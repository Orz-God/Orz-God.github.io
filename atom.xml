<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鱼人孑</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-09-13T17:17:41.379Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Orz-God</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络篇相关知识</title>
    <link href="http://yoursite.com/2016/09/13/%E7%BD%91%E7%BB%9C%E7%AF%87%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2016/09/13/网络篇相关知识/</id>
    <published>2016-09-13T13:38:19.000Z</published>
    <updated>2016-09-13T17:17:41.379Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>下列均转载自作者刘望舒 ，非常感谢！</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/1ae1170b9a9a" target="_blank" rel="external">Android网络编程（一）HTTP协议原理</a></p>
<p><a href="http://www.jianshu.com/p/af5ed498f2e2" target="_blank" rel="external">Android网络编程（二）HttpClient与HttpURLConnection</a></p>
<p><a href="http://www.jianshu.com/p/797306fac9e8" target="_blank" rel="external">Android网络编程（三）Volley用法全解析</a></p>
<p><a href="http://www.jianshu.com/p/e475f4479fb2" target="_blank" rel="external">Android网络编程（四）从源码解析Volley</a></p>
<p><a href="http://www.jianshu.com/p/f7ca8877cf9b" target="_blank" rel="external">Android网络编程（五）OkHttp2.x用法全解析</a></p>
<p><a href="http://www.jianshu.com/p/e15f90632692" target="_blank" rel="external">Android网络编程（六）OkHttp3用法全解析</a></p>
<p><a href="http://www.jianshu.com/p/1ec39a05708f" target="_blank" rel="external">Android网络编程（七）源码解析OkHttp前篇（请求网络）</a></p>
<p><a href="http://www.jianshu.com/p/35476796dd54#" target="_blank" rel="external">Android网络编程（八）源码解析OkHttp中篇（复用连接池）</a></p>
<p><a href="http://www.jianshu.com/p/c3837e928864" target="_blank" rel="external">Android网络编程（九）Retrofit2前篇（基本使用）</a></p>
<hr>
<blockquote>
<p>下列均转载自作者BlackSwift  ，非常感谢！</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/aad5aacd79bf" target="_blank" rel="external">OkHttp3源码分析[综述]</a></p>
<p><a href="http://www.jianshu.com/p/92a61357164b" target="_blank" rel="external">OkHttp3源码分析[复用连接池]</a></p>
<p><a href="http://www.jianshu.com/p/9cebbbd0eeab" target="_blank" rel="external">OkHttp3源码分析[缓存策略]</a></p>
<p><a href="http://www.jianshu.com/p/23b8aa490a6b" target="_blank" rel="external">OkHttp3源码分析[DiskLruCache]</a></p>
<p><a href="http://www.jianshu.com/p/6637369d02e7" target="_blank" rel="external">OkHttp3源码分析[任务队列]</a></p>
<hr>
<blockquote>
<p>下列均转载自简书作者烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫  ，非常感谢！</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/a44407f48321" target="_blank" rel="external">HttpClient-4.5总结（1）</a></p>
<p><a href="http://www.jianshu.com/p/bd7bea8eb487" target="_blank" rel="external">HttpClient-4.5总结（2）</a></p>
<p><a href="http://www.jianshu.com/p/f38a62efaa96" target="_blank" rel="external">HttpClient-4.5总结（3）</a></p>
<p><a href="http://www.jianshu.com/p/92a5d41cefc4" target="_blank" rel="external">HttpClient-4.5总结（4）</a></p>
<hr>
<blockquote>
<p>下列均转载自作者银狐公子  ，非常感谢！</p>
</blockquote>
<p><a href="http://blog.csdn.net/maoxiao1229/article/details/22886337" target="_blank" rel="external">基于android的Socket通信</a></p>
<hr>
<p><a href="http://www.cnblogs.com/devinzhang/archive/2012/01/08/2316453.html" target="_blank" rel="external">android之HttpURLConnection</a></p>
<p><a href="http://www.jianshu.com/p/a79f1f49371b" target="_blank" rel="external">对HttpURLConnection的简单封装</a></p>
<p><a href="http://www.jianshu.com/p/9d8784e81421" target="_blank" rel="external">Android HttpURLConnection及HttpClient对比</a></p>
<p><a href="http://www.jianshu.com/p/960fa7509891" target="_blank" rel="external">Android网络之HttpUrlConnection和Socket关系解析</a></p>
<p><a href="http://www.jianshu.com/p/8728e53a0d7e#" target="_blank" rel="external">Android网络之HttpUrlConnection和Socket关系图解</a></p>
<p><a href="http://www.cnblogs.com/angeldevil/p/3729808.html" target="_blank" rel="external">快速Android开发系列网络篇之Android-Async-Http</a></p>
<p><a href="http://www.jianshu.com/p/2910114bb78b" target="_blank" rel="external">Android网络开发之URLConnection和HttpURLConnection</a></p>
<p><a href="http://blog.csdn.net/vpingchangxin/article/details/23375461" target="_blank" rel="external"> android http多请求异步封装对你绝对有用</a></p>
<p><a href="http://www.jianshu.com/p/29b5d66079fa#" target="_blank" rel="external">Android个人总结之WebView的简单使用</a></p>
<hr>
<p><strong><font color="#FF7256">特别注意下列的网络请求：</font></strong></p>
<blockquote>
<p><a href="http://www.jianshu.com/p/3141d4e46240#" target="_blank" rel="external">Android网络请求心路历程</a><br><a href="http://www.jianshu.com/p/bd1a6fb7a44d#" target="_blank" rel="external">HttpRequest</a><br><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">Volley 源码解析</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">OkHttp使用教程</a><br><a href="http://duanyytop.github.io/2016/08/06/Retrofit%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">Retrofit用法详解</a><br><a href="http://www.jianshu.com/p/a56c61da55dd" target="_blank" rel="external">Retrofit2源码分析（动态代理）</a><br><a href="http://www.jianshu.com/p/fb8d21978e38" target="_blank" rel="external">Retrofit分析-经典设计模式案例</a><br><a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit分析-漂亮的解耦套路</a><br><a href="http://www.jianshu.com/p/9803a6efb672" target="_blank" rel="external">OkHttp3应用（HTTP DNS的实现）</a><br><a href="http://www.jianshu.com/p/d6fdfac5e97d#" target="_blank" rel="external">Socket通信简介</a><br><a href="http://www.jianshu.com/p/32d48ca7d0e0" target="_blank" rel="external">Android Webview总结</a><br><a href="http://www.jianshu.com/p/3fcf8ba18d7f" target="_blank" rel="external">史上最全WebView使用，附送Html5Activity一份</a><br><a href="http://www.jianshu.com/p/d2f5ae6b4927#" target="_blank" rel="external">WebView你真的熟悉吗？看了才知道</a><br><a href="http://www.jianshu.com/p/c86581cb343e#" target="_blank" rel="external">Cordova+Crosswalk打包WebApp</a><br><a href="http://www.jianshu.com/p/d3ef9c62b6c8" target="_blank" rel="external">还在用Android自带的WebView组件？太Out了！</a><strong><font color="#FF7256">（Crosswalk）</font></strong><br><a href="http://www.jianshu.com/p/1fb294ec7e3b" target="_blank" rel="external">RxJava + Retrofit完成网络请求</a><br><a href="http://gank.io/post/56e80c2c677659311bed9841" target="_blank" rel="external">RxJava 与 Retrofit 结合的最佳实践</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0105/3831.html" target="_blank" rel="external">OkHttp的使用简介及封装，实现更简洁的调用</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0504/4208.html" target="_blank" rel="external">Retrofit2 完全解析 探索与okhttp之间的关系</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0519/4279.html" target="_blank" rel="external">Retrofit–使用Retrofit时怎样去设置OKHttp</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0518/4270.html" target="_blank" rel="external">你真的会用Retrofit2吗?Retrofit2完全教程</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0816/6543.html" target="_blank" rel="external">教你一分钟实现动态模糊效果</a><br><a href="http://www.tuicool.com/articles/vmMjua2" target="_blank" rel="external">Volley+OkHttp3+Gson（Jackson）开源库的封装过程</a></p>
</blockquote>
<hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;下列均转载自作者刘望舒 ，非常感谢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/1ae1170b9a9a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Andro
    
    </summary>
    
      <category term="HttpClientHttp、URLConnection、OkHttp以及http" scheme="http://yoursite.com/categories/HttpClientHttp%E3%80%81URLConnection%E3%80%81OkHttp%E4%BB%A5%E5%8F%8Ahttp/"/>
    
    
      <category term="http/https" scheme="http://yoursite.com/tags/http-https/"/>
    
      <category term="retrofit2" scheme="http://yoursite.com/tags/retrofit2/"/>
    
      <category term="OkHttp3" scheme="http://yoursite.com/tags/OkHttp3/"/>
    
      <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
      <category term="HttpClientHttp" scheme="http://yoursite.com/tags/HttpClientHttp/"/>
    
      <category term="URLConnection" scheme="http://yoursite.com/tags/URLConnection/"/>
    
      <category term="Volley" scheme="http://yoursite.com/tags/Volley/"/>
    
      <category term="Crosswalk" scheme="http://yoursite.com/tags/Crosswalk/"/>
    
  </entry>
  
  <entry>
    <title>自动化测试及抓包分析</title>
    <link href="http://yoursite.com/2016/09/13/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%8F%8A%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/09/13/自动化测试及抓包分析/</id>
    <published>2016-09-13T13:00:08.000Z</published>
    <updated>2016-09-17T04:18:00.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong><font color="#FF7256">以下均为配合网络请求转载的文章</font></strong></p>
</blockquote>
<p><a href="http://www.cnblogs.com/TankXiao/p/3316355.html" target="_blank" rel="external">如何学习自动化测试</a></p>
<hr>
<p><a href="http://www.cnblogs.com/TankXiao/p/5451469.html" target="_blank" rel="external">Android ADB 用法</a></p>
<hr>
<p><strong><font color="#FF7256">抓包工具使用：</font></strong></p>
<p><a href="http://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html" target="_blank" rel="external">Fiddler 教程</a></p>
<p><a href="http://www.cnblogs.com/guodongdidi/p/4914408.html" target="_blank" rel="external">Fiddler+Jmeter+断言 详细教程</a></p>
<p><a href="http://www.cnblogs.com/maifengqiang/p/3863168.html" target="_blank" rel="external">超级详细Tcpdump 的用法</a></p>
<p><a href="http://www.cnblogs.com/zhuhongbao/p/3230046.html" target="_blank" rel="external">HttpWatch手把手图解教程</a></p>
<p><a href="http://www.cnblogs.com/TingyunAPM/p/5445476.html" target="_blank" rel="external">Android 常用抓包工具介绍之Charles</a></p>
<p><a href="http://www.trinea.cn/android/android-network-sniffer/" target="_blank" rel="external">Android利用Fiddler进行网络数据抓包</a></p>
<p><a href="http://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html" target="_blank" rel="external">Wireshark基本介绍和学习TCP三次握手</a></p>
<p><a href="http://www.cnblogs.com/tina-smile/p/5467447.html" target="_blank" rel="external">wireshark使用心得</a></p>
<hr>
<p><strong><font color="#FF7256">android自动化测试：</font></strong></p>
<p><a href="http://www.cnblogs.com/TankXiao/p/4815134.html" target="_blank" rel="external">Android Monkey 压力测试介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#FF7256&quot;&gt;以下均为配合网络请求转载的文章&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/TankXiao/
    
    </summary>
    
      <category term="android测试" scheme="http://yoursite.com/categories/android%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Fiddler" scheme="http://yoursite.com/tags/Fiddler/"/>
    
      <category term="ADB" scheme="http://yoursite.com/tags/ADB/"/>
    
      <category term="Tcpdump" scheme="http://yoursite.com/tags/Tcpdump/"/>
    
      <category term="Jmeter" scheme="http://yoursite.com/tags/Jmeter/"/>
    
      <category term="Wireshark" scheme="http://yoursite.com/tags/Wireshark/"/>
    
      <category term="Charles" scheme="http://yoursite.com/tags/Charles/"/>
    
  </entry>
  
  <entry>
    <title>十批判书</title>
    <link href="http://yoursite.com/2016/09/07/%E5%8D%81%E6%89%B9%E5%88%A4%E4%B9%A6/"/>
    <id>http://yoursite.com/2016/09/07/十批判书/</id>
    <published>2016-09-07T03:19:06.000Z</published>
    <updated>2016-09-17T02:06:22.434Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong><font color="#FF7256">郭沫若 著作</font></strong>        </p>
</blockquote>
<h4 id="郭沫若《十批判书》（1）"><a href="#郭沫若《十批判书》（1）" class="headerlink" title="郭沫若《十批判书》（1）"></a>郭沫若《十批判书》（1）</h4><h5 id="古代研究的自我批判"><a href="#古代研究的自我批判" class="headerlink" title="古代研究的自我批判"></a><strong><font color="#FF7256">古代研究的自我批判</font></strong></h5><p>关于秦以前的古代社会的研究，我前后费了将近十五年的工夫，现在是达到了能够作自我批判的时候。我首先要谴责自己。我在一九三〇年发表了《中国古代社会研究》那一本书，虽然博得了很多的读者，实在是太草率，太性急了。其中有好些未成熟的或甚至错误的判断，一直到现在还留下相当深刻的影响。有的朋友还沿用着我的错误，有的则沿用着我错误的征引而又引到另一错误的判断，因此关于古代的面貌引起了许多新的混乱。这个责任，现在由我自己来清算，我想是应该的，也是颇合时宜的。我在这儿想先检讨一下处理材料的问题。</p>
<p><strong><font color="#FF7256">甲、</font></strong> 关于文献的处理无论作任何研究，材料的鉴别是最必要的基础阶段。材料不够固然大成问题，而材料的真伪或时代性如未规定清楚，那比缺乏材料还要更加危险。因为材料缺乏，顶多得不出结论而已，而材料不正确便会得出错误的结论。这样的结论比没有更要有害。研究中国古代，大家所最感受着棘手的是仅有的一些材料却都是真伪难分，时代混沌，不能作为真正的科学研究的素材。关于文献上的辨伪工作，自前清的乾、嘉学派以至最近的《古史辨》派，做得虽然相当透彻，但也不能说已经做到了毫无问题的止境。而时代性的研究更差不多是到近十五年来才开始的。例如《周易》固然是无问题的先秦史料，但一向被认为殷末周初的作品，我从前也是这样。据我近年来的研究，才知道它确是战国初年的东西，时代拉迟了五六百年。我在前把《周易》作为研究殷末周初的资料，当然是完全错误。又如《尚书》，我们早已知道有今古文之别，古文是晋人的伪作，但在今文的二十八篇里面也有真伪，也是到近年来才开始注意到的。例如《尧典》(包括古文的《舜典》)、《皋陶谟》(包括古文的《益稷》)、《禹贡》、《洪范》这几篇很堂皇的文字，其实都是战国时代的东西一一我认为当作于子思之徒。我在前虽不曾认《典》、《谟》为“虞书”，《禹贡》为“夏书”，以作为研究虞夏的真实史料，但我却把《洪范》认为确是箕子所作，曾据以探究过周初的思想，那也完全是错误。《吕刑》一篇，文体与《左传》相近，旧称为周穆王所作，我也相信不疑。但其实那也是靠不住的。我揣想它是春秋时吕国的某王所造的刑书，而经过后来的儒者所润色过的东西。吕国曾称王，彝器中有《吕王作内姬壶》可证，由文字上看来是春秋时的器皿。吕国是大嶽伯夷之后，故《吕刑》中两称伯夷，而位在禹、稷之上。这已尽足以证明它决不是周穆王所作的了。《诗》三百篇的时代性尤其混沌。《诗》之汇集成书当在春秋末年或战国初年，而各篇的时代性除极小部分能确定者外，差不多都是渺茫的。自来说《诗》的人虽然对于各诗也每有年代规定，特别如像传世的《毛诗》说，但那些说法差不多全不可靠。例如《七月流火》一诗，《毛诗》认为“周公陈王业”，研究古诗的人大都相沿为说，我自己从前也是这样。但我现在知道它实在是春秋后半叶的作品了。就这样，一悬隔也就是上下五百年。关于神话传说可惜被保存的完整资料有限，而这有限的残存又为先秦及两汉的史家所凌乱。天上的景致转化到人间，幻想的鬼神变成为圣哲。例如所谓黄帝(即是上帝、皇帝)、尧、舜其实都是天神，却被新旧史家点化成为了现实的人物。这项史料的清理，一直到现在，在学术界中也还没有十分弄出一个眉目来。但这倒是属于史前史的范围，已经超出了古代，并已经超出了历史了。在这一方面，我虽然没有作出什么特殊的贡献，但幸而早脱掉了旧日的妄执，没有陷入迷宮。</p>
<p><strong><font color="#FF7256">乙、</font></strong> 关于卜辞的处理靠着殷虚的发现，我们得到一大批研究殷代的第一手资料，是我们现代考古者的最幸福的一件事。就靠着这一发现，中国古代的真面目才强半表露了出来。以前由后世史家所累积构成的三皇五帝的古史系统已被证明全属子虚，即是夏代的有无，在卜辞中也还没有找到直接的证据。但至少殷代的存在是确实被保证着了。卜辞的研究要感谢王国维，是他首先由卜辞中把殷代的先公先王剔发了出来，使《史记·殷本纪》和《帝王世纪》等书所传的殷代王统得到了物证，并且改正了它们的讹传。如上甲之次为匚乙、匚丙、匚丁，而非报丁、报乙、报丙，主壬、主癸本作示壬、示癸，中宗乃祖乙而非大戊，庚丁乃康丁之讹，大丁以文丁为是，均抉发了三千年来所久被埋没的秘密。我们要说殷虚的发现是新史学的开端，王国维的业绩是新史学的开山，那样评价是不算过分的。王国维死后，殷虚的科学发掘使卜辞研究进到断代研究的一步。卜辞是由武丁至殷末的遗物，绵延二百年左右，先年只能浑沌地知其为殷，近年我们可以知道每一辞或每一片甲骨是属于那一王的绝对年代了。这样便更增进了卜辞的史料价值，在卜辞本身中我们也可以看出发展了。我自己在这一方面也尽了一些绵力，如王国维发现“先妣特祭”之例，足证殷代王室还相当重视母权。但我继进又发现了所特祭的先妣是有父子相承的血统关系的，便是直系诸王的配偶虽被特祭，而兄终弟及的旁系诸王的配偶则不见祀典。这又证明立长立嫡之制在殷代已有它的根蒂。以上可以说是几项重要的发现。卜辞的研究虽然由王国维开其端，但嗣后的成绩却比王氏更大大的进步了。王氏在卜辞研究之余有《殷周制度论》之作，认为“中国政治与文化之变革莫剧于殷、周之际”，这是一篇轰动了全学界的大论文，新旧史家至今都一样地奉以为圭臬。在新史学方面，把王氏的论文特别强调了的，首先是我。我把它的范围更扩大了，从社会发展方面来看，我认为殷代是原始公社的末期，周代是奴隶社会的开始。这一扩大又引起了别一种的见解，认为殷代是奴隶社会的末期，周代是封建社会的开始。这见解到现在都还在相持，但其实都是由于演绎的错误。我自己要承认我的冒昧，一开始便把路引错了。第一我们要知道，《殷周制度论》的价值已经不能够被这样过高估计了。王氏所据的史料，属于殷代的虽然有新的发现而并未到家，而关于周代的看法则完全是根据“周公制作之本意”的那种旧式的观念。这样，在基本上便是大有问题的。周公制礼作乐的说法，强半是东周儒者的托古改制，这在目前早已成为定论了。以这样从基本上便错误了的论文，而我们根据它，至少我们可以说把历史中饱了五百年，这是应该严密清算的。卜辞研究是新兴的一种学问，它是时常在变迁着的。以前不认识的事物后来认识了，以前认错了的后来改正了。我们要根据它作为社会史料，就应该采取“迎头赶上”的办法，把它最前进的一线作为基点而再出发。目今有好些新史学家爱引用卜辞，而却没有追踪它的整个研究过程，故往往把错误了的仍然沿用，或甚至援引错误的旧说以攻击改正的新说，那是绝对得不到正确的结论的。</p>
<p><strong><font color="#FF7256">丙、</font></strong> 关于局青铜器的处理在古代研究上与卜辞有同等价值或甚至超过它的，是殷、周青铜器的铭文。关于这项资料的研究，在北宋时已开其端，已经有一千年的历史了。近五十年来研究这项学问的人才辈出，如吴大澂、孙诒让、王国维，都是很有贡献的。这项资料之所以与卜辞有同等价值或甚至超过它，是因为它也是第一手的资料，数量既多，而且铭文有长至四五百字的，与卜辞的简短而几乎千篇一律的情形不同。但这项资料也有它的缺陷，便是出土地多不明白，亘殷周两代千有余年，各器的时代相当浑沌。故如深懂科学方法的王国维，，他便发出了这样的慨叹：“于创通条例，开拓阃奥，概乎其未有闻”（《殷虚书契考释序》）。这是很知道甘苦者的评判，而决不是漫无责任、任意抹煞一切者的放言。王氏心目中的“条例”究竟是怎样，因为他自己没有“创通”出来，我们无从揣测。但我们准一般史料研究的公例，大凡一项资料，总要它的时代性准确，然后才有充分的史料价值。殷、周的年代太长，浑而言之日殷、周，或分而言之日殷曰周，都太含混了。因此自北宋以来无论仅存于著录或尚流传于人间的器物尽管将近万件，而却是一团大浑沌。以前的人也略略分殷分周，甚至有分出夏代来的。但所谓夏器近已被证明，不是伪器便只是春秋末年的作品。夏器迄今在铜器中尚无发现。殷、周之分，所据的标准是所谓“以日为名”。古时传说殷人以生日为名，故名中多见甲乙丙丁字样。因此凡彝铭中有祖甲、父乙，妣庚、母辛，或兄壬、妇癸者，在前便一律认为殷彝。其实这标准是不一定可靠的。近年发现穆王时的《遹簋》有“文考父乙”，懿王时的《匡卣》有“文考日丁”，足见“以日为名”之习至西周中叶也还有残余，而且已被证明，不是生曰而是死日了。这一条例一被打破，于是举凡以前的著录中所标为殷器的都成了问题。而尤其像罗振玉的《殷文存》那部书，主要根据“以日为名”而搜集的七百种以上的器皿，差不多全盘靠不住。我说“差不多”，因为那里面有些确是殷器。据我们现有的知识，凡疑似殷器中可确切断定为殷器的还不上一打。因此，我在前无条件地把《殷文存》作为研究殷代的资料而使用，近来还有不少的朋友以讹传讹，我是要承认我的冒昧的。中国青铜器可确定为殷代的均属于殷末，在其前的还未发现。一出马，青铜冶铸的技术便很高度，这是很值得讨论的一个问题。是在黄河流域更早期的器皿还未发现，还是根本没有而那技术是从南方的江淮流域输入的，这些都只好等将来的地下发掘来回答。我揣想后者是比较有更大的可能性，因为古来相传江南是金锡的名产地，而南方的发掘先例向来是很少的。或许是南方低湿，古器不容易保存的原故吧?</p>
<p>周代的铜器很多，在前依然只是一片浑沌，即使偶有年代划分也是漫无标准。例如很有名的《毛公鼎》，以前的人便认为是周文王的儿子毛叔的东西，但近年已经知道它是周宣王时代的作品了。我自己费了五六年的研究，得到一个比较明晰的系统，便是我所著录的《两周金文辞大系》的《图录》和《考释》。我是先寻到了一些自身表明了年代的标准器，把它们作为连络站，再就人名、事迹、文辞的格调、字体的结构、器物的花纹形式等以为参验，便寻出了一个至少比较近是的条贯。凡有国度表明了的，也在国别中再求出时代的先后。就这样我一共整理出了三百二十三个器皿，都是铭文比较长而史料价值比较高的东西，两周八百年的浑沌似乎约略被我凿穿了。从这儿可以发展出花纹学、形制学等的系统，而作为社会史料来征引时，也就更有着落了。就两周的铜器而言，武王以前的器物无所发现，武王以后的则逐代增多。但西周的多是王室及王臣之器，诸侯国别之器极其罕见，到了东周则王室王臣之器匿迹，而诸侯国别之器极其盛行。从这儿可以看出文化的进展，武王以前的周室没有什么高度的文化，平王以后的周室则是式微得不堪了。毫无问题，周人的文化是承继着殷人来的，单从文字的演变上也可以寻出它们递禅的痕迹。周人承用殷人文字，每每有类似之字而被周人错用了的(即是后人的写别字)。如勿（少一撇）勿本非一字，却被周人混同了。根据卜辞，勿（少一撇）本犁之最古字，被周人误用为勿，即其一例。周人的彝器得到整理，于是乎周公制礼作乐之说纯是一片子虚。周公在周初是一位有权变的政治家，那是毫无疑问的。但周人的礼强半是在西周三百年间逐渐累积而成，其中毫无疑问有很多殷礼的成分；至其构成为所谓“礼仪三百，威仪三干”的，还是自战国中叶以后。这层关系不明而纵论“殷、周礼制”，那是必然要错误的。大体上二千多年前的孔子所说过的话依然正确，便是：“周因于殷礼，所损益可知也。”（《论语·为政》，在前的王国维，其后的我，又其后的认西周为封建制的新史学家们，其实都是错了的。</p>
<p><strong><font color="#FF7256">一、</font></strong> 古器物中所见的殷周关系先就卜辞考察，殷人自己是始终称为商，不称为殷的。称殷似乎是出于周人的敌忾，初称为“衣”，古书中或作郼，在古与衛当是一字，入后更转为殷。《吕氏春秋·慎大览》“亲郼如夏”，高诱注云：“郼读如衣，今兖州人谓殷氏皆曰衣。”《康诰》“殪戎殷”，《中庸》作“壹戎衣”。武王时代的《大丰簋》“丕克乞衣王祀”，鲁炀公时的《沈子簋》也称“迺妹(敉)克衣”，“衣”都是殷。但到周康王末年的《大盂鼎》便直称为殷了一一“我闻殷坠命，惟殷边侯甸，粤殷正百辟，率肄于酒。”衣本是一个小地名，在卜辞里时常见到，是殷王田猎的地方，据我考证，当在河南沁阳县境内，即是《水经》沁水注所说的殷城。周人对于敌国不称其本号的商，而称为衣或殷，大约也就如像我们在抗战时期宁愿称日本为倭，而日本人也宁愿称中国为支那一样的吧。周人在卜辞中屡次出现，有一例称为“周侯”的，此外有几例说到“聘周”，大抵都是武丁时候的卜辞，足证殷、周本来是同盟兄弟之国。关于“聘”字结构很奇怪，照那最复杂的一个字样写下来可以写成■字，我从前释为寇，那是不正确的。按照字的构成应该是从灿玉由(缶也，盛玉之器)，■(古兵字)声，说为聘字，较为合理。武丁以后，周人在卜辞里面便很少见了。据古本《竹书纪年》，言“文丁杀季历”，大约是实在的事。自此以后殷、周遂成世仇，周文王蓄意报复，没有成功，到周武王的手里公然也就把仇报了。但周武王之所以能够报仇雪恨把殷朝的王室颠覆了的，倒并不是因为殷纣王(帝辛)怎样暴虐，失掉了民心，而实在是有另外的一段历史因缘的。这段古史的真相也因卜辞的发现才得大白于世。殷末在帝乙、帝辛两代，曾长期和东南夷发生战争。据卜辞所载，帝乙十年及二十年屡次征讨夷方，地点不是在山东的齐与雇，便是在淮水流域的条与灊，和“渐居淮岱”的东南夷合拍，可知夷方即指东南夷。在帝辛的一代，《左传》上也屡屡说到，说他“为黎之蒐东夷叛之”（昭公四年），说他“克东夷而殒其身”（昭公十一年），说他“百克而卒无后”（宣公十二年）；可见帝辛继承父业，屡次用兵，终于是把东南夷平定了，故尔他能“有亿兆夷人”作他的“臣”（昭公二十四年）一一就是奴隶。俘虏能有亿兆，战争可见猛烈，殷将士的损失也必定不在少数。就在这样的情形下边周人乘虚而入，殷纣王用俘虏兵对敌，卒致“前徒倒戈”，遭了失败。这便是殷、周之际的所谓征诛的实际。只有三千奴隶的小奴隶主周人结果把有亿兆奴隶的大奴隶主殷人打败了。殷人之所以致败，主要是在帝乙、帝辛经略东南夷的征战上流血过多；其次大约殷人好酒，生活腐化，也是一个重要的原因吧。但殷人虽被打败，并没有灭亡；在殷纣王的儿子武庚时又还反抗过一次，结果又被周公打败；殷人及其同盟民族的一部分便遭了奴役。“殷民六族”被给予鲁公伯禽，“殷民七族”被给予卫康叔。“怀姓九宗”被给予唐叔虞（定公四年），还有些“顽民”被迁于洛邑一一主要也就是建筑来镇抚殷人的一个军事和政治的据点。另一部分的殷人和他们的同盟民族则被压迫到江淮流域，即殷纣王所开拓出来的东南夷旧地，便成为宋、楚、徐等国。终周之世南北都是对立着的。</p>
<p><strong><font color="#FF7256">二、</font></strong> 论所谓“封建”制旧时说夏、殷、周三代为封建制，以别于秦后的郡县制，这是被视为天经地义的历史事实，从来不曾有人怀疑过，也是不容许人怀疑的。但近年来因封建制被赋与了新的意义，因而三代是封建制之说便发生了动摇。但古时所说的“封建”，是“封诸侯，建藩卫”的事，假使是在这种含义上，要说三代或至少周代是“封建制”，那当然是可以说得过去的。夏代渺茫得很，我们现在还不好多谈。就在周朝初年的人说到殷代的史事虽然相当详细，而说到夏代的便已经很少，看《尚书?无逸》等篇便可以知道。我们更后了三四千年，又无地下发掘可据，我们拿什么来说呢?殷代是有材料可以说的。卜辞里面已经有所谓“诸侯”的痕迹，例如屡见“多田(甸)”与“多伯”，又有“周侯”、“噩侯”、“皃伯”、“盂伯”等称谓。周初的《大盂鼎》也称“维殷边侯甸”。故如《孟子》、《王制》、《周官》等所说的五等诸侯，《禹贡》、《职方》等所说的五服九服等所用的一些字面，至少有一部分，在殷代是已经出现了。到了周代所可说的材料更加多了。首先是《左传》定公四年所载的鲁、卫、晋的分封；又如僖公二十四年的“周公吊二叔之不咸，故封建亲戚以藩屏周，管、蔡、郕、霍、鲁、卫、毛、聃、郜、雍、曹、滕、毕、原、酆、郇，文之昭也；邘、晋、应、韩，武之穆也；凡、蒋、邢、茅、胙、祭，周公之胤也”；昭公二十八年的“武王克商，光有天下，其兄弟之国者十有五人，姬姓之国者四十人”；这些我们都可以承认。因为古时所谓“国”本是等于部落的意思，所谓“封建藩卫”也不过是建置大小不等的各种殖民部落而已。异姓之国大抵是原有的部落，同姓之国则多系从新建设的。《孟子》、《王制》等的五等爵禄，《禹贡》、《职方》等的畿服制，本互有出入，而他们的物证，我们在周代的彝铭里面找不出来。就彝铭所可考见的诸侯的称谓来说，并无所谓等级。如鲁于《春秋》称公而彝器中称侯，晋于《春秋》称侯而彝器中称公，秦于《春秋》称伯而有《秦公钟》、《秦公簋》，又有《秦子戈》。滕、薛之器一律称侯，邾有《邾公华》、《邾公■》、《邾公■》等钟，而又有《邾伯鼎》、《邾伯鬲》。曾有《曾伯簋》，有《曾子簠》。邓乃称公，都不见于《春秋》盟会者亦称公。许不称男而称子。这些都是有古器物可为证明的。足见等级之制只是后世儒家的依托。王国维更有一个重要的发现，便是古诸侯在其国内可以称王，他结论是：“古时天泽之分未严，诸侯在其国自有称王之俗，即徐、楚、吴、越之称王者亦沿周初旧习，不得尽以僭窃目之。”这结论是很有根据的。古诸侯在国内既可称王，因而其臣下亦每自称其首长为“天子”，如《献簋》称其君椃伯为“朕辟天子椃伯”便是绝好的例证。但近时的新史学家有的竟连这个发现都不承认，以为称王者仍是化外诸国的僭窃。其实如像《散氏盘》之“夨王”，那是与散氏同在大散关附近的国家，以年代言则在厉王之世。这个宗周畿辅附近的小国也公然称王。且除《散氏盘》之外还有《夨王尊》自称曰“夨王作宝尊”，有《同卣》曰“夨王锡同金车弓矢”。别有《散伯作夨姬簋》，可见矢还是姬姓之国，这是断难目为化外的。其实要肯定周代的“封建”是一回事，不必一定要否定儒者的托古改制。即使否定儒者的托古改制，而认为周代确有五等诸侯或五等畿服，也和我们现代所说的封建社会的观念完全不同。在这儿不容许我们的新旧观念绞线。现代的封建社会是由奴隶社会蜕化出来的阶段。生产者已经不再是奴隶，而是被解放了的农工。重要生产工具，以农业而言，便是土地已正式分割，归为私有，而有剥削者的地主阶层出现；在工商方面则是脱离了官家的豢养，而成立了行帮企业。建立在这阶层上面的国家是靠着地主和工商业者所献纳的税收所维持着的。这是我们现代所说的封建社会。周代尤其西周的经济情形究竟是不是这样的呢?这是我们应该探讨的中心问题，我们进一步来向这个问题追索吧。</p>
<p><strong><font color="#FF7256">甲、</font></strong> 关于殷代的生产状况我们先来研究殷代的生产情形。就卜辞所见，殷代的牧畜应该还是相当蕃盛的，因为祭祀时所用的牲数很多，每每有多至五百头牛的。而牲类则牛羊犬豕俱有，也有了大牢(牛羊豕)和少牢(羊豕)的名称。用牲的方法也非常繁多。这和传说上的盘庚以前殷人八迁、盘庚五迁的史影颇为合拍。这样屡常迁徙，是牧畜民族的一种特征。但农业却已经成为了主要的生产了。田畴农藉等字已经出现；禾黍来麦穑禀等字也数见不鲜。和农业相关的历法已经相当的严密，例如年字从人负禾，也就是象征一年的收获。春秋冬夏等节季名称虽然还没有得到确证，但已有年终置闰称为“十三月”，系为调整十二月之太阴历与四季之太阳历而设，则四季当已划分。又有祈年的纪录，据所标明的月分上看来，多在春秋二季，似乎周人所行的春社秋社的典礼在殷时已经萌芽了。此外也还屡见“告麦”和“观黍”等的纪录，足见农产品之被重视。祭神时多用酒鬯，这是农产的再制品，没有农业的发达是不能想象的。殷人好酒也就间接地说明了这回事。蚕桑丝帛等字已经出现了，大率丝织业也是发明了的。工艺品的名汇相当多，殷虚出土的实物也不少。周初的文献里面已经有“百工”的称谓，当然是沿着殷代而来。这些都足以为农业已经发达的旁证。农耕的工具，由藉字的构成看来有“未”，原字像一人执一柄两股叉的工具在操作。这两股叉的工具是耒，从金文耒字藉字可以旁证，汉代武梁祠石刻中的夏禹手里也操着这个东西。又有犂字作勿（少一撇），像用耒启土之形。虽然多假借为犂牛之犂(黑色)，原文为农具字是毫无问题的。但这些耒，是用木制，还是用金属，无从断定。用铁之事在殷代不能有，青铜器的耕具在中国不曾发现过，就在全世界上也不曾发现过。或者两叉的耒就是木叉，所谓“斲木为耜，揉木为耒”。而犁锄之类或用尖石与海蚌，所谓“剡耜而耕，摩蜃而耨”。由农字从辰，耨字从辰等看来，辰当是耕器，即是蜃之初文。卜辞辰字极多见，其字形上部或作曲线之弯曲形像蚌，或作直线之磬折形象石，可知殷代耕具确曾经过蚌制与石制两个阶段。这些用具是不是已经下了舞台，我们还不敢断言。要说用这样原始的耕具为什么发展出相当高度的农业，我看这也不难于说明。因为用多量的奴隶作过分的榨取，是可以达到这个目的的。这是工具的原始性发挥着奴隶制的制约性，或保障作用，不然便会用不着大规模的奴隶生产了。殷人耕田是不是在用大规模的奴隶呢?是在用大规模的奴隶。耕田的人称为“众”或“众人”，我引几项卜辞在下边吧。乙巳卜毅贞：王大令众人曰协田!其受年。十一月。(《粹》八六六，(前)七、三〇、二，又《续》二、六、五)戊寅卜宾贞：王往，以众黍子同。（《卜》四七三，《前》五、二〇、二）贞维小臣令众黍。一月（《卜》四七二，《前》四、三〇、二）这些“众”字都作“日下三人形”，耕种的规模就原辞的气势上看来也是相当宏大的。周初的诗里面耕种者依然叫着“众人”，如《周颂·臣工》“命我众人，庤乃钱镈，奄观铚艾”，便是明证。又有名的《曶鼎》是穆王以后的器皿(因原铭有“周穆王大室”语，我参以它证断定为孝王时器)。铭文的第三段载有名叫匡季的，在一次饥荒年辰抢劫了曶的禾稻十秭；曶控诉匡季于东宫，匡季自愿以田五田、众一夫、臣三人来赔偿。可见众与臣是同性质的东西，而是可以任意转移物主的什物。“众”或“众人”就在周穆王以后都还是奴隶，在殷代的情形便可以由这儿逆推了。在这儿《尚书·盘庚》三篇值得我们引用，以前我把它们的价值评判过低，现在可以承认是错了。那三篇东西确实是殷代的文献，但次序可是紊乱了。现有的《盘庚上篇》是告“众戚”的，是迁殷以后相当久的事；《盘庚中篇》是将迁时告民众的；《盘庚下篇》是迁徙后不久告百姓的。民众、百姓、众戚，三篇的对象不同，三种人的身分也是不同的。民众是“畜民”，也就是奴隶；百姓是百官，是“邦伯师长百执事之人”，众戚是“婚友”，是同姓或异姓的贵族。“畜民” 亦屡称为“众”，和卜辞的用语是相契合的。在卜辞中众或众人又屡用以从事战争。这是当然的事体。凡是奴隶社会的生产者，在战时也就是战士，这是公例。因此我们可以知道牧野之战前徒倒戈的“亿兆夷人”，在平时也必然是农夫或其他从事工艺的人了。殷代确已使用大规模的奴隶耕种，是毫无问题的。因此，我在十几年前认为殷代是原始公社制末期的那种看法，当然要修正才行。殷人是不是已经用牛耕，没有直接的证据。有犁字作年，从牛，但均用作犂牛(黑色的牛)，不知道哪一种是它的本义。又牛字每于角上加横画以示梏，常见告字，即系梏之初文，牛当然已在被服用了，但不知道是用来耕田，还是用来拉车。依照殷人的传说，服牛是先公王亥所发明的。牛既用以拉车，当然也可用以耕田，这或者也就是使殷人农业能够发展的另一个重要因素吧。殷人的商行为无疑是已经开始了。《周书·酒诰》称妹土人“肇牵车牛远服贾”，肇者始也，可见在周初人的眼目中认商行为是始于殷。大约就因为这样，所以后世称经营这种行为的人便为“商人”的吧。但在卜辞里面，关于商行为的直接的例子无可考见。贝字是出现了。这个字的出现尽足以表示商行为业已存在。贝即贝子，学名所谓“货贝”(Cypreamoneta)，是南海出产的东西，特别以中南半岛附近所产为名贵；东海海岸不产此物，殷代已有贝，可知必自南方输入。至今南洋土人犹呼贝子为Bia，音与华语相近，可知贝之为物不仅是三四千年前的舶来品，即贝字读音也是三四千年前的舶来语。贝子的输入是由实物交易而得，毫无疑问。初人中国只是当着装饰品使用的，以若干贝为一朋，一朋即是一条颈链，故賏字从贝(賏，贝连也)，贲字从贝(贲，饰也)，赞字从贝(赞，美也)。贝不易得，后来替之以骨，更替之以石，全仿贝子之形而加以刻画。后来更兼带有货币的作用。但这转化过程是到周代才完成了的。周代彝器有《遽伯还簋》，其铭为“遽伯还作宝阝尊彝，用贝十朋又四朋”，大约是西周末年的器皿。这确实是把贝子作为货币在使用了。贝子兼有货币作用之后又有铜制的仿造品出现，骨董家称之为“蚁鼻钱”。罗振玉说：“蚁鼻钱间有有文字者，验其书体乃晚周时物。”据我所见到的实物，他这个断定是正确的。周初的彝器中有以金属的若干分量为赏罚的例子，我们可据以推定是承继了殷人的习惯而来的。</p>
<p>第一是《禽簋》：王伐楚侯，周公某(诲)禽祝，禽又(有) 臤(贤)祝，王易(锡)金百寽。周公，据我考定即是周公旦，禽即伯禽，伯禽在周曾为大祝，别有《大祝禽鼎》可证。“金百寽”即铜一百寽。寽重十一铢又二十五分之十三。这个字在今文《尚书·吕刑》作率（见《史记·周本纪》），古文《尚书》误作锾（今本《书经》如是）。率是译音，亦或作律，锾是读了别字。东汉的古文家们古文程度并不深，时常爱读别字。</p>
<p>第二是《师旅鼎》：唯三月丁卯，师旅众仆不从王征于方，雷使厥友弘以告于伯懋父。伯懋父乃罚得夏古三百寽，今弗克厥罚。伯懋父，经我考定即卫康叔的儿子康伯髦。于方当即卜辞所常见的盂方，是东南夷里面的一族。王，无疑是周成王。“罚得”下一字可惜不认识，或者是显字的变体，读为献。但顶重要的是古今两字相对待，器既属于周初，言今自然是指周，言古则当然是指殷了。据此可见殷、周的衡量一定有轻重的不同，殷寽必重于周，故言“今弗克厥罚”。而且金属的使用价值，在殷代已经用一定的衡量来表示，也是毫无问题的。不过这些例子，我们只知道殷末周初已经在宝贵贝玉，或者竟以之为货(商品)，但不是已成为价值媒介的纯粹货币，这层我们是须得注意的。殷末的商业只能在物物交易的阶段，我们从周代经济的发展上来看，更可以得到详细的证明。</p>
<p><strong><font color="#FF7256">乙、</font></strong> 关于西周的生产状况西周的文化大体上是承继殷人的遗产。我们无论从周初的彝器来看，或从《尚书》里面的《大诰》、《康诰》、《酒诰》、《召诰》、《洛浩》、《多士》、《多方》、《无逸》、《君奭》那几篇来看，周人自己都承认着是接受了殷人的遗产，而且要以殷先哲王为模范。故从文字结构上看不出差别，在器物形制上看不出差别，甚至如年月日的写法一如欧洲的方式把年放在最后，也看不出差别。殷人用卜，周人也用卜，只是我们现在还没有发现周人的甲骨文字而已；谁也不能断定说：周人一定没有。殷人祀天，周人也祀天；殷人祭祖宗，周人也祭祖宗；侯甸男邦采卫是沿用着殷人的体制，所有一切的内服外服也一仍旧贯。除掉因军事胜利的结果，主客易位，把殷人奴化，而建立了一些周人的殖民部落而外，我们所看到的最显著的差异，便是殷人嗜酒，周人严厉禁酒；祭祀时殷人用牲特别多，而周人十分少，如此而已。周公禁酒确是很厉害的，动辄便要杀人。但这禁酒和嗜酒的区别，与其从道德性上去追求它们的根源，倒应当是由于生产力有强有弱吧。酒是农业的精制品，嗜酒必以农业发达为前提。周人生于比较硗瘠的西北，不敢把农产品多事浪费，放养成了禁酒的习惯。周人虽以农神后稷为祖，只表示他们尊重农业，并不能作为农业十分发展的根据。周人的周字是古初的琱字，《函皇父簋》周女员一件作琱女员，便是明证。字像平板上有点线的碉画，金文画字下体从周，也就是象征一只手执刀笔在琱刻点线。有人以古周字和田字相近(古文周或省口，而于田字形的空白中各加一点)，以为是像周人的农田种植，那也完全是臆说。用牲数少，毫无疑问是牧畜业衰颓了的现象。我们看《召诰》里面所用的牲数吧：“丁巳，用牲于郊，牛二。越翼日戊午，乃社于新邑，牛一，羊一，豕一。”再看《洛诰》里面所用的牲数吧：“戊辰，王在新邑烝祭岁，文王骍牛一，武王骍牛一。”胜利者周公和成王祭天地祖宗所用的牲体才仅只有这么样一二头的数目，和卜辞动辄四五百头的比较起来，不是有天渊之隔的吗?在《逸周书?世俘篇》里面倒有一二例的牲数用得特别的多：乙卯，武王乃以庶国馘祀于周庙断十六，断羊二。用小牲羊犬豕于百神水土。用牛于天于(与)稷五百有四。用小牲羊豕于百神水土社二千七百有一。这一些超级的数目，旧时的人不大相信，如孔鼌注便以为“所用甚多，似皆益之”，但我以为《世俘》这一篇倒可算是真实纪录，以后人头脑，就要夸张也夸张不到的。但周武王之所以能够这样慷慨地用一次，并不表示周人养猪养羊特别地讲究，而是因为用的是殷人的遗产!而且只慷慨了这一次，以后便倒楣了。在历史上只留下了这么空前绝后的一例。周初的农业自然已经有了高度的发展，但这发展并不是周人特异的突出，而是殷代遗产的继承。我们看《尚书?无逸篇》吧，周公自己说他的父亲“文王卑服，即康(糠)功田功”，可见文王这位酋长还在亲自下田风谷。又看《楚辞·天问篇》，“伯昌号衰，秉鞭作牧”，可见这位下田风谷的酋长文王，同时也还在看牛看羊。这些都是很可靠的资料，和文王的祖父太王都还在穴居野处的传说是很相称合的。故所以周代的铜器，在武王以前的，一个也没有。但到了成王时代，气象便迥然不同了。要考察周初的产业情形，最好的资料是《周颂》里面的几篇关于农事的诗。《噫嘻》、《臣工》，特别的早。大小《雅》和《国风》里面的那几篇洋洋大作的农事诗，都是西周末年或更后年代的东西了。　我们看《噫嘻》吧。“嘻成王，既昭格尔。率时(是)农夫，播厥百谷。骏发尔私(耜)，终三十里；亦(弈)服尔耕，十千维耦。”这诗，非常素朴。这可能就是成王时代的作品，因为文、武、成、康这些名号都非死谥。死后追谥的事是战国中叶以后才出现的。这由王国维首先发现，继经我补充证明，目前是已经成为定论了。诗也经过改窜是毫无问题的，证据就在一个“尔”字。这个第二人称代名词的使用，由彝器看来，是春秋中叶才开始的。殷代及西周的古器物铭文里面的人称代名词，第一人称主格用我，用余，不用予字；领格用朕，有时用我；宾格用余，有时亦用我。第二人称主格用女(汝)，有时用若(极罕见)；宾格亦用女；领格则专用乃。第三人称主格罕见(春秋时器甩皮，即后世彼字入领格用其、用厥；宾格用之。这是东周以前用字的通例。凡《诗》、《书》中用朕为主格，用于吾尔汝等字，不是后人伪托，便是经过改窜的东西。《噫嘻》虽然采的诗形，但假如简单化起来，仅只是这么一句：成王叫你们来，带领着这些农夫们去，播种耕田。这和卜辞的“王令小臣以众黍于某”，在根本上并没有什么不同。特别值得注意的是“十千维耦”的一句，这是讲有二万人在同时集体耕作。这和卜辞的“王大令众人曰协田”，也恰恰彼此得到注释。我们不好把这些辞句只轻率地看为夸张便了事，我从前是曾经犯了这样的轻率的毛病的。西周诗人极其质实，决不肯振奋一下想象力的翅膀。大抵他们所举的数目字都可认为有账簿性的效用。此处的“十千维耦”，《载芟》的“千耦其耘”，以及所谓“千斯仓，万斯箱”，“如茨如梁，如坻如京”之类，都是实写，便是有大规模的集体耕作为它们的蓝本的。这样的场面早已下了历史舞台，后代的诗人是不能想象的了，因此也再没有这样的诗篇产出了，便是要夸张也夸张不出。在这儿可容许我们考虑到的便是殷、周两代曾经实行过井田制。这个问题，在前被人否定过，也被我自己否定过的；现在我却要肯定它，而且认为这是解决殷、周社会组织的一个极重要的关键了。我也算经过了十五年的探讨而来，决不是一时的心血来潮，为了要自圆其说，而任意的翻云覆雨。井田制是断然存在过的，我们可以得到很多的证明。例如田字本身便是一个证据，这个象形文是有图画价值的，古代必然有过豆腐干方式的田制，才能够产生得出这样四方四正，规整划分的田字。在甲骨文字里面已经就是这样，几千年来都没有改变。其次是西周的金文里面有好些赐田和以田地赔偿或交易的纪录，而都是以“田”为单位。例如上面已经提到的《曶鼎》(孝王时)叙匡季起初以田赔偿盗禾之罪“田五田”，不能了息，后又“用田二”，“凡用即留田七田”。又如《卯簋》乃先后年代之器，叙荣伯赐卯的物品里面有：“马十匹，牛十，锡于亡一田，锡于×一田，锡于×一田，锡于×一田”。《不■簋》(夷王时)叙不■伐犭严狁有功，伯氏赐他：“弓一，矢束，臣五家，田十田”。《敔簋》(夷王时)叙敔抵御淮夷有功，王赏赐他：“贝五十朋，赐田于含攵五十田，于早五十田”。像这样以一田、二田、七田、十田、五十田为计，明明是以“田”为计算单位，这更足以证明田的亩积必然有一定的大小。这样，田有一定的亩积而且规整划分的制度，除井田制之外不能想象。正因为古时候有过这样的田制，故尔《周官?遂人》有治野的方法，《考工记》也才有匠人为沟洫，叙述井田构成的方式。又如子产在郑变法还在“井沃衍”；李悝为魏文侯行尽地力之教，也还在“地方百里，提封九万顷”；商鞅在秦变法才开始“坏井田，开阡陌”。这些纪录没有井田制是讲不通的。井田制必然是施行过的，问题倒应该是：井田究竟是怎样一种形式。</p>
<p><strong><font color="#FF7256">三、</font></strong> 关于井田制关于井田制，一般大抵是以《孟子》为根据，而逐渐加以发展。孟子劝滕文公行井田时，他说：请野九一而助，国中什一使自赋。……方里而井，井九百亩，其中为公田，八家皆私百亩，同养公田。公事毕，然后致治私事。又说：夏后氏五十而贡，殷人七十而助，周人百亩而彻，其实皆什一也。……《诗》云：“雨我公田，遂及我私。”惟助为有公田。由此观之，虽周亦助也。(《孟子?膝文公上》)</p>
<p>照孟子的意思，三代的田制虽然略有因革损益，但在原则上是一致的，至少八家共井式的井田制是为殷、周两代所共通，不同的仅仅殷人以七十亩为单位，周人以百亩为单位而已。这大约多少是有些根据的。他也引到龙子曰：“治地莫善于助，莫不善于贡。”龙子不知何许人，必是孟子先辈而有名于时的人，故孟子引其说为说。或疑为商鞅变法时与之辩论的甘龙，不仅时代稍后，且远在秦国，未必便能相闻。大约殷人七十亩而取七，周人百亩而取十，会是事实，而变为八家共井式的井田，则只是孟子的乌托邦的理想。古者世禄，画方田仅以代禄，即是给予一般的内服臣工，并不是给予一般耕田的人。孟子主张耕者有其田，故假借古时田制史影以图减少阻碍，所引《大田》的“雨我公田，遂及我私”，固是公田与私田的对称，然要解释为井字形田的当中百亩为公田，周遭的八个百亩为私田，那只是孟夫子的“我田引水”而已。自有这孟子式井田说出世，到汉代的《韩诗外传》与《穀梁传》便逐渐完整化了起来。《韩诗外传》是汉文、景时的韩婴“推《诗》之意”所作。他推《信南山》的“中田有庐，疆埸有瓜”而解释为：“古者八家而井，田方里为一井……其田九百亩。……八家为邻，家得百亩，馀夫各得二十五亩。家为公田十亩，馀二十亩为庐舍，各得二亩半。”这样倒计算得很周到，不仅和“什一”的说法很能够牵合，而且从《诗经》里面又找到了一个证据，比孟子所找到的公田私田还要显得更切实些。《春秋》宣公十五年“初税亩”，《穀梁传》也就根据了韩婴，而更加说得像煞有介事。初者始也。古者什一，藉而不税。初税亩，非正也。古者三百步为里，名曰井田。井田者九百亩，公田居一。私田稼不善则非吏，公田稼不善则非民。初税亩者，非公之去公田而履亩十取一也。以公之与民为已悉矣。古者公田为居井灶，葱韭尽取焉。这样，当中的公田不仅有庐舍，而且还有水井、灶头、菜园子，想得更比韩生周到了。然而《信南山》那两句诗的原意，可惜并不是那么一回事。且把那整个一节诗拿来研究一下吧。中田有庐，疆場有瓜，是剥是菹，献之皇祖。曾孙寿考，受天之枯。庐与瓜是对待着说的，下边统言剥言菹，可以知道庐必与瓜为类，断不会是居宅庐舍之庐。同样的诗例，我们可以举《南山有臺》为证。南山有臺，北山有菜。……南山有桑，北山有杨。南山有杞，北山有李。南山有栲，北山有杻。南山有枸，北山有楰。臺既与莱为对文，而其余数章又都是桑杨杞李等植物名汇，则臺断非亭臺楼阁之臺。故古时注家即破臺为薹，训为莎草，这便与莱为类了。和这同，与瓜为对文，而可剥可菹(摘来做咸菜)的庐，也必然是假借字。我看这一定是蘆字的假借，说文云“蘆，蘆菔也”。中田者田中，“中田有庐”亦犹“中谷有蓷”，就是说田当中有蘆菔。这样一得到解释，可知韩生引用这两句诗，比孟子引用《大田》的那两句是更加胡涂了。孟子之所以不引这两句，倒可借证孟子也是不把庐训为庐舍的。假使还需要例证的话也可以举出《七月》的“七月食瓜，八月断壶”。壶字与瓜为对，下文也都说的是植物，故只是葫芦的瓠，而不是茶壶酒壶的壶。这在古人也早就知道了。在前的训诂家称之为“同音通假”，事实上可以说就是写别字。不过壶这个字倒是葫芦之义在先，水壶之意在后，壶起初用葫芦来做，故尔称为壶而已。就是现今的壶也还多少保存着葫芦的形式。但孟子式的井田说，也并不是毫无根据：它所根据的应该是《考工记》的《匠人》职文，或与《匠人》职文同根据一种古代曾经有过的事实。《考工记》毫无疑问是先秦古书。且看那开首的叙记里说到“有虞氏上陶，夏后氏上匠，殷人上梓，周人上舆”，可知时已不属西周，而书亦非周人所作。又说到“郑之刀，宋之斤，鲁之削，吴、越之剑，迁乎其地而弗能为良”；郑、宋、鲁、吴、越等国入战国以后都先后灭亡，其技艺亦早已“迁乎其地”；可知这所说的还是春秋时代的情形。又说到“粤无镈，燕无函，秦无庐，胡无弓车”，或“燕之角，荆之干，妢胡之哿，吴、越之金锡”，作者之国别连燕、秦、荆楚、始胡都是除外了的。当时重要的国家所没有提到的只是齐和晋。“■胡”，旧注以为“胡子之国在楚旁”，这样的小国不应有被举的资格；我疑始即是汾，指晋国，胡仍是“胡无弓车”之胡。如此则只剩下齐国一国了。再看书中所用的度量衡多是齐制，如《冶氏》为杀矢的“重三垸”，垸据郑玄注即东莱称重六两大半两(大半两即三分之二两)的环；如《栗氏》为量的釜豆等量名都是齐制。又如“梓人为饮器，勺一升，爵一升，觚三升，献以爵，而酬以觚，一献而三酬则一豆矣”，即所谓“齐旧四量，豆区釜钟，四升为豆”（《左传》昭公三年）。据此我们尽可以断定：《考工记》是春秋年间的齐国的官书。《考工记》的年代国别既明，我们请来看它的匠人为沟洫的职文吧。匠人为沟洫。耜广五寸，二耜为耦。一耦之伐广尺深尺谓之■(吠)。田首倍之，广二尺深二尺谓之遂。九夫为井(井方一里)，井间广四尺深四尺谓之沟。方十里为成(十井)，成间广八尺深八尺谓之洫。方百里为同，同间广二寻深二仞谓之浍。专达于川。这就是今文《尚书·皋陶漠》“濬畎浍距川”的详细内容，当然也就是孟子的井田制之所根据。但孟子把它理想化了，把“九夫为井”改为八夫共井，当中一眼改为了公田，以图实现其耕者有其田的理想。《考工记》的井田制大率在齐国是实行过的，《管子·侈靡篇》言“断方井田之数，乘马甸之众［而］制之，陵溪立鬼神而谨祭”，虽不必是管子时事，然足见齐国实曾施行过井田。但这和周室施行的办法却又多少有点不同。周室治野的办法在《周官?遂人》职文里面还保持着，那是纯粹十进位的办法，没有“九夫为井”的那一套花样，但遂沟洫浍川等名称是完全相同的。凡治野，夫间有遂，遂上有径。十夫有沟，沟上有畛。百夫有洫，洫上有涂。千夫有浍，浍上有道。万夫有川，川上有路。以达于畿。(这是一纵一横的办法，比《匠人》职文的方式更为简单。)</p>
<p>这项资料我觉得同样值得宝贵，并不是出于刘歆的杜撰。因为《周官》尽管是有问题的书，但只是经过刘歆的剪裁添削，割裂改编而已，其中自有不少的先秦资料。故《周官》和《左传》一样，固不可尽信，然亦不可尽不信，使用时须得有一番严密的批判。像这“治野”一段，如是出于杜撰，便应当与《孟子》、《考工记》等相同；而现在不同，倒正足以证明其不是杜撰了。这十进位的办法和古代罗马的百分田法极相类似。古罗马人治野，先要视飞鸟之影以察几祥，卜地既吉，乃用悬规以定地之中点(仿佛古人所谓“土中”)。中点既定，即由此引出正交之纵横二路。以此为基线辟一中央四分之方形或矩形(恰如我国田字)。于四隅建封疆，或以木，或以石。(此如用我国古制称之，亦即所谓“封建”。)再与纵横二路两两平行，各作小径，划成无数正整的区域，每区以罗马尺二四〇方尺之正方形或矩形为正规。这种遗迹在意大利境内已经由地下发掘出来了。这和《遂人》职文不是极相类似吗?从前怀疑井田制的人以为那样划豆腐干方式的办法不曾有，也不能有，然而经过考古上的证明，罗马在奴隶制时代已经有过了。我们的井田虽然还不曾从地下发掘出，但将来是很有希望的，谁也不能断定它绝对不能出土。地下的证据虽然还没有得到，古文献和古器物上的证据是已经有得够充分了。例如古时灭人国有改变人的亩道之事。《春秋》成公二年晋卻克打败了齐侯，他所要求的媾和条件便有“使齐之封内尽东其亩”的一项。这也正好是井田的一种证明。因为亩道系以国都为中心，故有南北纵走与东西横贯的两种大道，南北纵走的是南亩，东西横贯的就是东亩。《诗》上所说的“我疆我理，南东其亩”（《小雅?信南山》），就是这个事实。齐国在晋的东边，“尽东其亩，唯戎车是利，事实上就等于撤销它的首都和国防，把南北纵走的大道一律改为东西横贯，以便一有战事时，晋国的兵车可直达齐国的全境。这些资料好像与井田制并无直接关系，而其实它们正是绝好的证明。古器物铭文上的直接资料，如田字本身的结构，周代金文里面的以田为单位的一些纪录，我在上面已经叙述到了，不再赘述。此外也还有几项更确实的证据。一、《召卣》：唯十又三月初吉丁卯，召启进事，奔走事皇辟君，休。王自殼使赏毕土方五十里。这是周初的器皿，由花纹、形制与字体都可判定，“十又三月”是年终置闰，也沿用着殷人的习惯。“赏毕土方五十里”，是说予以毕地之土田五十里见方。毕在陕西长安、咸阳二县的西北，乃毕公高所封。高召古音同部，因此这位“召”应该就是高的本字了。我从前因为不相信豆腐干式的划土分田法，曾极尽曲解的能事，想推翻这个铁证。现在想起来，真是徒劳的妄举了。二、《段簋》：唯王十又四祀十又一月丁卯，王在毕烝。……念毕仲孙子，令龏女月遗大则于段。这是昭王十四年的器皿。“大则”即《周官?大宗伯》“五命赐则”之则。郑玄注：“王莽时以二十五成为则，方五十里。”莽制复古，一切都是有根据的。“则”上加一“大”字，或许比方五十里还要多些吧。三、《贤殴》：唯九月初吉庚午，公叔初见于卫，贤从。公命史畮(贝每)贤百畮(亩)。……这个器皿的字体也是很古的，断然属于周初。公叔当即卫康叔。这“百亩”地应该就是一田的地积。两个购字，即古亩字，但上一个是动词，有赐予之义，故知读为晦，亦即是贿字。根据以上一些证据，我们确切地可以说：殷、周两代是施行过豆腐干式的均田法的；其在西周不仅行之于镐京，于洛阳，而于齐于卫都有朕迹，只是各地所行的方式，多少有些出入。这些，一律都可以叫作井田，不必一定要九夫为井或八家共井。因为那样规整地划分的田地，从其一局部看来，是和井字很相仿佛的一一无论甲骨文或金文，井字形都和现行楷书是一样，而纵横笔画更是完全整齐的。</p>
<p><strong><font color="#FF7256">四、</font></strong> 施行井田的用意为什么要施行这样豆腐干式的井田呢?</p>
<p>这显然是由于两层用意所设计出来的：一是作为榨取奴隶劳力的工作单位，另一是作为赏赐奴隶管理者的报酬单位。古时候没有正确的时间和一定的考核标准，故尔划分出一定的地积来以便容易考查奴隶生产的勤惰。《王制》所谓“制农田百亩，百亩之分上农夫食九人，其次食八人，其次食七人，其次食六人，下农夫食五人”，实际就是要榨取一人的劳力来供养五人至九人的食粮。在上者以这为标准课农夫的勤惰，也以这为标准而定其上下，加以赏罚。有了生产奴隶出现之后，必然有管理生产奴隶的人。在奴隶数目不多的时候，奴隶主自己可以管理，但如数目一多，生产一扩大了，那就须得有得力的或忠实的管事们来代管，于是官就出现了。这就是阶级统治的形成。等奴隶数目更多，生产规模更扩大，管奴隶的人也就更加多，而管奴隶的人也就须得更有人来管理。于是层层相因，而所谓公卿大夫士的层次，或王公大夫士皁舆隶僚仆台的十等，就逐渐产生出来了。除王以外的这些管事们必得有一定的报酬，在后人是用薪俸，在秦、汉是用谷米，而在殷、周则更原始地就用生产工具的土地。为要表示出等级，使报酬有一定的多寡，因而也就得利用这规整分地的办法了。管理奴隶的人除奴隶领主自己的兄弟亲戚之外，愈和奴隶层接近的下层管事，照例是由奴隶提升起来的顺民。普通的官僚在古时称为臣宰，在初都只是奴隶的称号。(臣是亡国奴，宰是“罪人在屋下执事者”。)卜辞中屡见以多臣多宰从事征伐，或命臣以众庶从事战争或耕稼的纪录，臣宰的初义在殷、周还未尽失，愈朝后代走便愈涂上了光彩，所谓大臣冢宰之称那差不多是光荣绝顶的名词了。就这样，阶级统治随着历史的进展便愈见隐晦下来。我们为了求得它的本来面目，最捷的途径是从停留在原始阶段中的氏族社会里去找资料。在我国这种后进的兄弟民族是很。多的，如像彝族，那毫无疑问是还停留在奴隶制阶段的。如像凉山彝族，有黑骨头与白骨头之分。黑骨头便是真正的彝族，是贵族。白骨头是先后被俘掳去的汉人，是奴隶一一“娃子”。据往年的调查，凡汉人被俘为奴，起初是备受缧绁之苦。但经若干时期之后，只要你诚心归顺，便可以得到身体的自由，而一切的耕作与劳役都得唯命是听，有事时还须参加战争。这些都是所谓“娃子”。娃子如有才干并特别忠顺，为主人所赏识了，便被提升为“管家娃子”。可以让你同另一异性的忠顺娃子结婚，给你一片土地，一所房屋，让你去自耕自食。每年年终只消献纳猪一头，杂酒一罐。但平时劳役，战时出阵，也都要唯命是听的。管家娃子也能俘掳汉人，驯服之以为自己的奴隶，这种奴隶叫作“三滩娃子”。滩是等级的意思。管家娃子为头滩，普通娃子为二滩，娃子的娃子为三滩。我们根据这个原始的奴隶社会，很可借以了解殷、周时代的社会机构。所谓“百僚庶尹，惟亚惟服，宗工，越百姓里居”的內服，其实一多半也就是所谓“管家娃子”。还有所谓“侯甸男卫邦伯”的“外服”，那是些酋长族的分家。那些各个的分家，殖民部落，自然又是一些由奴隶的等级所累积起来的金字塔了。一一这就是我们中国古时候的所谓“封建”。近年有些新史学家依然为这种原始字面所蒙蔽，他们说“西周是大封建社会”，或“初期封建社会”，因而也很在努力，想从新的观点来证成这种说法，在我看来，不免是徒劳的。新史学家们对于史料的征引，首先便没有经过严密的批判：《易经》仍被视为殷末周初的古书，《书经》甚至引用到梅赜的伪古文，《诗经》则一本《毛传》。对于旧文献的批判根本没有做够，不仅《古史辨》派的阶段没有充分达到，甚至有时比康有为、阎百诗都要落后，这样怎么能够扬弃旧史学呢?有好些朋友又爱驰骋幻想，对于神话传说之被信史化了的也往往无批判地视为信史，对于甲骨文的引用和解释也太随便。甲骨文字的研究是方兴未艾的一种学问，前人的成说每每不久便被推翻，我们如不去全面追踪或过于轻信，便容易以不狂为狂，以狂为不狂。例如新史学家们所爱征引的“弇奴”说，早就被扬弃了。“弇”是娩字，“奴”是嘉字。又例如同样爱被征引的“歸矛”说，也早就被扬弃了，“歸”为婦字，“矛”是包字。然而新史学家们至今都还在引用来著书立说。“帚侄”是人名，而说为子侄之侄。“臣在鬬”的鬬字是地名，而认为奴隶用于角鬬。其它错误，不遑枚举。关于金文，《殷文存》仍全被视为殷文。周代的彝器则笼统活脱地被使用着，不肯从分别时代上着眼。这些作风，不能不说是在基本上就颇成问题的。但是，这些问题我们姑且抛开，且就新史学家们认周代为封建社会的主要根据，重新作一番检讨吧。首先他们是否认井田制的，但信手又把孟子所理想化了的井田式认为庄园制的雏型。这是不着边际的循环论证。由我上文的叙述自可表明，无庸再说了。其次他们认为土地已经分割，即是土地已经私有，也就是庄园地主已经存在。土地已经分割是事实，但只是土地的享有，而非土地的私有。内服的百僚“田里不鬻”，外服的诸侯只是殖民地代办，有罪则“有削地”(《王制》，“诸侯，其有削地者归之闲田”)，有废国（如“降霍叔于庶人”）。削地废国之权直到春秋初年的周室都还保存，如隐公十一年“王取田于郑，而与郑人苏忿生之田”之类，即其证。所以诗人说：“普天之下，莫非王土。”又其次认为耕者都是农奴，是自由民。这由于没有把古代民字的本义认识清楚。殷、周两代从事农耕者谓之民，谓之众，谓之庶人，其地位比臣仆童妾等家内奴隶还要低。我引了不少的证据，也反复讨论过多少次，然而总得不到一致的见解，而又无正面的反驳，不知道这问题的症结究竟是在那里。我想，主要的原因或许是由于农业奴隶与封建制下的“农奴”性质相近而生出了混同吧。农业生产奴隶和手工业的生产奴隶或商业奴隶，性质不尽同。这在典型的奴隶制时期的希腊已经是表明着的。注重手工业和商业的雅典，奴隶是无身体自由的，而注重农业的斯巴达，它的农耕者黑劳士(Helots)便有充分的身体自由。这是因为农业的土地便发挥着更大的缧绁髡钳的作用，耕者不能离开土地，离开了便有更深沉的苦痛。这层土地的束缚作用，连相当原始的彝族都是无意识地利用着的。中国是大农业国，故殷、周两代的农耕奴隶，能显得那么自由。新史学家们爱引用《尚书》里面的几句话，“尔乃尚有尔土”，“今尔惟时宅尔宅，继尔居”（以上《多士》），“今尔尚宅尔宅，畋尔田”（《多方》），以为都足以证明殷灭亡后的那些顽民都成了“农奴”一一自由民，有自己的土田房屋。其实在这里面顶多是包含了一些“管家娃子”。所谓“有尔土”是享有尔土，不是私有尔土；所谓“宅尔宅，继尔居”，或“畋尔田”，是宅尔所宅之宅，继尔所居之居，畋尔所畋之田。我们如把享有认为私有，那是会差之毫厘而谬以千里的。土地既可作为酬劳臣工的俸禄代替，更重要的生产工具一一奴隶，当然也可以作为酬劳品。故鲁公伯禽受封时有“殷民六族”，卫侯康叔受封时有“殷民七族”，唐侯叔虞受封时有“怀姓九宗”。而西周金文中由我所发现的臣民与土田同锡之例，更屡见不鲜。说者也每每认为这些都是“农奴”，“就是因为他们大半都是连同土地而被赏赐”。其实土地的束缚性很大，即到资本制下农民和土地都还不容易分开，但它们是可以分开的，分合是可能全凭个人意志。封建制下也可以分开的，分合是可能半凭个人意志。到了绝对分不开，全无个人选择的自由，不正好证明是奴隶吗?在这儿十八世纪绝对专制王权下的俄国暴政，把农奴成千成万的连同土地一道给人，那种变例是不能拿来做证明的。因为农奴在历史的反常期中屡屡被横暴的领主或征服者逆化而为奴隶，在中国秦、汉以后的历史上也正不乏其例。就在目前的世界大战中希特勒不正把无数资本主义的乃至社会主义的国家的人民化为奴隶吗!我们能引据目前的资料证明西周已经是资本制度么?</p>
<p>要之孟子式的井田制不能认为庄园。土田虽见分割并非私有，即彝族社会里也有这样的现象，不能认为封建制的特征。农业奴隶本有较广泛的身体自由，其与土田同被分锡正表示其自由实有条件，决不能认为“农奴”。耕者深受土地束缚，随着土地而转徙，颇类于土地上的树木。然此亦非被分锡者所私有，而实为其所享有，故诗人又说：“率土之滨，莫非王臣。”历史是整个的，个别的社会关系也要看整个的社会关系来决定。西周还是青铜器时代，做青铜器和其它器具的工人都还是奴隶(说明详下)，而农耕者已经是半自由民或自由民，那是怎么也说不通的事。</p>
<p><strong><font color="#FF7256">五、</font></strong> 申述人民身分的演变为了大家省得翻书去逐步找寻起见，我不妨再把我所见到的人民身分的变迁，更综合地叙述一遍吧。人民本是生产奴隶，这是我在古代社会中所发现的一个重要的事项，但其实这已经是一种进步，人民在达到这个历史阶段之前是连做奴隶的身分都没有的。我们知道人类的原始时代是纯粹的家族集团或宗族，那时是无所谓奴隶的。一族人就如一家人，虽有族长或家长，并无所谓主奴之分。奴隶是来自异族。起初征服了或战胜了异族，俘获的人是要尽遭屠杀的，每每把这种人来作为牺牲以祭本族的祖宗神祇。就是在卜辞里面以人为牺牲的纪录也多到举不胜举。用人牲之例多言“伐”，伐若干人即是杀若干人，有一次伐至二千六百五十六人的。又屡言“■”，■若干人即是辜若干人，磔若干人。可见殷人的原始性依然相当强，对于人夫并不怎样爱惜。但人是有使用价值的，起初择其辩黠柔顺者以备驱遣，那便是臣，便是妾，即所谓家内奴隶。继进即其顽强不听命者亦强迫之以事生产，那便是众，便是民。最有趣味是民与臣两个字，在古时候本都是眼目的象形文。臣是竖目，民是横目而带刺。古人以目为人体的极重要的表象，每以一目代表全头部，甚至全身。竖目表示俯首听命，人一埋着头，从侧面看去眼目是竖立的。横目则是抗命乎视，故古称“横目之民”。横目而带刺，盖盲其一目以为奴征，故古训云“民者盲也”。这可见古人对待奴隶的暴虐。古人于奴，髡首、黥额、刖足、去势，乃家常茶饭，盲其一目固无所惜。特一目被盲不便生产，后世不用此法而已。盲双目以为音乐奴隶之事则仍未绝灭。卜辞中无民字，亦无从民之字，但这只是没有机会用到而已，并不是殷代无民。也就如金字亦不见于卜辞，我们也不能说殷代还没有铜。《盘庚》、《高宗肜日》、《微子》那几篇《商书》都已经有了民字，而尤其《高宗肜日》的“王司敬民，罔非天胤”那句祖己所说的话，简直是思想上的一大进步，把人民都平等地看成为天的儿子了。但这无疑是经过后代儒家所润色的。周初的几篇《周书》都有民字。在彝器方面，成王时代的《班簋》叙毛伯伐东国，三年告厥成功，有“惟民氓拙哉，彝昧天命，故亡”的话，当然指斥的是殷之顽民。康王二十三年的《大盂鼎》言，“在武王嗣文作邦，辟厥匿，匍有四方，畯正厥民”，又言，“粤我其遹相先王，受民受疆土”，这些都和《周书》的观念很接近，表示民与土地是天所授予于王室的财产，所谓“皇天付中国民越(与)厥疆土于先王”（《梓材》）。这些都很明显地是殷代传下来的观念。“有人此有土，有土此有财，有财此有用”，疆土和人民本来是分不开的。民在周初又称为人鬲。《大盂鼎》纪康王锡盂的物品说道：“锡汝鬯一卣，冕衣芾舄车马。锡乃祖南公旂用狩。锡汝邦司四伯，人鬲自驭至于庶人六百又五十又九夫。锡夷司王臣十又三伯，人鬲千又五十夫。亟××自厥土。”所谓“邦司”就是管家娃子，所谓“夷司王臣”也就是专管夷仆的王家娃子。这两项是分开来纪载的，同一人鬲也是分开来纪载着。据此，我们可以推想到“邦司”所管的人鬲是旧有的奴隶，“夷司王臣”所管的人鬲一定是征服殷室后新归附的夷人。特别值得注意的是这人鬲的内函，前项的六百五十九人中分明包含着“自驭至于庶人”。庶人在人鬲中居于最下位，这也就和“人有十等”之外而“马有圉，牛有牧”未能入等的是同样。驭当即十等人中的舆，可见人鬲是把下等的家内奴隶也包含着的。这项把庶人身分表示得绝好的材料，它的价值决不亚于爪哇岛上发现了一个原始人的牙齿，而学者们偏不重视它，不在这些地方驰骋一下想象，倒是有点不可思议的事。人鬲又省称为鬲。成王时的《作册夨令簋》言：“作册夨令尊宜(进肴)于王姜，姜赏令贝十朋，臣十家，鬲百人。”这也是臣与鬲为对。臣以家言，可见是有家有室的管家娃子；鬲以人言，可见还是单身汉的普通娃子。这鬲也就是《逸周书?世俘篇》“馘磿亿有七万七千七百七十又九人”的磿，两字的读音是相同的。在我看来，恐怕也就是黎民的黎。臣民本是王家所授予，和“田土不鬻”一样，也不宜私相授受，或有所损失。故周初的人时常谆谆告诫，要“怀保小民”。但年代经久了，享有逐渐化为私有，而人臣蕃昌之家又能自备三滩娃子。于是臣下之间也同样把自己的娃子或土地分予人了。这种情形由金文看来，是周穆王以后才频繁起来了的。人民不仅可以授与，而且可以买卖。《周礼?地官?质人》“掌成市之货贿、人民、牛马、兵器、珍异”，《秋官·朝士》“凡得获货财、人民、六畜者委于朝，告于士”，人民与牛马六畜同科，可以在市上交易。这在有名的《曶鼎》里找到例证，并且找到了在孝王时的人口贩卖的价格。《曶鼎铭》第二段言留先生向一位奴隶主限先生讲好了“用匹马束丝”买五名奴隶，连马匹丝束都交付了，但限先生变卦，不肯卖，只得又改用一种金属一百寽。但限先生又变了卦。因此便结成讼事，结果限先生输了。据这段彝铭我们可以知道，不仅是在孝王时的贸易还在行着实物交易与准货币交易的两种形式，而且人也可成为交易的货物。五个人的价格仅抵一匹马和一束丝，而用货币交易时一个人也仅抵二十个寽。一寽等于十一铢又二十五分之十三，用汉代的五铢钱换算时，一个人值不上五十文制钱。这人的价格是多么的贱呀!</p>
<p>《曶鼎铭》的第三段，前面曾经征引过，匡季愿出田七田，众一夫，臣五人，去赔偿劫稻，而不愿出三十秭禾的罚款。这也足见七个田和六个人的价值比三十秭禾还要低。一秭是半托（见《说文》），一托是四百秉（见《仪礼·聘礼》），一秉是一把(郑玄说)。一把禾可取米一合，六千把仅合六石。五个人和七个田还抵不上六石米，这人价和地价不是便宜得可以惊人吗！但奴隶的价格并不是长久都是这样贱的，入后渐渐地贵了起来。我们在这儿可以引两件有名的故事来凑成这段奴隶涨价的历史。第一件是春秋末年齐国的宰相晏婴赎越石父的故事。越石父为人奴，晏子出而遇之于途，奇其貌，解左骖赎之（见《史记·晏婴传》及《晏子春秋》）。这明明表现着，一名奴隶已经值得一匹上好的马了。比起孝王时的价钱是涨了五倍以上。第二件是战国梁襄王时候的事，卫嗣君有胥靡逃亡了，到梁国去替襄王后治病。卫君知道了，先请用五十金赎回，往返五次梁王都不肯。后来便决计以一个都邑名叫左氏的去更换他（见《韩非·内储说上》）。这些不用说都是特别的情形，不能认为当时一般的奴隶市价。用都邑自不用说，就是用五十金也未免太贵了。因为一金的重量有二十两与十六两的两种说法，五十金则为一千两或八百两。尽管用的是铜，都觉得贵得太利害了一点。但无论怎样，从这个例子里面，总可以反映出战国时代的奴价是比春秋时代更加增高了。奴隶为什么会这样涨价呢?这是社会变革的一个契机，且留待下面慢慢地解释吧。</p>
<p><strong><font color="#FF7256">六、</font></strong> 井田制是怎样破坏了的井田除王室或公室自奉而外，其余是公卿大夫士等的俸田，但这一律都为公家所有，也就是一律都应该称为公田的。井田制的开始破坏应该是由于私田的产生。俸田不得称为私田。即使夺取同僚的俸田，或甚至篡有公家的官田(这样的事在《左传》里面很多)，只是所有权易主而已；在仅有的田积里面，也并没有产业的发展，因而也就不能扬弃一种社会制度。夺取别国的田地可能促进一部分的产业的增加，但这只能说明得一种后果，而未能说明其本身韵前周。因为兼并侵略是由生产发展派生出来的，是什么因素使生产发展了，并没有得到说明。近时的新史学家们在说明古代社会的变革上差不多翻来覆去地只是强调这兼并侵略的事项，他们的见解，事实上丝毫也没有脱掉旧史学的窠臼。井田制的破坏是由于私田的产生，而私田的产生则是由于奴隶的剩余劳动之尽量榨取。这项劳动便是在井田制的母胎中破坏了井田制的原动力!这层我们是要特别强调的。公卿大夫士这些上层的管家娃子所领得的采邑或俸田虽然有限度，但他们对于所获得的三滩娃子的劳动榨取，尽可以是无限度的。可幸中国又是温带里面的大陆国，除平衍地区的井田官地之外，有无量的山林陂池可供开拓。那些小奴隶主们是绝对不会放松这些利源的。就这样驱使所有的奴隶以开拓这些羡余，所谓“筚路蓝(篓)［缕］，以处草莽，跋涉山林”，所谓“庸次比耦，以艾杀此地，斩之蓬蒿藜藋”，这些当然是不犯禁的事体，而且勤劳有加倒常是受国家奖励的。这样所开辟出来的东西便成为自己所私有的东西，鬻卖抵偿，纯是自己的自由；既非受自公家，当然也就毫无纳税的义务。领主们这样纯粹享有着奴隶生产的剩余价值，在时间的经过当中便逐渐富庶起来，所有的私田加多，三滩娃子也加多了。这也就是他们能够更进一步去推行兼并侵略的资本了。私田的垦殖是在国家大法的范围之外的，当然不必遵守你那种西方西正的古板办法，而且也不能遵守。山林陂隰，那是无法拓出井字来的。这就是所谓“暴君污吏必漫其经界”也就是所谓“辟草莱，拓土地”了。这种因任地势的自然田畴，我们在金文里面可以找出它的详细的刻画，那便是有名的《散氏盘》了。那盘铭一开首就说“用夨扑散邑，乃即散用田”，便是因为夨国在前去扰犯了散国的城邑，结果一一大概是打败了一一便用田去向散国赔偿。田是两个，一个是眉田，一个是井邑田。铭中把这两田的疆界叙述得很清楚，接着叙出参加验界的双方的官吏，接着是两处田官的先后发誓；自言没有隐瞒，也不会变卦，如有则受重罚。就这样还画成了地图，由矢王送给散氏。顶值得注意的是两个田的疆界．那儿涉水涉湖，登山下山，一封二封地表示界标，或者利用天然林木，或者利用人行道路；地域究竟有好宽，不得而知，但那田形毫不平坦，也决不规整，是毫无疑问的。从前我就不止一次地征引过这项铭文来否定井田制，以为毫无井田的痕迹。其实我的思虑是太不周到了。它这本来就不是井田，而是夨族的私田，正因此所以夨王才能够自由处理。故尔这项重要的资料并不足引据以否定井田，倒适足引据以证明井田之渐被否定。《散氏盘》毫无疑问是厉王时代的东西，足证厉王时各族所有的私田是已经不少了。在同一时代里面有两个鬲攸从的器皿(这个人的名字见于《散氏盘》，故毫无疑问是同时)，一个是《鬲从盨》，另一个是《鬲攸从鼎》，两个都说的是田邑的事情。前者是叙说有章氏用八邑去向鬲从换田，又有良氏也用五邑换田，结果都顺当成交。后者是叙鬲攸从分田地给攸卫牧，而攸卫牧没有报酬，遂成讼事；结果是使攸卫牧发誓：“我弗具付鬲从其且(租)，射(谢)分田邑、则放。”于是乎讼事便了结。这倒足以证明厉工时地主形态的人的确是存在了。但一只燕子，还不能算是春天。地主关系要经过法定而成为制度，是还需要好几百年的．然而井田制的危机是出现了，建立在这个基础上的社会关系也就开始动摇。又加以厉王是一位暴君，所以成其为暴者是因为保守旧的势力以压制新的势力，所以结果他曾被新起的地主阶层和下面要说到的工商阶层，把他从京城里赶跑．一时曾出现过一次早产的、结果是夭折了的地主政权，便是十三年间的“共和行政”。一一共和是共伯名和；这由古本《竹书纪年》、《庄子》、《吕氏春秋》等书表示得很明白，但被《史记》误为周、召二公共和而治。近时的新史学家也还有根据《史记》为说的，我要请这样的朋友读读朱右曾、王国维的关于《竹书纪年》的研究。这早期政权虽然失败了，但等宣王即位时已开始“不藉千亩”，这正表明井田制下的仪式已经形式化而不被遵守了；又开始“料民于太原”，也是想把涣散了的奴隶统治来从新编配，借以维持其反动政权．对于新兴地主们的锐锋是使他们由内部转向外部，北伐犭严狁，南征淮、徐，以满足他们开疆拓土的欲望。就这样又把内在的危机一时延引下去了。这便是旧式史家所说的“宣王中兴”。有两个《召伯虎簋》，那是千真万确的宣王时候的器皿。其中有一个是宣王的后妃责备召伯虎的，那里面重要的一句话是：“余考止公仆庸土田，多债，必伯氏纵许”，是说父家田斌多积欠。是召伯虎投有帮忙。看情形是召伯虎在对于新兴的兼并势力加以削弱，至少被疑为是。又有一个《兮甲盘》，也是宣王时器皿。那是宣王五年，兮甲从王刚好伐了犭严狁之后，又奉命去征收四方的积欠一直南到淮夷。王的命辞这样说道：淮夷旧我帛贿人(犹言朝贡之臣)，毋敢不出其帛其积。其进人，其贮，毋敢不即次，即市。敢不用命，则即刑扑伐。其惟我诸侯百姓，厥贮毋敢不即市，毋敢或入蛮究贮，则亦刑。说得有声有色，甚为严烈。在这儿正表示着把内乱转化为对外侵略的机微。诸侯百姓等所谓内外臣工都已经不奉命令，而却远远去和淮夷算账，要叫他服力役之征(“进人”)，要叫他献纳赋贡(“贮”)。结果是引起了徐、淮的战争，《大雅》里面有好几篇歌功颂德的诗，写得十分堂皇，把胜利也形容得十分彻底。“于疆于理，至于南海”（《江汉》），“四方既平，徐方来庭”（《常武》），俨然像淮、徐都被征服，一直打到了南中国海，而文武盛世又重现了的一样。然而徐、楚在春秋时正大称其王，而外强中干的周室却不久便为犬戎所扫荡了。一切对于统治帝王所呈献的功德颂本是骗人的东西，我们是不好轻信的。周室就这样倒楣了下去，便形成为“礼乐征伐自诸侯出”的对代(春秋前半)。但那些老牌诸侯也并没有辉煌得多久，又挨一连二地沿走着周室的途径而趋向末路。姑且把鲁国来举例吧。这是西周诸侯中坐第一把交椅的。虽然它在春秋初年也曾经红过一时，如桓公十三年“春二月，公会纪侯、郑伯。己巳，及齐侯、宋公、卫侯、燕人战，齐师、宋师、卫师、燕师败绩”（《春秋》）。仅和纪、郑两小国联盟便打退了四个大国的联军，不是颇有点霸主的风度吗?然而在春秋末年却已经让孔子发出了“禄之去公室五世矣，政逮大夫四世矣，三桓之子孙微矣”的浩叹了（《论语·季氏》）。这“五世”大概是从宣公起算、“四世”是从成公起算的吧，约略当春秋的一半。在春秋二百四十二年当中，鲁国的产业情形虽然书阙有间，但就在宣公十五年却留下了一项在社会史上极其重要的纪录，便是上面举出过的“初税亩”这三个字。虽然只是这样的三个字，但它们确是新旧两个时代的分水岭，以前的《春秋》三传，也同样重视了这三个字。这的确是井田制的死刑宣布，继起的庄园制的汤饼会。我们为什么要重视这三个字?因为在这时才正式地承认了土地的私有。自殷、周以来的土田都是国有的或王有的公田，虽然在西周末造已经有私田出现，但和国家的经济机构毫无关系，也可以说是未经合法承认的私有。因为初出现时不能影响大局，公家一直默认了它。然而时间一经久了，私田的亩积便超过公田，私门富庶了，公家便式微了下来。因而“礼乐征伐”便逐渐“自大夫出”，更达到“陪臣执国命”的地步。公室为挽救自己的式微，便被逼得把传统的公田制打破，而公开承认私有，对于私田一律课税。这样便是社会制度的改革。私肥于公，因而泯却公私而一律取税，这在初是有利于公家而不利于私家的。公家可以多得些税收，而私家则不能再偷税了。因此这一税亩制度在初必曾遭遇过反对。果然在三十二年后的襄公十一年，三家来一次总反攻，“三分公室而各有其一，季氏尽征之，叔孙氏臣其子弟，孟氏取其半焉”（昭五年）。季孙氏采用征税的新制度，叔孙氏沿用奴隶制，孟孙氏则新旧参半。再隔二十五年，又“四分公室，季氏择二，二子各一，皆尽征之，而贡于公”（昭五年）。行新制度的季孙掌握了霸权，三家都采取征税制，而把鲁公室瓜分了。但鲁公室依然存在，它是靠着三家的贡税而维持着的。这“贡”在哀公时已是十分取二，但仅限于三家所分的公田，其三家的私田不在献贡的范围之内。这一部制度变革的经过，由《论语》上下列一段颇难索解的故事，可以得到补充。</p>
<blockquote>
<p><strong><font color="#FF7256">哀公问于有若曰：“年饥用不足，如之何?”有若对曰：“盍彻乎?”(十分取一为彻。)曰：“二吾犹不足，如之何其彻也?”对曰：“百姓足，君孰与不足?百姓不足，君孰与足?”(《颜渊》)</font></strong></p>
</blockquote>
<p>这段文字骤看起来是有点滑稽的，一向的注家把它当作仁政在讲，那是只有更增加滑稽的程度。哀公已经增加了田税，十分取二了，还感国用不够，而有若却教他“何不十分取一”。这位有若先生岂不是一位十足的书呆子吗?然而我想，有若不会有这样的呆一一这样的呆得不成话。但假如我们明了了当时的情形。那这段滑稽文字便并不那么滑稽了。哀公所说的“二吾犹不足”是由鲁国旧有的公田十分取二，而有若的“彻”是叫他撤去公私之分，不管你公田私田，而一律的十分取一。这样从多量的田积中虽然取得少些，实在比你从少量的田积中取得多些的，还有更多的收获。所以说：“百姓足，君孰与不足?”一一百姓在这儿是指三家等的贵族的。贵族们都有十足的私田，你公家从多中捞末，为什么会不足呢?这样十分富有社会史料价值的一段故事，可惜一向竟被人忽略而且完全误解了。我们现在得到了正确的解释，便可以知道鲁国的公田制，也就是井田制，是在春秋末年才废除了的。这样的变革在当时的中国并不是平衡地发展起来的。大多数的国家都比鲁国迟，而有的国家来不及蜕变便被人吞并了；但在战国年代所有存在着的国族都先先后后起着变革，一直变到秦始皇并吞六国，乃至陈、吴、刘、项的奴隶大暴动的成功为止，才达到了它的最后的终结。</p>
<p><strong><font color="#FF7256">七、</font></strong> 工商是怎样分化出来的原始工艺大抵都是农人的副业，例如织布抽丝，织屦编笠，制造简单的匏土革木之器，甚至修造古时的简单的宫室社庙，这些都用不着怎样高超的技术，无须乎有人来专司其事的。但社会进展了，工艺品的需要提高了，特别是领主贵族们已经领略了安逸享受的滋味，不能再满足于农人们在农忙之暇所造作出来的那种土气十足的东西了。于是工艺就来了一个初步的分化，那便是有高级品(雅)与低级品(土)的两种东西。高级品不再是让农人们抽闲来干得了的，于是便不得不有专门职司的人。故尔殷、周两代都有“百工”，就是职司各种工艺的百官。就在春秋时代，管仲也说“处工就官府”（《齐语》），而晋文公时的晋国也是“工贾食官”（《晋语》）。《考工记》前面说过是春秋时齐国的官书，他们的“攻木之工七，攻金之工六，攻皮之工五，设色之工五，刮摩之工五，抟埴之工二”，三十工也都是官。那儿所管的工事差不多全部都是上等的东西，只有一项“段氏为镈器”是和农业生产有关的，而职文偏偏缺了。官也要来做工的吗?如有人肯这样发问，问题便容易得到答案。其实那不是官自己动手，而是把工艺分成若干部门，设些官来专门掌管这些部门的无数群工艺奴隶而已。管理工奴的有工官，也就和管理耕奴的有农官一样。管理耕奴的农官，在卜辞里似乎称为“藉臣”，其在周代则称为“田畯”或“保介”。农业生产尽管庞大，但生产样式只有那么一套，故尔管理耕奴的官职比较少(人数却不必少)，而工艺部门的生产花样多，故尔管理工奴的官职要比较多。就从工艺这一分野，我们也尽足以证明，殷、周同是奴隶社会。这些并不是我在驰骋幻想，请记起鲁成公二年，楚国侵鲁，鲁国“赂之以执斲，执针、织纴皆百人”（《左传》）以求和的故事吧。那不足以证明就在春秋中叶以后，鲁国的木工、绣工、织工、缝工都还是没有人身自由的奴隶吗?</p>
<p>《考工记》的工官，单就那六种“攻金之工”来说，那所攻的金大抵都是青铜。青铜是铜与锡的合金，各种器具所用的青铜。在它们的合金成分上各有不同，《记》申都是详细地记载着的。金有六齐(剂)。六分其金而锡居一，谓之钟鼎之齐；五分其金而锡居一，谓之斧斤之齐；四分其金而锡居一，谓之戈戟之齐；参分其金而锡居一，谓之大刃之齐；五分其金而锡居二，谓之削杀矢之齐；金锡半，谓之鉴燧之齐。只有镈器之剂没有提到，镈器在春秋时是已经有了用铁的征据的。青铜的冶铸都有工官职管，因而我们可以知道，殷、周两代传世的青铜器都是出于工艺奴隶之手，而青铜器也就恰好是殷、周社会所遗留下来的时代铜像了。在这儿我们看不出殷、周之间有什么划时代的区别，不仅没有，就像青铜合金一样泯合着，铜与锡分不开来。中国的青铜器时代起源于什么时候，现在还不知道。但我们所知道的是殷末和西周前半已经达到了青铜冶铸的最高峰。体质、形式、花纹、铭辞、字体，一切都非常庄重，丝毫也不苟且。这一时期的古器，向来是为骨董家们所特别珍重的。除掉直接由殷虚发掘，或由铭文本身表露着是殷是周，我们因而可分别为殷器或周器之外，无铭或仅一二个图形文字，以及有“以日为名”的一二个简单的名号，如祖甲、父乙，妣丙、母丁，兄壬、妇癸之类的，我们是无法分别殷、周的。旧时以“以日为名”为殷习，凡有那种名号之器统称为殷彝，现在我们已经知道“以日为名”之习就在西周中叶也还残留着，那个根据是不能成为绝对的标准了。西周初年的一切都是沿袭着殷制，尤以这青铜器为最显著。最好请从花纹上去看时代吧，所谓夔龙、夔凤、饕餮、雷纹，全部都措用着殷代的图案，原始的图腾气味是十分浓厚的。但到恭王、懿王以后就渐渐改变了。体质、形式、花纹、铭辞、字体，一切都变得很潦草。以花纹而言，前期的那些图案渐渐消灭，或变而为异常简单的粗枝大叶的几条曲线，如夔龙变成为横写的S字形之类，非是细心的人，追迹着全时代的进展，是找不出它们之间的联系的。铭辞字体都非常草率，甚至有不少夺掉字句的例子。这颓废的气韵一直传到春秋中叶，又才来了次一期的变化。这一次的变化可以说是“中兴”，然而与殷末周初还是判然不同的。在中兴期里面，一切都变得精巧玲珑了。体质轻便，形式新鲜，花纹工细，铭辞多韵文，字体用花文，草率的陋习完全革掉，而原始的风味也完全扬弃了。特别是在花纹里面，有现实的动物形象出现，工细之极已经开始使用印板。字体有意求工固不用说，而且有所谓“鸟篆”出现，一字的笔画尽可能使之鸟形化，或把鸟形附加上去，纯粹是装饰的意味。这一期也可以称为艺术期，自春秋中叶至于战国末年。但自战国末年以后随着青铜器时代的下台，这些艺术的努力便从青铜器上面移往别的器用上去了。以上是青铜器的演变。这样的波动，我们从社会史上怎么来加以说明呢?这很简单，和农业的发展是一致的。便是在殷末周初是奴隶生产的最高度发展的时期。恭、懿以后毛病渐渐生出来了，就和有农田和耕奴的人尽力榨取耕奴的剩余劳动以成为地主一样，管工奴的人也尽力榨取工奴的剩余劳动以成为工头了。怎样榨取法呢？便是对于公家的器皿尽力草率，敷衍塞责，而把劳力挪用到低级品的生产上，以换取新兴地主或耕奴们的米谷钱财。这样也就促进了商行为。所渭“如贾三倍，君子是识”，所说的就是这个事体。西为交易主要发生于农工之间，而农官工官都是所说的“君子”。就这样百工们也领略到做生意比做工官还要有利，他们也就渐渐脱离官籍，而新成为一种工商阶层，故尔他们的姓氏多半是沿用着他们的职名。这分化和地主的产生过程相同，而时期也约略一致。在初这些私人生产也和私田一样，国家是不课税的，所谓“市廛不税，关讥不征”。然而涓涓之水，后来成了江河，和私田不能不取赋一样，关市也就不能不征税了。这一转变，在周室大约是在厉王时代，所谓厉王“学专利”（《国语·周语》），案其实也就是想把那些私人生产的所得收归国有，而结果是遭了大反对，被逼着出了京城。宣王承继着他，把政策缓和了一点，所谓“不藉千亩”，所谓“诸侯百姓，厥贮毋敢不即市”，是表明着私田有税，关市有征，然而不是全盘夺取了。新兴的地主阶层和工商阶层，在初起时，在本质上并没有什么差异。地主依然靠奴隶的剥削，工商也一样靠奴隶的剥削。金文里面有把邑来和田交换的例子。邑中必带有生产的工奴，田中也必带有生产的耕奴，不然那是不成意义的。还有把邑来做赏赐品的，也不能认为只有房屋没有人。《易·讼卦》九二：“不克讼，归而逋其邑人三百户。”这些逃亡了的“邑人”，岂不同样是奴隶吗?这样无限制的剩余劳动的剥削便同样地使商人的势力后来逐渐庞大了。拿郑国的情形来说，在东周初年郑国的建国差不多就是纯全靠执政者(新兴地主)和商人的同盟而成立的。子产有一段建国的追忆，这样说道：昔我先君桓公，与商人皆出自周。庸次比耦，以艾杀此地，斩之蓬蒿藜藋(当时的河南还是这样的情形，请注意)而共处之。世有盟誓以相信也，曰：“尔无我叛，我无强贾。毋或匄夺。尔有利市宝贿，我勿与知。”恃此质誓，故能相保，以至于今。（《左传》昭十六年）地主和商人都是遭了亡国的惨祸，由宗周逃走出来的，走到新开的土地，组织了这么一种新式的联合政权，而这政权的联系看来也是很疏松的，商人毫无纳税义务，竟俨然敌国。这种商人如没有控制着多量的奴隶以从事生产或流通，那是怎么也不能想象的事。说到郑国的商人使我们必然联想到的是弦高犒师的故事。鲁僖公三十三年春，秦国的兵走过周的北门，到了滑地，打算侵袭郑国。适逢其会，郑国的商人弦高要到周去做生意，便在路上碰着。弦高便把十二条牛拖着四车皮革以犒劳秦师，矫称奉郑国的君命，以表示郑国有备。一方面又派人兼程回郑国报信。结果秦兵也就不敢侵郑，把滑灭了之后便回去了。这弦高的气派不也俨然像一个王者吗?这假如不是驱策着一大群奴隶而且有干戈兵甲的保卫以组成一个大商队行进，那也是不能令人想象的事。郑国是由西周蜕变出来的，它的情形比其它各国要早些的，而实际上不过如此。其它国度，如有名的货殖大家白圭，是战国初年魏文侯时代的人，他所有的大本领之一，是“能……与用事童仆同苦乐”（《史记·货殖列传》）。可见他用来经商的管事，都还是家奴。一直到战国末年的吕不韦，以一个国际商人的资格，一跃而登上秦国的政治舞台，他所有的家僮是万余人，比起弦高的气派来，不用说是更加煊赫了。汉时也还有家僮存在，如西蜀的卓氏、程郑是有名的例子。但是汉代的奴隶多用于工商业的经营，不能认为生产的主流了。准上我们可以知道，青铜器的制作至春秋中叶之所以突然中兴的关系，是因为新分化的工商业发达了的结果。特别显著的是花纹、器制、铭辞、字体，差不多无分南北，都有一致的倾向。十几年前在呼和浩特市北一百里左右的李峪村，曾经出现过一大批铜器，精巧异常，由法国的商人王尼克(L.Wanieck)运往了欧洲，一时漫无根据地称之为“秦式”。但到后来，在洛阳韩墓，在寿春楚墓，以及淮河流域一带，和最近在长沙出土的器物，都和呼市器群的花纹形式相差不远。因此才得以断定，那并不是什么“秦式”，而是春秋中叶以还普遍于南北的一种新型。一一这样的普遍性的说明，自然也只好求之于工商业的普遍发展了。但这一发展是在西周以后，而不是在西周时代，我们是须得把它认识清楚的。西周的商行为并不是没有，但不能说是已经发展。前面已经提到过，孝王时的奴隶买卖还在实物交易与准货币交易的状态。厉王时的田邑交易，也是实物交易的一例。还有一个《格伯簋》，大约是上下年代的东西，那铭文载着有“格伯爫又（上下结构）良马乘于倗生，厥贮{价)卅用则析”。以三十田去换四匹马(四马为乘)，也依然是实物交易。在西周，货币制并未发达。周人曾经沿袭殷人的习惯，使用过贝子与铜块，终西周之世似乎都是这样的情形。金文中有一个字，为西周后半叶所常见的，便是《毛公鼎》(宣王时器)的“取箦卅寽”的取下一字。这个字在别的器皿里面或从双人旁(如《曶鼎》、《酨簋》)，或从走之(如《扬簋》、《番生簋》、《■簋》)。这种东西是以寽为单位的，可见依然是生铜，如后世使用金锭银锭那样。这只能说是准货币，还未达到纯粹货币的阶段。就是贝子的使用也是这样的，因为它是兼备着装饰品和价值媒介的双重使命的。纯粹货币的使用，盛行于战国年间。它的绝对年代还未十分考出，但至古也不能超过春秋中年。战国时代的货币，形式是多种多样的，概略言之，可以分为四种。一种是秦式，圆形方孔，铸有“半两”二字，古泉家称为寰法。二种是晋式，钱镈形(钱本是耕具，货币因之而名为“钱”，原义反失)，大小轻重不等，古泉家称为布，有方足布、尖足布等名。三种是齐式，刀形，出于齐地的有“齐邦法化”“即墨法化”，化就是货。出于燕地的有“明”字，古泉家称为明刀。这些都统被称为刀币。四种是楚式，豆腐干形，近年始出土，古泉家称为锾。偶于一小方中有“一两”二字，一大方为十六小方，即为一斤。文献中常见“金若干斤”之语，到现在才得到解释。后来，这些形式都统一于寰法；秦国混一天下固然是政治的原因，事实上还是它本身便当，形成了优胜劣败的现象。世界万国的硬币都通行着圆形。货币的发展和商业的发展是相应的，商业的发展又依存于农工，以故货币的形式也多是取自农人工人的用具，这是很有趣味的一个现象。例如晋式的博形是取象于耕具，而楚式的豆腐干形是取象于井田。又例如齐式的刀形是工人用具，而秦式的寰法也是环状石斧的再转化。(环状石斧一转化而为璧，再转化而为钱。)</p>
<p>在这儿我还要郑重地纠正我自己的另一个错误，便是关于铁器使用的时期。中国的铁器时代是秦以后才正式登上了历史舞台，这是毫无疑问的，例如以铁造兵器的史实是在汉代才普遍化了的。江淹的《铜剑赞序》说：“古者以铜为兵。春秋迄于战国，战国迄于秦时，攻争纷乱，兵革互兴，铜既弗克给，故以铁足之。铸铜甚难，求铁甚易。故铜兵转少，铁兵转多，二汉之世，既见其微”。这和考古上所见到的情形是一致的。存世秦前兵器都是铜制，至迟的有如秦《上郡戈》和《吕不韦戈》，足证秦始皇初年都还在用铜兵。汉代的铜兵却一件也不曾发现过。但铁兵的使用并不始于汉，在战国末年已经在开始使用了。《荀子·议兵篇》“楚人铁牠，惨如蜂虿”，又秦昭王曾赞叹“楚之铁剑利而倡优拙”（《史记·范睢列传》），可见铁兵的使用始于楚。在楚之外也还有别的国家在用铁器的，如中山的力士吾邱鸠的“衣铁甲，操铁杖以战”（《吕氏春秋·贵卒篇》），魏国信陵君的食客朱亥“袖四十斤铁椎，椎杀晋鄙”（《史记·信陵君传》），商鞅的铁殳（《韩非·南面篇》），韩国的铁幕（《韩策》）、铁室（《韩非·内储说上》）等。大率冶铁的技艺还未十分纯熟，没有制出像楚国那样更有效的积极的兵器。铁兵使用的开始并不就是铁的使用的开始，因为铁要能炼成钢，然后才能铸造成高级的兵器，在钢的使用之前应该还有一段长时期的毛铁的使用的。《孟子》书中已言“以铁耕”，可知当时耕具已在用铁。这种使用可以上溯至春秋年间，有文献可考的是在齐国。《管子·海王篇》：“今铁官之数日：一女必有一针一刀，耕者必有一耒一耜一铫，行服连轺輂者必有一斤一锯一锥一凿”。《管子》多是战国时代及其以后的文字纂集，所纂集的齐国的史籍，可能上溯至管仲时代。又《国语·齐语》也载有管仲的话：“美金以铸剑戟，试诸狗马；恶金以铸锄夷斤■，试诸壤土”。美金自然是青铜，恶金可能就是毛铁了。但要再朝上溯，便毫无根据了。《考工记》的“段氏为铸器”，职文适缺，是一件遗憾的事，即便是铁器也只是春秋后半叶的情形。《诗经·秦风》“驷鐡（马旁）孔阜”(襄公时诗)，说者谓马色如铁故名鐵（马旁），然安知非马名在先而铁名在后，即金色如骥故名铁?铁字并不古，在西周和以前的铁器也始终没有发现过。殷虚的发掘，得到了不少的铜器，有斧斤刀椎针镞矛戈之属及各种礼器，更还有不少的铜模、铜锅、铜矿及大块孔雀石，而却无丝毫的铁的痕迹。铁的发现不能上溯至殷末，由这比较科学的发掘是可以下出断案的。我从前发表《中国古代社会研究》的时候，殷虚才刚开始地面试掘，方法是很成问题的，我曾因试掘者董作宾的《新获卜辞写本》后记里面，于“同时出产之副产物”中有一个“鐵”字，表示过极大的惊异。这经后来的科学的发掘证明，是从被窜乱了的表层里面所拾得的后代窜人物而已。但比这更草率的，我竟据《诗经·公刘篇》的“取厉取锻”一语，而解释为周初已发现铁，作为周人的生产力超过了殷人的根源。这所犯的错误相当严重。《公刘篇》绝不是周初的诗，锻字的初文即是段字，有矿石，石灰石以及椎冶的含义，并没有铁矿的意思。我以前根据郑玄“石所以为锻质”的解释认为铁矿，那完全是牵强附会。现在我却可以得到一个更正确的推论了。冶铁技术的发明和发展不用说是冶金工业的一大进步，而把铁作为耕具及手工具的使用，又增加了整个的生产力，而使社会生产得到了更高一段的发展。这无疑便成为社会变革上的一个重要的契机。但这些事实，我们知道，并非出现于周初，而是出现于春秋、战国时代，那么，这铁的使用倒真正成为春秋、战国时代是古代社会的转折点的“铁的证据”了。</p>
<p><strong><font color="#FF7256">八、</font></strong> 奴隶就这样得到解放一些大夫或陪臣们，起先是靠着残酷的剩余劳动的剥削，逐渐起家，等到他们的羽翼丰满了，与更上层的榨取者成为敌对的形势，他们必然地要转换作风，把被剥削者的大群作为自己的同盟军，而与公家对抗。人民争夺战便不间断地展开出来。《左传》昭公三年齐国的晏婴和晋国的叔向谈到齐、晋之政的那一番有名的对话，是值得我们注意的。晏婴先说到齐国的情形上来，他说道：此季世也，吾弗知，齐其为陈氏(即田氏)矣。公弃其民而归于陈氏。齐旧四量：豆区釜锺。四升为豆，各自其四，以登于釜，釜十则锺。陈氏三量，皆登一焉，锺乃大矣；以家量贷而以公量收之。山木如市，弗加于山；鱼盐蜃蛤，弗加于海。民参其力，二入于公而衣食其一；公聚朽蠹而三老冻馁。国之诸市，屦贱踊贵。民人痛疾而或燠休之，其爱之如父母，而归之如流水。欲无获民，将焉避之!</p>
<p>这所说的新旧势力的对比相当详细，看这情形和鲁国的三家，特别是季孙氏，与鲁国公室斗争的步骤，差不多是一样。叔向说到晋国的情形上来，可惜又含糊了一点。且看他说：虽吾公室今亦季世也。戎马不驾，卿无军行。公乘无人，卒列无长。庶民罢敝而宫室滋侈，道殣相望而女富溢尤。民闻公命，如逃寇雠。栾、卻、胥、原、狐、续、庆、伯，降在皂隶，政在家门，民无所依。君日不悛，以乐韬忧。公室之卑，其何日之有!<br>这只说到公室的糊涂，而没有说到家门究竟是在怎样为政。不过我们从这里也可以推想得到一些影子。因为人民既闻公命如逃寇雠，必然另外有吸引他们的力量。而这力量既在家门，则家门所为的政必然是一些德政，至少总不是“宫室滋侈”而“女富溢尤”的暴政。不过晋国的情形要复杂些，不比齐国那么简单；晋国是六卿专政，在家门与公室之间既有斗争，而家门彼此之间又有斗争。可惜史籍上所剩下来的多是他们在军事上斗争的痕迹，而他们在政治上的施设，却差不多完全被湮灭了。像这样私家与公室之争，争取人民，在春秋、战国年代差不多是每一个国家所共通的现象，一直到秦始皇与吕不韦的斗争为止，才逐渐地走下了历史舞台。这儿正表明着一个社会变革的关键，人民就是在这样的契机下从奴隶的羁绊解放出来的。更进还有值得我们注意的是在春秋年间有所谓“士”的一种阶层出现。人民分化成为四民，所谓士农工商，而士居在首位。这是后来的封建社会的官僚机构的基层。我们如把这层忽略了，不仅周、秦之际的社会变革我们得不到正确的了解，那种变革之在周、秦诸子的意识形态上的反映，不用说是更得不到正确的了解的。士的起源究竟可以追溯在什么时代呢?士的含义颇多，如士女对言，那只是等于一般的男子；如公卿大夫士的所谓元士，那只是一些下级的官吏。这些都和我们现在所追求的士民的士不同。因此，如像《周书?多士篇》的“殷遗多士”，那在事实上只是一些“殷之顽民”，和后来的士也是不相同的。后来的所谓士，大率可以追溯到齐桓公的时候。管仲相齐桓公，“制国(都城)以为二十一乡，工商之乡六，士乡十五。”农人则居于鄙野，这是他的“四民者勿使杂处”的政策。他说：“昔圣王之处士也，使就闲燕，处工就官府，处商就市井，处农就田野。”虽然是假托之于古先圣王，但看他所说的士的内容和古代的情形已经是大有不同了。今夫士，群萃而州处，闲燕则父与父言义，子与子言孝，其事君者言敬，其幼者言悌；少而习焉，其心安焉，不见异物而迁焉。是故其父兄之教不肃而成，其子弟之学不劳而能。夫是故士之子恒为士。看这样子完全是一座世袭官僚养成所。这当然是从古时的庠序学校等所演变出来的，但在奴隶制时代，庠序学校等是教养贵冑子弟的地方，庶民子弟不能高攀。而在桓公时则有所谓“三选”之法，“匹夫有善可得而举”，可见庶民子弟已经可以上升为士。所以这种士已经不纯是贵冑而至少有一部分是人民了。这是值得特别注意的。《王制》里面也有一节选举的叙述更为详细，我率性把它摘录在下面吧。命乡论秀士，升之司徒，曰选士。司徒论选士之秀者而升之学，曰俊士。升于司徒者不征于乡，升于学者不征于司徒，曰造士。乐正崇四术，立四教，顺先王《诗》、《书》、《礼》、《乐》以造士。春秋教以《礼》、《乐》，冬夏教以《诗》、《书》。王大子、王子、群后之大子、卿大夫元士之適子、国之俊选，皆造焉。……大乐正论造士之秀者以告于王而升诸司马，曰进士。司马辨论官材。论进士之贤者以告于王而定其论。论定然后官之，任官然后爵之，位定然后禄之。这无疑也是从春秋或战国时代的文献所纂录下来的。因为司徒、司马等官在春秋以前，其官位并不隆崇，他们只是天官六大(大宰、大宗、大史、大祝、大士、大卜)之下的事务官而已。到了春秋时代，天官倒了楣，司徒、司马等职才辉煌了起来。在这一节叙述里面所值得注意的，是一些选士俊士等的所谓“国之俊选”，都是从人民里面选举出来的人。这就更加严密地接近后人所谓士了。当然，这些士虽说都由乡里所选进，而在事实上也并不必选自真正的劳力的人民，而只是选自新起的一些小地主。但这些小地主们的本身也多半还是奴隶，故从整个来说，奴隶是获得解放，而且获得了参预政权的门路，是毫无疑问的。这些初期的所谓士在性质上多少也还有些不同，便是他们是文武不分。故尔平时虽在讲学论道，而战时却一样地要被坚执锐。士既由民间上升，则上层的礼乐刑政所谓文化，也就因士为媒介而下降。文化便起了对流。不下庶人的礼乐，一部分下了下来；不登大雅之堂的东西，一部分也要登了上去。这种变革在文字上表现得最为明显。中国的头号古文如《诗经》的《雅》、《颂》，《书经》的《诰》、《命》，以及卜辞金文等，那和民间口语是绝对隔离的，焉乎也者那样的语助(表示口语形态的音符)是绝对不用的。到了春秋和战国时代，有这种语助辞的文体便大批出现了；我是称之为中国的二号古文，在当时其实就是口语。故从这文字的变革上也正明白地反映着社会的变革。士在春秋前期大抵是由各诸侯的公室所养畜，贵族或逃亡贵族的子弟占多数。但到末叶以后，私门和公室斗争，公室既在养士，私门也在养士。例如齐陈成子“杀一牛，取一豆肉，余以食士”（《韩非·外储说右上》）；又如鲁“季孙养孔子之徒，所朝服而与坐者以十数”（《韩非·外储说左下》）；可见私门养士之风已大盛行。至战国时代，公室如鲁穆公、魏文侯、齐威王、齐宣王、梁惠王、燕昭王等都曾经有一段时期成为文士的集中保护者。而私门如四公子一一孟尝君、春申君、平原君、信陵君及秦的吕不韦，也都动辄是食客三千，真可谓登峰造极。私门与公室之间就在养士上也有竞争。公室不能容便走私门，如田骈受谗于齐而奔薛，孟尝君闻之，使人以车迎。私门呆不住便跑公室，如李斯因吕不韦失足而上《谏逐客书》以媚秦王。于是乎所谓士的流品也就日渐复杂了。士成为了一种吃饭的职业，有所谓游士，有所谓辩士，走公室，跑私门，不狩不猎，不工不贾，四体不勤，五谷不分，也就尽可以糊其口于四方了。士一成为职业，自然也就成为择业的对象。有的人认此为终南捷径，便大家竞争着来学做士。《韩非·外储说左上》载有两段故事，便是“中章胥己仕，而中牟之民弃田圃而随文学者邑之半；平公腓痛足痹，而不敢坏座，晋国之辞仕记者国之锤(四分之一为垂)。”这些都是春秋末年的事，想见当时学读书学做士已经成了风气。孔子和墨子那两大读书帮口，便是在这样的风气中形成的。既有多数的人要靠着读书来取进身之阶，自然也就有孔、墨这样的大师，靠着教书来铺张自己的场面了。孔子有弟子七十二人，墨子有弟子百八十人，这些数目大概都是可靠的。孔子是宋人的私生子而生于鲁，自称“少也贱”，后来做到鲁国的大夫；墨于是鲁国贱人，后来也做到宋国的大夫。这些大概也都是事实。但他们的出身都是文学之士，墨子曾“习儒者之业”，这也是毫无问题的，不然他们根本就得不到接近学术的机会，那里还能够一跃而成为天下的“显学”呢?<br>士之中也有专门的武士，便是士卒。高级一点的自然是官，最低级的便只是兵。在战国时代为保卫所有权并侵夺弱者的所有权起见，各国便开始有常备兵的设置。因而当兵也就成为了人民解放的一个门径。关于兵的待遇，各国的情形不同，《荀子·议兵篇》替我们保存了一些重要的资料；在这里面，战国时，各国的社会由奴隶制蜕化的情形也表示得非常显明。齐人隆技击，其技也，得一首者则赐赎锱金。(取得一个首级的，给以八两黄铜。)</p>
<blockquote>
<p>魏氏之武卒以度取之。衣三属之甲，操十二石之弩，负矢五十个，置戈其上，冠胄带剑，赢三日之粮，日中而趋百里。中试则复其户(免其奴役)，利其田宅。(公田公宅归其私有。)</p>
<p>秦人……功赏相长也，五甲首而隶五家。(取得五名著甲者的首级的，便给以五家奴隶。)</p>
</blockquote>
<p>《汉书·刑法志》引用此文，以为“齐湣以技击强，魏惠以武卒奋，秦昭以锐士胜”。这可见齐之技击，魏之武卒，秦之锐士，为时先后，相差不远。齐人用金钱赏赐是商业式的办法，魏人用田宅赏赐是农业式的办法，秦人用奴隶赏赐可以说是工业式的办法。虽然方法不尽相同，但当兵的靠着自己的体力和本领，不仅解放了自己的奴役(“复户”)，而且得到了财力物力人力的私有。这无疑又是奴隶解放的另一种直接的关键，从这儿当然又可以有小规模的有产者出现了。又有所谓隐士或“辟世之士”。这在《论语》里面便有楚狂接舆、子桑伯子(即《庄子》的子桑户)、荷篠丈人、荷蒉、晨门、长沮、桀溺。孔门里面的颜回、原宪、琴张、曾皙、牧皮(即孟之反)，也是这一流。就连孔子自己多少都有些这样的倾向。孔子的老师老聃，老聃的弟子杨朱，不用说也就是这一派的大头目了。这一派人产生在春秋末年的社会关系，也是很容易地可以得到说明的。他们有的是由贱人上升的，有的是由贵族降落的；他们都有相当优越的智慧，并也都有不愁饥寒的小的官职或产业；在那社会的大动荡中经不起波折，或者无心上进，或者也无法上进，便乐得高尚其志，过着脱离现实的独善生活。有的疾世愤俗，做出些狂放不检的行为，故意去破坏既成的或方生的秩序(即所谓“礼教”)；有的又恬淡无为，安贫乐贱，而陶醉于自己所幻想出的精神世界。表现的方式虽然不同，但他们都是一群脱离现实的利己主义者，那是毫无问题的。既有这样的生活，当然会有超现实的理论出现以作为这种生活的根据。人是喜欢找理由来说明自己的立场的。因而老聃、杨朱的形而上的思想便发生了。但这思想，由于是脱离现实或超现实的东西，没有群众的基础，所以它不能像儒墨那样，在春秋、战国之交及早形成为一种有力的潮流。它的发展而为家派，要到齐国的威王、宣王时代，新兴的地主政权已经获得初步的稳定的时候，在一种高等的文化政策保护之下，才被培育了起来的。当时的稷下先生们里面，一大半是道家，如宋钘、尹文、田骈、慎到、接予、环渊之流，在稷下是执掌着牛耳的。在当时墨家已流入于秦，为秦惠王所保护；钜子腹黄享是惠王的先生，唐姑果是他的亲信。而齐国则保护道家。所以栖栖遑遑，找不着主子的儒家代表孟轲，便大发其牢骚，说“天下之言，不归杨，则归墨”，这话倒也是当时的学派势力的正确的反映。近时学者对于这些发生和发展的过程，不曾作出充分的追迹。他们只在浮面上看见杨朱没有著作传世(《列子》中有《杨朱篇》是晋人伪托)，又看见传世《道德经》是战国时人的述作，于是便怀疑杨、老的存在，有的又要把他们的年代降到战国中叶以后，这是受了形式逻辑的限制。在我看来，正是“知其一而不知其二”的见解。春秋末年还没有专门著书的风气，这早为学术界所承认了。故如孔、墨的书都只是门弟子们的纪录。像老聃和杨朱那样避世者流，当然更不会自己动手著书了。但他们总得也有些口说流传，我们是没有理由否认的。例如《庄子·天下篇》论到彭蒙、田骈、慎到的一派，说明了彭蒙是田骈之师，而彭蒙又有“彭蒙之师”。彭蒙之师日：“古之道人至于莫之是，莫之非而已矣”。这是先秦古籍中的唯一的资料。以年代而言，“彭蒙之师”或当与墨翟同时，相当于孔门弟子或再传弟子，然而他已经在说“古之道人”，而见解也是道家的见解。我们不因《天下篇》的孤证而否认“彭蒙之师”，以何因缘而能否认先秦诸子所公认的杨朱、老聃呢?</p>
<p>以前的人，又有的因为要争道统，不愿在通天教主的孔仲尼之上还有教祖存在，故尔要否定老聃。像唐代的韩愈就是这一派的代表，他认老聃是道家假造来争夺教席的，甚至儒家也胡涂了，竟承认孔子的确师事过老子。这完全是不顾事实的偏见。我们还有什么争道统的必要吗?尽管你是怎样的通天教主，但你总不能没有老师。其实孔子自己早就承认了：“述而不作，信而好古，窃比于我老彭。”（《论语·述而》）老就是老子，我们无须乎一定要强辞夺理地来剥夺这层师弟关系。我的看法倒很老实。我认为老子确有其人，也确是避世理论的倡导者。他虽然不曾著书，但有口说流传。现存的《道德经》是环渊亦即关尹所著录，但这书不是纪录体，而是赞颂体，因而强半以上都是环渊自己的东西。孔子是师事过老子的，但他们的生活态度不同，思想上没有多大关涉。老子的思想虽在孔、墨之先，而它的成为学派是在孔、墨之后，这种现象，就在近代的科学史中也有类似的例子。最后，还有所谓任侠之士，大抵是出身于商贾。商贾而唯利是图的便成为市侩奸猾，商贾而富有正义感的便成为任侠。故在古时如聂政、朱亥、剧孟、郭解之流，都大大小小地经营着市井商业。直到现在的江湖人士也还保存着这个传统。这在后来虽不再以士视之，而在古时可依然是士的一部分。《墨经上》说“任，士损己而益所为也”，可见墨家后学也还视任侠为士。大约就因为这样吧，近时的学者差不多普遍地有认任侠出于墨家的倾向，但那是不正确的。司马迁很同情游侠，曾为侠士们立传；除掉把延陵、孟尝、春申、平原、信陵，都认为是豪侠之外，而他说“闾巷之侠”，“儒墨皆排摈不载”，可见侠固非儒，然亦非墨。墨家的行谊有些近于任侠是实在的，但儒家里面有漆雕氏之儒，“不色挠，不目逃，行曲则违于臧获，行直则怒于诸侯”（《韩非·显学篇》），而却为墨子所反对，谓“漆雕刑残，［辱］莫大焉”（《非儒篇》）。汉初甚至有道家而“尚任侠”的入，最明著的如张良，如田叔，隐僻一点的如黄石公，如乐巨公都是。足见任侠出于墨，实在缺乏事实上的根据，而是富于盖然性的揣测。主要是由于墨家的基本立场隐晦了，我们只看见他们在“摩顶放踵”，或“赴火蹈刃”，而忽略了他们是在为谁如此。最好是平心静气地把《非儒篇》来研究一下，在那里面，墨家非毁儒者都是以帮忙私家一一所谓“乱臣贼子”为根据的，那么墨子自己岂不是明显地站在公室一方面的吗?这种立场，和任侠的态度，根本相反。因此，我很诚恳地请求，研究古代思想的朋友们从这项资料上来从新加以考虑。士的流品的复杂，所谓鸡鸣狗盗、引车卖浆者流，都可以成为士。那倒表示着在社会变革的过程当中，奴隶解放的程度相当彻底。但这种现象是不能够长久的，社会的动荡一平静了之后，士的成分便逐渐纯化；工农所打出来的天下，又由新的贵族们来君临着。那些地主和工商业的巨头代替了奴隶主的地位，把所谓“士”垄断了，也就是说把刑政大权垄断了。于是又形成一种新的封建秩序。工农所得的是什么呢?由有形的锁链变而为无形的锁链而已。</p>
<pre><code>写于一九四四年七月十八日
</code></pre><hr>
<h4 id="郭沫若《十批判书》（2）"><a href="#郭沫若《十批判书》（2）" class="headerlink" title="郭沫若《十批判书》（2）"></a>郭沫若《十批判书》（2）</h4><h5 id="孔墨的批判"><a href="#孔墨的批判" class="headerlink" title="孔墨的批判"></a><strong><font color="#FF7256">孔墨的批判</font></strong></h5><h6 id="论孔墨的基本立场"><a href="#论孔墨的基本立场" class="headerlink" title="论孔墨的基本立场"></a><strong><font color="#FF7256">论孔墨的基本立场</font></strong></h6><p>到了现在要来论孔子与墨子实在不是件容易的事。他们是大师，有不少的门徒，尤其孔子，二千年来是被视为了天教主的，关于他们的事迹和学说，自然不免有不少的美和傅益。譬如我们读一部《新约》，便只见到耶稣是怎样的奇，不仅难治的病着手成春，而且还有起死回生的大力。孔墨虽然没有这样被人神化，而在各自的门户内是充分被人化了的。因此，我们如未能探求得他们的基本立场之前，所关于他们的传说或著作，我们都不好轻率地相信。那么又什么资料上来探求他们的基本立场呢?很可庆幸的是他们态度差不多完全相反，我们最好从反对派所传的故事与批中去看出他们相互间的关系。反对派所传的材料，毫无疑不会有溢美之辞，即使有诬蔑溢恶的地方，而在显明相互的关系上是断然正确的。因此我采取了这一条路，从反对的镜子里去找寻被反对者的真影。墨子后起，他是反对孔子的。在现存的《墨子》书里面有《非儒篇》，那里面有几段关于孔子的故事，我觉得最有研究的价值。第一个故事：齐景公问晏子曰：“孔子为人何如?”晏子不对。公又复问，不对。景公曰：“以孔丘语寡人者众矣，俱以为贤人也。今寡人问之而子不对，何也?”晏子对曰：“婴不肖，不足以知贤人。虽然，婴闻贤人者入人之国，必务合其君臣之亲，而弭其上下之怨。孔丘之荆，知白公之谋而奉之以石乞。君身几灭而白公僇。婴闻贤人得上不虚，得下不危；言听于君必利人，教行于下必利上。是以言明而易知也，行明而易从也，行义可明乎民，谋虑可通乎君臣。今孔丘深虑周谋以奉贼，劳思尽知以行邪，劝下乱上，教臣杀君，非贤人之行也；入人之国而与人之贼，非义之类也；知人不忠，趣之为乱，非仁之类也。逃人而后谋，避人而后言，行义不可明于民，谋虑不可通于君臣；婴不知孔丘之有异于白公也，是以不对。”景公曰：“呜乎，贶寡人者众矣，非夫子则吾终身不知孔丘之与白公同也。”这个故事，在年代上有些大漏洞。楚白公之乱见《左传》哀公十六年。这一年的四月孔子死。七月白公胜发难。齐景公呢，已经死去十二年了，晏婴比景公还要死得早。因此以前的人便都说这是墨子的“诬罔之辞”，那自然是没有什么问题的。不过诬罔就算是诬罔吧，我觉得很有意思。因为我们从这儿可以看出：墨子是赞成“入人之国，必务合其君臣之亲，而弭其上下之怨”的，孔子呢，则和这相反，“劝下乱上，教臣杀君”。更说质实一点吧，便是墨子是反对乱党，而孔于是有点帮助乱党的嫌疑的。这是极有趣味的一个对照。第二个故事：孔丘之齐，见景公。景公悦，欲封之以尼谿，以告晏子。晏子曰：“不可。夫儒浩居(傲倨)而自，顿者也，不可以教下；好乐(音乐)。而淫人，不可使亲治；立命而怠事，不可使守职；宗(崇)丧循哀，不可使慈民；机服勉容，不可使导众。孔丘盛容修饰以蛊世，弦歌鼓舞以聚徒，繁登降之礼以示仪，务趋翔之节以观众，博学不可使议世，劳思不可以补民；累寿不能尽其学，当年不能行其礼，积财不能赡其乐。繁饰邪术以荧世君，盛为声乐以淫愚民；其道不可以期世，其学不可以导众。今君封之，以利齐俗，非所以导国先众。”公曰：“善。”于是厚其礼，留其封，敬见而不问其道。孔丘乃恚怒于景公与晏子，乃树鸥夷子皮于田常之门，告南郭惠子以所欲为，归于鲁。有顷闻齐将伐鲁，告子贡曰：“赐乎!举大事于今之时矣。”乃遣子贡之齐因南郭惠子以见田常，劝之伐吴；以教高、国、鲍、晏，使毋得害田常之乱；劝越伐吴。三年之内齐、吴破国之难，伏尸以亿术数。孔丘之谋也。这段故事的前半也见《晏子春秋》外篇，但《晏子春秋》一书很明显地是墨子学派的人所假托的。晏子反对孔子的说话完全是墨子的理论，《公孟篇》云：“子墨子谓程子曰：（儒之道足以丧天下者四政焉。儒以天为不明，以鬼为不神，天鬼不说，此足以丧天下。又厚葬久丧，重为棺椁，多为衣衾，……此足以丧天下。又弦歌鼓舞，习为声乐，此足以丧天下。又以命为有，……此足以丧天下。”）这四政和这儿的傲倨自顺，好乐淫人，立命怠事，崇丧循哀，是完全一致的。这段故事当然也是在做小说。但最重要的还是在后半，同前一个故事表示孔子在帮忙白公胜一样，他又在帮忙田成子。这事恐怕倒近乎事实，另一反对派的庄子后学，在《盗跖篇》里也提到过一些影子：“田成子常杀君窃国而孔子受币。”但在《论语》里面所说的情形便完全不同了。陈成子弑简公，孔子沫浴而朝，告于哀公曰：“陈恒弑其君，请讨之。”公曰：“告夫三子。”孔子曰：“以吾从大夫之后，不敢不告也。君曰告夫三子者？”之三子告，不可。孔子曰：“以吾从大夫之后，不敢不告也。”（《宪问》）这纯全是忠于主上，而反对乱贼的立场。但我们如要做一个公平的批判人，就宁肯相信《墨子》和《庄子》，而不肯相信一些孔门后学的。因为“三占从二”，我们当从多数。这是一。凡是扶助或同情乱党的人，他的子孙后进是谁也要替他掩盖掩盖的，这是二。第三个故事：“孔丘为鲁司寇，舍(捨)公家而奉季孙。季孙相鲁君而走，季孙与邑人争门关，决植。”这故事颇残缺，“决植”两字上当有夺文，不过意思是可领会的。决假为抉，植是户旁柱，相传“孔子之劲举国门之关而不肯以力闻”。“决植”大约就是当季孙逃走时，城门掩上了，逃不出，而孔子替他把城门挺开了?这位千斤大力士，照墨子看来是心术不正，所以他的弟子们也就跟着他学，到处捣乱。以下是这三个故事的总批评：“孔丘所行，心术所至也。其徒属弟子皆效孔丘。子贡、季路辅孔悝乱乎卫，阳货乱乎齐，佛肸以中牟叛，漆雕刑残，×莫大焉。夫为弟子后生［于］其师，必修其言，法其行，力不足，智弗及而后已。今孔丘之行如此，儒士则可以疑矣。”我们真应该感谢墨子或其后学，有他们这样充满敌忾的叙述和批评，不仅表明了孔子的真相，而且也坦露了墨子的心迹。一句话归总：孔于是袒护乱党，而墨子是反对乱党的人!这不是把两人的根本立场和所以对立的原故，表示得非常明白吗?</p>
<p>乱党是什么?在当时都要算是比较能够代表民意的新兴势力。陈成子以大量贷出而以小量收回，因而把齐国公室的人民尽量争取去了，这是很有名的故事。季孙氏在鲁也有类似的情形，他礼贤下士，“养孔子之徒，所朝服而与坐者以十数”（《韩非·外储说左下》）。就拿白公胜来说吧，令尹子西分明称赞他“信而勇，不为不利”。就是反对他的叶公也只说他“好复言而求勇士，殆有私乎?”如此而已。“好复言”应该是说话算数的意思，也就是所谓“信”了。他作乱的一年恰巧是孔子死的一年(鲁哀公十六年)，《左传》把那时的情形叙述得相当详细。他在七月发难，把令尹子西和司马子期都杀了，同时也把楚惠王捉着了。石乞劝他杀掉楚王，他不肯；劝他焚府库，他也不肯。结果惠王被人盗去，府库为叶公所利用，他竟一败涂地，“奔山而缢”了。关于焚府库的一节，《吕览·分职篇》有更详细的叙录，今揭之如次：白公胜得荆国，不能以其府库分人。七日，石乞曰：“患至矣，不能分人，则焚之。毋令人以害我”。白公又不能。九日，叶公入。乃发太府之货与众，出高库之兵以赋民，因攻之。十有九日而白公死”。据这故事看来，白公这个人实在还太忠厚了一点。石乞倒确是一位好汉。白公死后，他被人生擒，人们要他说出白公的死所，当然是准备戮尸，石乞不肯说。不说便要烹他，他也不肯蝉。结果他被人烹了。他倒确是一位智勇兼备的人。假使他果真是出于孔子的推荐，孔子不要算是很有知人之明的吗?</p>
<p>以下我们再把孔门弟子帮助乱臣贼子的罪状追究一下吧。</p>
<p><strong><font color="#FF7256">第一，“子贡、季路辅孔悝乱乎卫。”</font></strong>这是鲁哀公十五年的事，在孔子死的前一年。那时候的卫君彻，是蒯聩的儿子。卫灵公不喜欢蒯聩，把他赶出国外去了，死后卫国立了他的孙子彻为卫君，在位都已经十二年了。蒯聩施用阴谋回到岡里来。劫持着孔悝，夺取了他儿子的君位。子路在做孔悝的家臣，他因为反对蒯聩，被蒯聩的人把他砍死了。后来把他的尸首也煮成了肉酱。消息传来的时候，据说孔子正在炖肉吃，他连呼“天祝予！天祝予！”(祝者斫也)，叫人把炖的肉也倒了。这事，在庄子后学也在加以非难，《盗跖篇》云：“子路欲杀卫君而事不成，身菹于卫东门之上。”可见墨家和道家是同情蒯聩，而儒家是同情卫彻的。这在我们是无可无不可的事情，但要说“季路辅孔悝乱乎卫”或“欲杀卫君(指蒯聩言)而事不成”，不仅和当时的情形不甚相符，而且是有点类似于鞭尸戮墓了。关于子贡的参加，《左传》和《史记》等书均不曾言及，但除这《非儒篇》之外，《盐铁论》的《殊路篇》也说到子贡。“子路仕卫，孔悝作乱，不能救君出亡，身菹于卫。子贡、子皋(羔)遁逃，不能死其难。”《盐铁论》或别有所本，大约在当时，子贡在卫也是担任有什么职守的吧。</p>
<p><strong><font color="#FF7256">第二，“阳货乱乎齐。”</font></strong>阳货一名阳虎，这人在孔门弟子是没有把他当成孔门看待的，而且也把他说得很坏。但其实倒是一位了不起的人物。《孟子?滕文公篇》引阳虎曰“为富不仁矣，为仁不富矣”，真不失为千古的名言。《盐铁论?地广篇》引此二语作为“杨子曰”，因此有人遂疑阳货即杨朱(宋翔凤《论语说义》中有此说)，但在我看来，无宁是杨朱的兄弟杨布。《韩非?说林下》云：“杨朱之弟杨布，衣素衣而出，天雨，解素衣，衣缁衣而反。其狗不知而吠之。杨布怒，将击之。杨朱曰：子毋击也。子亦犹是。曩者，使汝狗白而往，黑而来，子岂能毋怪哉?”这两弟兄的性情一缓一急，颇有点像宋时的程明道与程伊川。古者布与虎间音，而布作钱币用，与货同义，是则布与货是一字一名，虎是假借字了。以时代说来没有什么龃龉，性格也还相符。阳虎本作乱于鲁，《左传》定公八年及九年载其事。八年冬十月，阳虎欲去三桓，入于灌阳关以叛。翌年六月伐阳关。阳虎出奔齐。他到齐国，请齐国出兵伐鲁，齐景公都打算答应他了，鲍文子以为不可。鲍文子说他“亲富不亲仁”，又说齐侯富于季孙，齐国大于鲁国，正是阳虎所想“倾覆”的。于是齐侯便听了他的话，把阳虎囚禁了起来。他逃了两次，终竟逃到了晋国，投奔赵氏。《左传》在这儿加了一句孔子的批评：“赵氏其世有乱乎!”这意思当然是很不满意于阳虎了。以上是节取《左传》的叙述，照这情形看来，阳虎无“乱乎齐”的痕迹，因而《孔丛子?诘墨篇》便引作“乱乎鲁”，孙诒让以为“当从《孔丛》作鲁”。然在《韩非?外储说左下》有下列一段关于阳虎去齐走赵的故事。阳虎去齐走赵。简主问曰：“吾闻子善树人。”虎曰：“臣居鲁，树三人，皆为令尹。及虎抵罪于鲁，皆搜索于虎也。臣居齐，荐三人，一人得近王，一人为县令，一人为候吏。及臣得罪，近王者不见臣，县令者迎臣执缚，候吏者追臣至境上，不及而止。虎不善树人。”据此，可见阳虎居齐，为时颇久；而他之去齐是因为“得罪”，则“乱乎齐”似乎也是事实，只这事实的真相是怎样，可不得而知了。唯《韩非·难四篇》亦言齐景公囚阳虎事，则与《左传》所述相同，或者是传闻异辞的吧。此外，同一《外储说左下》篇，还有批评阳虎的一节：阳虎议曰：“主贤明则悉心以事之，不肖则饰奸而试(弑)之”。逐于鲁，疑于齐，走而之赵。赵简主迎而相之。左右曰：“虎善窃人国政，何故相也?”简主曰：“阳虎务取之，我务守之。”遂执术而御之，阳虎不敢为非，以善事简主，兴主之强，几至于霸也。这批评可以算得公允。“兴主之强，几至于霸”和《左传》的“赵氏其世有乱乎”完全相反，仲尼的那句评语不是七十子后学的蛇足，便可能是刘歆弄的花样了。特别值得注意的，是这又一可宝贵的二句“阳虎议”一一“主贤明则悉心以事之，不肖则饰奸而弑之。”这确实是含有些革命的精神在里面的。这种精神不失为初期儒家的本色，例如孟子也说过这样的话：“君有过则谏，反复而不听则易位”，和这两句阳虎的主张是很相仿佛的。</p>
<p><strong><font color="#FF7256">第三，“佛肸以中牟叛。”</font></strong>佛肸是晋国范氏的家臣，他以中牟叛，大约是在鲁哀公五年。《左传》在此年夏言：“赵鞅伐卫，范氏之故也，遂围中牟。”赵氏与范氏敌对，因卫助范氏故伐卫，因中牟叛晋故围中牟也。关于这事，《论语·阳货篇》有纪录：佛肸召，子欲往。子路曰：“昔者，由也闻诸夫子曰：亲于其身为不善者，君子不入也。佛肸以中牟畔，子之往也如之何?”子曰：“然，有是言也。不曰坚乎，磨而不磷？不曰白乎，涅而不缁?吾岂匏瓜也哉?焉能系而不食?”佛肸要找老师去帮忙，老师也很想借这个机会去行道，“我难道是个硬壳葫芦儿?只能挂着做摆设，不能吃的吗?”急于想用世的孔老夫子的心境，真是吐露得淋漓尽致。这样袒护乱党的行径，连子路都不大高兴的，公然逃过了儒家后学的掩饰而收在了《论语》里面，实在是值得珍异的事。而且同在《阳货篇》里面还有公山弗扰的一节：公山弗扰以费畔，召。子欲往。子路不说(悦)曰：“末之也已，何必公山氏之之也!”子曰：“夫召我者而岂徒哉?如有用我者，吾其为东周乎!”《左传》作公山不狃，以费畔事系于定公十二年，然在《孔子世家》则系于定公九年阳虎奔齐之后。公山与阳虎同党，阳虎于定公八年“入灌阳关以叛”，公山当亦同时响应，其定公十二年之畔，盖定而复反者也。定公十二年时孔子正为鲁司寇，则召孔子事当在八年。此事虽记于《论语》，而《非儒篇》不及，盖因公山氏非孔门弟子之故。</p>
<p><strong><font color="#FF7256">第四，“漆雕刑残。”</font></strong>《孔丛子·诘墨篇》引作“漆雕开形残”，形与刑通，漆雕之为漆雕开，殆无疑问。唯因何而“刑残”，事无可考。《韩非·显学篇》儒家八派中有“漆雕氏之儒”，又言“漆雕之议，不色挠，不目逃，行曲则违于臧获，行直则怒于诸侯”，虽同一有姓而无名，亦当是漆雕开。王充《论衡·本性篇》，载漆雕开言“人性有善有恶”，与宓子贱、公孙尼子、世硕诸儒同，可见漆雕开确曾成一学派。《汉书·艺文志》儒家有“《漆雕子》十三篇”，班固注云“孔子弟子漆雕启后”，启即是开，因避汉景帝讳而改。後乃衍文。盖启字原作启，与后字形近。抄书者于字旁注以启字，及启刊入正文，而启则误认为后，更转为後也。这一学派既尚勇任气，藐视权威，自然是有遭受“刑残”的充分的可能。且此事，既与子路乱卫、阳货乱齐、佛肸衅晋等并列，必然也是所谓叛乱事件，那是毫无疑问的。尤可注意的，初期儒家里面也有这样一个近于任侠的别派而为墨家所反对。近时学者，每以为侠出于墨，或墨即是侠；有此一事也就是强有力的一个反证。任侠之轻死虽有类于墨氏的“赴火蹈刃”，但他们的反抗权威却和墨家的“尚同”根本相反，我们是须得注意的。又《孟子》书中言：“北宮黝之养勇也，不肤挠，不目逃，思以一毫挫于人，若挞之于市朝。不受于褐宽博，亦不受于万乘之君；视刺万乘之君若刺褐夫。无严诸侯，恶声至，必反之。”（《公孙丑上》）这和漆雕氏之议很相近。孟子又说，“北宫黝似子夏”，大约这位北宮黝也就是漆雕氏的后学，是一位儒家了。以上，孔子帮助乱党，与其门人弟子帮助乱党例，见于《非儒篇》者一共七项。墨家既一一列举出来加以非难，在墨家自己当然是决不会照着这样做的了。这不是很鲜明地表示着了儒墨两派的基本立场吗?至少在初期，这情形，是无可否认的。所揭举的事实虽然不尽可靠，而《非儒篇》也不必就是墨子所写下来的文字，然把两派的立场实在是画出了极其鲜明的轮廓。以前推崇孔子的人，因为孔子已经成为了“大成至圣”，对于这些材料一概视为诬蔑，全不加以考虑。现今推崇墨子的人，把墨派几乎当成了不可侵犯的图腾，对于这些材料又一概视为痛快，也全不加以考虑。这些态度，我认为都是有所蒙蔽，非把这蒙蔽去掉，我们是得不到正确的认识的。自汉武帝崇儒术黜百家以来，孔子虽然处于至高无上的地位，但在他构生前其实是并不怎么得意的，《龙子·让王篇》说他“再逐于鲁，削迹于卫，伐树于宋，穷于商、周，围于陈、蔡，杀夫子者无罪，藉夫子者无禁”；《吕览·慎人篇》亦有此说。注云“藉犹辱也”，足见孔子在当时，至少有一个时期，任何人都可以杀他，任何人都可以侮辱他的。这和亡命的暴徒有何区别呢!因此，我们要说孔子的立场是顺乎时代的潮流，同情人民解放的，而墨子则和他相反。这在孔门后学或许会喊冤屈，而在墨家后学是应该没有什么话好说的。儒者要喊冤屈，这可能性很大。就是孔子在生当时，他的门徒已经在替他粉饰了。《论语》里面有下列一段故事，值得我们叙录。子疾病，子路使门人为臣。病间，曰：“久矣哉，由之行诈也!无臣而为有臣，吾谁欺?欺天乎!且予与其死于臣之手也，无宁死于二三子之手乎!且予纵不得大葬，予死于道路乎！”（《子罕》）这个故事不仅表示了孔子的态度，也把过渡时代的当时的时代性，表示得很清楚。臣是奴隶。在奴隶制时，主人死了奴隶大多数是要殉葬的，即使不殉葬总必然有一些特殊的行动。孔子生了病，子路以为会死，故尔把门人来假装成奴隶。这在子路或许是沿守旧制，想替孔子撑撑门面吧，也就和现今都还在烧纸人纸马那样。然而竟惹得孔老夫子那样生气，那样愤慨，痛骂了子路一顿。我顺便要在这儿解释一下“门人”和“弟子”之类的字眼。这是春秋末年的新名词。那时沿守旧制的，有时也称为“徒”，称为“役”。门人服侍先生，和奴隶的情形差不多，不过是志愿性。而非强制性而已。“有事，弟子服其劳；有酒食，先生馔。”先生出门的时候，弟子要“仆”(即是当车夫)，要任徒卫。但究竟不是徒，不是役，年稍长者先生视之如弟，稍幼者视之如子，因而有“弟子”之名。保守的子路，似乎不懂得孔子正以有“二三子”为新时代的光荣，而他偏要使同学们退回到旧时代的躯壳里去，竟挨受了那么一顿臭骂，那是罪有应得的。但在于路或许还是出于无心，而在孔子死后，有心的粉饰更是层出不穷了。所谓“孔子没而微言绝，七十子丧而大义乖”，至少在这些方面是没有什么夸张的。一方面有墨家道家的攻击，另一方面以前的“窃国者”已经“为诸侯”了，乱党同情者的帽子是不好久戴的。故尔在《论语》里面也就有“陈恒弑其君，请讨之”的完全相反的记事，也更有“天下有道则政不在大夫，天下有道则庶人不议”之类的有道无道的放言，矛盾固然是矛盾，但我们与其相信神道碑上的谀词，无宁相信黑幕小说上的暴露。到了孟子手里粉饰工作更加彻底了，如“孔子于卫主痈疽，于齐主寺人瘠环”，大有不择木而栖的情况，也被斥为“好事者为之”，而另外说出了所主的两位正派人物来。到底那一种说法近乎事实，无从判断，但孟子是惯会宣传的人，他的话要打些折扣才行。举如他所说的“孔子成《春秋》而乱臣贼子惧”，那也就是一个最适当的例。《春秋》或许真是孔子所作的书吧，但那样简单的备忘录，在二百四十二年的行事当中记下了“弑君三十六，亡国五十二”，与其说足以使“乱臣贼子惧”，无宁是足以使暴君污吏惧的。</p>
<h6 id="论孔子的思想体系"><a href="#论孔子的思想体系" class="headerlink" title="论孔子的思想体系"></a><strong><font color="#FF7256">论孔子的思想体系</font></strong></h6><p>孔子的基本立场既是顺应着当时的社会变革的潮流的，因而他的思想和言论也就可以获得清算的标准。大体上他是站在代表人民利益的方面的，他很想积极地利用文化的力量来增进人民的幸福。对于过去的文化于部分地整理接受之外，也部分地批判改造，企图建立一个新的体系以为新来的封建社会的韧带。廖季平、康有为所倡道的“托古改制”的说法确实是道破了当时的事实。一个“仁”字最被强调，这可以说是他的思想体系的核心。“仁”字是春秋时代的新名词，我们在春秋以前的真正古书里面找不出这个字，在金文和甲骨文里也找不出这个字。这个字不必是孔子所创造，但他特别强调了它是事实。仁的内函究竟是怎样呢?虽然没有一个明确的界说，我们且在《论语》里面去找寻一些可供归纳的资料吧。</p>
<p>一、“樊迟问仁，子曰‘爱人’。”(《颜渊》)</p>
<p>二、“子贡曰：‘如有博施于民而能济众，何如?可谓仁乎?’子曰：‘何事于仁?必也圣乎，尧舜其犹病诸。夫仁者，己欲立而立人，己欲达而达人，能近取譬，可谓仁之方也已。’”(《雍也》)</p>
<p>三、“子张问仁于孔子。孔子曰：‘……恭、宽、信、敏、惠。恭则不侮，宽则得众，　信则人任焉，敏则有功，惠则足以使人。’”(《阳货》)</p>
<p>四、“顾渊问仁。子曰：‘克己复礼为仁。……非礼勿视，非礼勿听，非礼勿言，非礼勿动。’”(《颜渊》)</p>
<p>五、“司马牛问仁。子曰：‘仁者其言也■。…为之难，言之得无■乎?’”（同上）六、“刚毅木讷近仁。”(《子路》)</p>
<p>七、“巧言令色鲜矣仁。”（《学而》，又见《阳货》）八、“志士仁人无求生以害仁，有杀身以成仁。”(《卫灵公》)</p>
<p>八、“仁者先难而后获。”（《雍也》）</p>
<p>从这些辞句里面可以看出仁的含义是克己而为人的一种利他的行为。简单一句话，就是“仁者爱人”。但古时候所用的“人”字并没有我们现在所用的这样广泛。“人”是人民大众，“爱人”为仁，也就是“亲亲而仁民”的“仁民”的意思了。“巧言令色”是对付上层的媚态，媚上必傲下，故他说“鲜矣仁”。“巧言令色”之反即为“刚毅木讷”，对于上层能如此，对于下层也不过如此，所以他说“近仁”。因此我们如更具体一点说，他的“仁道”实在是为大众的行为。他要人们除掉一切自私自利的心机，而养成为大众献身的牺牲精神。视听言动都要合乎礼。(就是“复礼”，复者返也。)礼是什么?是一个时代里所由以维持社会生活的各种规范，这是每个人应该遵守的东西。各个人要在这些规范之下，不放纵自己去侵犯众人，更进宁是牺牲自己以增进众人的幸福。要这样社会才能够保持安宁而且进展。要想自己站得稳吧，也要让大家站得稳；要想自己成功吧，也要让大家成功。这是相当高度的人道主义，要想办到这样的确不大容易，所以说“为之难”。他也这样叹息过：“我还没有看见过从心坎里喜欢仁的人，也没有看见过从心坎里恨不仁的人。只要有人能够有一天把自己的力量用在仁的身上，我还不相信有什么力量不够的事情。从心坎里欢喜仁的人，从心坎里恨不仁的人或许有的吧，但我还没有看见过。”这也许是他有所愤激的时候说的话吧：因为在他的门徒们里面有一位颜渊，便是“其心三月不违仁”的人。三个月不改变仁者的心肠或许还短了一点，“其他的人便只是偶而仁一下而已。”孔子的理想，是要：“无终食之闲违仁，造次必于是，颠沛必于是。”尽管是怎样的流离困苦，变起仓卒，都不应该有一顿饭的时刻离开了为大众献身的心。这是要自己去求的，自己去做的，并不是高喊人道主义而希望别人给我些什么恩惠。这也并不在远处，就在自己的身边，也就在自己的身上。为仁由己，而由人乎哉!（《论语·颜渊》）仁远乎哉我欲仁，斯仁至矣。（《论语·述而》）伯夷、叔齐求仁而得仁。（同上）仁既是牺牲自己以为大众服务的精神，这应该是所谓至善，所以说“苟志于仁矣，无恶也”，一一只要你存心牺牲自己以维护大众，那就干什么事情都是好的。你既存心牺牲自己，不惜“杀身成仁”，那还有什么可怕的呢?又还有什么不能够敢作敢为的呢?在这些场合就是先生在前也不能和他推让，他不做，我也要做。所以他说：“仁者不忧”，“仁者必有勇”，“当仁不让于师”。但是仁是有等次的，说得太难了，谁也不肯做，故教人以“能近取譬”。或者教人去和仁人一道慢慢地濡染，这就叫作“亲仁”，也就是所谓“里仁为美”。人对于自己的父母谁都会爱的，对于自己的儿女也谁都会爱的。但这不够，不能就说是仁，还得逐渐推广起来，要“老吾老以及人之老，幼吾幼以及人之幼”。假使推广到“博施于民而能济众”，你是确确实实有东西给民众而把他们救了，那可以说是仁的极致，他便称之为“圣”了。他认为尧、舜便是比较接近于这种理想的人格。孔子曾说“吾道一以贯之”，但他自己不曾说出这所谓“一”究竟是什么。曾子给他解释为“忠恕”，是不是孔子的原意无从判定。但照比较可信的孔子的一些言论看来，这所谓“一”应该就是仁了。不过如把“忠恕”作为仁的内函来看，也是可以说得过去的。这两个字和“恭宽信敏惠”也没有什么抵触。恭与信就是忠，是克己复礼的事。宽与惠就是恕，是推己及人的事。敏是有勇不让，行之无倦的事。这种由内及外，由己及人的人道主义的过程，应该就是孔子所操持着的一贯之道。他在别的场合论到君子上来的时候，是说“修己以敬”，“修己以安人”，“修己以安百姓”，所说的就是这一贯的主张了。“修己以敬”是“克己复礼”；“以安人”是“己欲立而立人，己欲达而达人”；“以安百姓”是“博施于民而能济众”。故尔他说“修己以安百姓，尧、舜其犹病诸”，也和“博施于民而能济众，尧、舜其犹病诸”，是一样的意思了。这种所谓仁道，很显然的是顺应着奴隶解放的潮流的。这也就是人的发现。每一个人要把自己当成人，也要把别人当成人，事实是先要把别人当成人，然后自己才能成为人。不管你是在上者也好，在下者也好，都是一样。但要做到这一步，做到这一步的极致，很要紧的还是要学。人是有能学的本质的，不仅在道义上应该去学仁，就是在技艺上也应该去学要怎样才可以达到仁的目的。立人立己，达人达己，不是专凭愿望便可以成功的事情。因而他又强调学。《论语》一开头的第一句便是：“学而时习之，不亦悦乎!”究竟学些什么呢?礼乐射御书数的六艺应该都在所学的范围之内，而他所尤其注重的似乎就是历史，看他自己说他“述而不作，信而好古”，又说“好古敏以求之”，可见他是特别注重接受古代的遗产。看他把一些古代的人物如尧、舜、禹、汤、文、武尤其周公，充分地理想化了，每每在他们的烟幕之下表现自己的主张，即所谓“托古改制”。他之注重历史似乎也有一片苦心。除这“好古”之外，还有一种求学的法门便是“好问”。“就有道而正焉”，“不耻下问”，便是这一法门的指示。故尔他说：“不曰如之何如之何者，吾末如之何也已矣。”而他自己是“入太庙每事问”，“三人行必有我师”的。大概在一定的范围内，什么事都可以学，什么人都可以问。这一定的范围赋有道德的属性和政治的属性，这差不多是先秦诸子的通有现象，严格地说来，先秦诸子可以说都是一些政治思想家。为什么有这样的通性呢?那是因为为士的阶层所制约着的原故，士根本就是一些候补官吏。所谓“学而优则仕”，“学古人官”，倒不限于儒者，就是墨法名道诸家都是一样。“士者所以为辅相承(丞)嗣(司)者也”（《尚贤》，上），这是墨子的士观。“士生乎鄙野，推选则禄焉”（《齐策》），这是道家颜斶的士观。可知学为士就是学为官，不是学为农，学为工，学为商。工农商之能成其为学，又是资本主义社会成立以后的事了。但在这学为官的范围内，“夫子”倒的确是“焉不学，而亦何尝师之有”的。在这个范围以外那就成问题了。樊迟请学稼，他说“吾不如老农”；请学为圃，他说“吾不如老圃”。农为他所不曾学。也为士所不必学，故接着他还斥责樊迟为“小人”。他说：“上好礼则民莫敢不敬；上好义则民莫敢不服；上好信则民莫敢不用情。夫如是则四方之民襁负其子而至矣，焉用稼?”问农没有答出，却来这么一套不相干的政治理论，显然樊迟的问是逸出了士学的范围的了。墨子也和这是一样，他说过：“一农之耕分诸天下，不能人得一升粟；一妇之织分诸天下，不能人得尺布；不若诵先王之道而求其说，通圣人之言而察其辞。虽不耕而食饥，不织而衣寒，功贤于耕而食之，织而衣之者”（《鲁问篇》）。这是当时为士者的通识。和这不同的就只有一些避世之士和后起的一部分道家而已。但那出发点是超现实的独善主义，我们是须得注意的。工艺似乎学过。孔子自己说：“吾少也贱，故多能鄙事。君子多乎哉，不多也。”又说：“吾不试，故艺”(试是浅尝之意)。这些艺能，大约不是指射御之类吧，射御是君子所必学的，不能视为鄙事或贱艺。商是不曾学过的，也是为士者所不应该学的。子贡会经商，他说他“不受命而货殖”，而他自己是“罕言利”，又说“喻于利”的是小人。他是文士，关于军事也没有学过。卫灵公问阵，他说：“俎豆之事则尝闻之矣，军旅之事未之学也。”接着便赶起车子跑了。不过他也并不如旧式注家所拟议的那样看不起军旅之事。为政之道，他既主张先“足食足兵”，又还说过，“以不教民战是谓弃之”，“善人教民七年亦可以即戎”那类的话。军事的学习虽也是士的分内事，只是他对于这方面没有充分地研究过而已。他为人为学倒很能实事求是，主张“知之为知之，不知为不知”，主张“多闻阙疑，多见阙殆”一一可疑的，靠不着的，不肯乱说。又说“多闻择其善者而从之，多见而识之，知之次(次第)也”，可见他是很能够注重客观观察的。“吾尝终日不食，终夜不寝，以思，无益，不如学也。”这个经验之谈很有价值，可见他是反对瞑想那种唯心的思维方法的。但他也并不泯却主观，一味的成为机械。“学而不思则罔，思而不学则殆”，必须主观与客观交互印证，以织出一条为人为己的道理，然后他才满足。然而时代限制了他，他肯定人类中有“生而知之”的天才，他说：“生而知之者上也，学而知之者次也，困而学之又其次也，困而不学，民(盲)斯为下矣。”又说：“上智与下愚不移。”不移的下愚，我们能够承认其存在，如早发性痴呆症，那的确是没有办法的。生而知之的上智，却完全是莫须有的幻想。不过，好在他自己还不曾自认是生而知之的人。他自己的述怀是：“我非生而知之者，好古敏以求之者也。”故他所强调的还是“学而知之，困而学之”的步骤。他自己的敏求是到了“发愤忘食，乐以忘忧，不知老之将至”的程度的；他教人好学也要“食无求饱，居无求安，敏于事而慎于言，就有道而正焉”；又说，“士志于道而耻恶衣恶食者未足与议也。”他的十五志学，三十而立，四十不惑，五十知天命，六十耳顺，七十从心所欲不逾矩的那个简略自传，也表示着他一生都在困学敏求当中过活。他注重历史，因而也注重根据。“怪力、乱神”之类的东西他是不谈的。要考证夏礼和殷礼，他嫌在夏后的杞国和殷后的宋国都无可征考，因为“文献不足”。儒家的典籍当中，《诗经》大约是由他开始搜集的吧。他已经屡次说到“《诗》三百”的话上来，又曾提到《雅》和《颂》。这一部最早的古诗总集里面，夏诗自不用说，就连殷诗也一篇都没有，《商颂》是宋襄公时正考父所作的东西。《书经》的情形稍微不同。这部书虽然也在他所“雅言”之例，但他很少征引。大约在他当时并不曾搜集到好多篇章吧。他把《诗经》看得特别重要，看来似乎是他所使用的极重要的：一部教材。“兴于诗，立于礼，成于乐”，“诗可以兴，可以观，可以群，可以怨”，“不学诗无以言，不学礼无以立”，可见他是特别注重诗教，也就是情操教育了。学诗不仅可以增广知识，“多识于鸟兽草木之名”，而且可以从政，可以做外交官，、据说都能因此而做得恰到好处。这大约是由于诗里有民间疾苦，有各国风习，有史事殷鉴，也有政治哲理的原故吧。把好多优美的古诗替我们保留了下来，单只这一点，应该也可以说是孔子的功绩。诗与乐是联带着的，孔子也特别注重音乐。他自己喜欢弹琴，喜欢鼓瑟，喜欢唱歌。“与人歌而善，必使反之而后和之”，可见他学唱歌是怎样的用心。“在齐闻《韶》三月不知肉味”，可见他对于音乐又是怎样的陶醉。他把音乐不仅视为自我修养和对于门人弟子的情操教育的工具，而且把它的功用扩大起来，成为了治国平天下的要政。这是“与民偕乐”的意思，便是把奴隶时代的贵族们所专擅的东西，要推广开来使人民也能共同享受。这一点不仅表示了这位先驱者充分地了解得艺术价值，而且也显豁地表示了他所代表着的时代精神。不过时代也依然限制了他。他所重视的乐是古代的传统，也就是古乐。他说：“《韶》尽美矣又尽善也，《武》尽美矣未尽善也。”《韶》虽不必是舜乐，《武》也不必作于周武王，但总之都是古乐。当时和这古乐对峙的已经有新音乐起来，便是所谓“郑声”，这新音乐却为他所不喜欢，他斥之为“淫”。郑声和《韶》、《武》，我们都听不见了，无从来加以覆勘，但据我们的历史经验，大凡一种新音乐总比旧音乐的调子高，而且在乐理、乐器、乐技上也照例是进步的，故尔所谓“郑声淫”的“淫”应该是过高的意思，决不是如像《毛毛雨》之类的那种所谓靡靡之音，倒是可以断言的。礼，不用说也是学的极重要的对象。礼，大言之，便是一朝一代的典章制度；小言之，是一族一姓的良风美俗。这是从时代的积累所递传下来的人文进化的轨迹。故有所谓夏礼、殷礼、周礼。但所谓夏礼、殷礼都已文献无征，“无征不信”，故他所重视的是“郁郁乎文哉”的周礼。他特别崇拜周公，以久“不复梦见周公”为他衰老了的征候而叹息。其实乱做梦倒是衰弱的征候，他的晚年之所以“不复梦见周公”，倒足以证明他已经超过了周公的水准了。周公在周初固然是一位杰出的人物，特别在政治上，但所有一切的周礼相传为周公所制作的，事实上多是出于孔子及其门徒们的纂集与假托。禮是后来的字，在金文里面我们偶尔看见有用豐字的，从字的结构上来说，是在一个器皿里面盛两串玉具以奉事于神，《盘庚篇》里面所说的“具乃贝玉”，就是这个意思。大概礼之起起于祀神，故其字后来从示，其后扩展而为对人，更其后扩展而为吉、凶、军、宾、嘉的各种仪制。这都是时代进展的成果。愈望后走，礼制便愈见浩繁，这是人文进化的必然趋势，不是一个人的力量可以把它呼唤得起来，也不是一个人的力量把它叱咤得回去的。周公在周初时曾经有过一段接受殷礼而加以斟酌损益的功劳，那是不可抹杀的事实，但在孔子当时的所谓周礼又已经比周公时代更进步了。虽然或者说为更趋形式化了要妥当一些，但在形式上也总是更加进步了的。田制、器制、军制、官制，一切都在随着时代改变，没有理由能说总合这一切的礼制全是一成不变的东西。孔子在春秋末年强调礼制，可以从两点来批判他，一层在礼的形式中吹进了一番新的精神，二层是把“不下庶人”的东西下到庶人来了，至少在精神方面。“礼云礼云，玉帛云乎哉!乐云乐云，钟鼓云乎哉!”他并没有专重钟鼓玉帛等礼乐之外形。“人而不仁如礼何!人而不仁如乐何！”他是把仁道的新精神灌注在旧形式里面去了。</p>
<blockquote>
<p><strong><font color="#FF7256">礼与其奢也宁俭，丧与其易(治)也宁戚。（《论语·八佾》）</font></strong>  </p>
<p><strong><font color="#FF7256"> 能以礼让为国乎，何有？不能以礼让为国，如礼何？（《论语·里仁》）先进于礼乐，野人也；后进于礼乐，君子也。如用之，则吾从先进。（《论语·先进》）</font></strong> </p>
</blockquote>
<p>这些是表现着他的进步精神。野人就是农夫，他们所行的礼和乐虽然是非常素朴，然而是极端精诚。把精神灌注上去，把形式普及下来，重文兼重质，使得文质彬彬，不野不史(“质胜文则野，文胜质则史”)，那倒是他所怀抱的理想。这应该也就是他的礼乐并重的根据吧。礼偏于文，乐近于质，他把这两者交织起来，以作为人类政治生产的韧带，这层是他的政治哲理的一个特色，我们是不能否认的。“礼乐不兴则刑罚不中，刑罚不中则民无所措手足”，他是把人文主义推重到了极端了。不过就在礼这一方面，时代也依然限制了他。他在形式上特别注重古礼，就和他在乐的方面注重《韶》、《武》而要“放郑声”的一样，有好些当时的世俗新礼，他就看不惯。他主张：“行夏之时，乘殷之辂，服周之冕。”“行夏之时”，在农业生产上大抵有它的必要。“殷辂”是否特别舒服，“周冕”是否特别美观，我们就无从判定了。据我从卜辞里面的发现，知道殷王所乘的猎车是驾两匹马的，比起周人的驷马来怕不怎么舒服吧。关于冕制，似乎他也还能够从权，且看他说：“麻冕礼也，今也纯(丝)，俭，吾从众。”但这“从众”的精神可惜他没有可能贯彻到底。他有时候却又不肯“从众”。“拜下礼也，今拜乎上，泰也，虽违众，吾从下。”这就表示得很鲜明，他一只脚跨在时代的前头，一只脚又是吊在时代的后面的。“拜下”是拜于堂下，受拜者坐于堂上，拜者“入门立中廷北向”而拜，这种仪式，我们在西周的金文里可以找到无数例，这是奴隶制下的礼节。等时代起了变革，阶层上下甚至生出了对流，于是拜者与受拜者便至分庭抗礼，这也正是时代使然。众人都上堂拜，而孔二先生偏要“违众从下”，很明显地是在开倒车。从此可以见得他对于礼，一方面在复古，一方面也在维新。所谓“斟酌损益”的事情无疑是有的，尽管他在说“述而不作”，但如三年之丧便是他所作出来的东西，是不是杰作是另外一个问题，他自己的门徒宰予就已经怀疑过不是杰作了。在主观方面强调学，在客观方面便强调教。教与学本来是士的两翼，他是士的大师当然不能离开学与教。他有有名的庶、富、教的三步骤论，是他到卫国去的时候，冉有替他御车，他在车上看见卫国的老百姓很多，便赞叹了一声：“庶矣哉!”一一人真多呀。冉有就问：“庶了又怎么办?”他答道：“富之!”一一要使他们丰衣足食。冉有又问：“已经丰衣足食了，又怎么办?”他又回答道：“教之”一一好生展开文化方面的工作去教育他们。究竟教些什么呢?可惜他没有说。不过他是承认老百姓该受教的，这和奴隶时代只有贵冑子弟才能有受教育的权利，已经完全不同。他是仁道的宣传者，所学的是那一套，所教的也当然就是那一套。文行忠信是他的四教，他的门徒是分为四科的：德行、言语、政事、文学。四教和四科大概是可以扣合的吧，总不外是诗书礼乐和所以行诗书礼乐的精神条件。他本人确实是一位很好的教育家，他的教育方法并不是机械式的，他能够“因材施教”。他也不分贫富，不择对象，他是“有教无类”。当然，也并不是毫无条件，只要有“十小条干牛肉”(束脩)送去，他就可以教你了一一“自行束脩以上，吾未尝无诲焉。”这也是教书匠的买卖不得不然，假如连“十小条干牛肉”都没有，你叫教书匠靠吃什么过活呢?</p>
<p>为政总要教民，这是一个基本原则。“以不教民战，是谓弃之”，“善人教民七年亦可以即戎”，“举善而教不能，则劝”。这和后起的道家法家的愚民政策是根本不同的，这点我们应该要把握着。因而“民可使由之，不可使知之”的那两句话，近人多引为孔子主张愚民政策的证据的，却是值得商讨了。一个人的思想言论本来是有发展性的，不得其晚年定论，无从判断一个人的思想上的归宿。周、秦诸子的书中都有时常自相矛盾的地方，我们苦于无法知道那些言论之孰先孰后。孔子是号为“圣之时”的，是能因时而变的人。庄子也说过：“孔子行年六十而六十化，始时所是，卒而非之，未知今之所谓是之非五十九年非也”（《寓言》）。他的晚年定论我们实在也无从知道。《论语》这部书是孔门二三流弟子或再传弟子的纂辑，发言的先后次第尤其混淆了，不能不说是一件遗憾。但要说“民可使由之，不可使知之”为愚民政策，不仅和他“教民”的基本原则不符，而在文字本身的解释上也是有问题的。“可”和“不可”本有两重意义，一是应该不应该；二是能够不能够。假如原意是应该不应该，那便是愚民政策。假如仅是能够不能够，那只是一个事实问题。人民在奴隶制时代没有受教育的机会，故对于普通的事都只能照样做而不能明其所以然，高级的事理自不用说了。原语的涵义，无疑是指后者，也就是“百姓日用而不知”的意思。旧时的注家也多采取这种解释。这是比较妥当的。孟子有几句话也恰好是这两句话的解释：“行之而不著焉，习矣而不察焉，终身由之而不知其道者众也。”（《孟子·尽心上》）就因为有这样的事实，故对于人民便发生出两种政治态度：一种是以不能知为正好，便是闭塞民智，另一种是要使他们能够知才行，便是开发民智。孔子的态度无疑是属于后者。孔子在大体上是一位注重实际的主张人文主义的人，他不大驰骋幻想，凡事想脚踏实地去做。他生在那么变化剧烈的时代，旧名与新实不符，新名亦未能建立，故他对于路问政主张先要“正名”，谓：“名不正则言不顺，言不顺则事不成，事不成则礼乐不兴，礼乐不兴则刑罚不中，刑罚不中则民无所措手足。”所正的“名”既与“言”为类，正是后起的名辩之名，而不限于所谓名分。故“正名”也就如我们现在小之要厘定学名译名，大之要统一语言文字或企图拼音化那样，在一个社会制度大变革的时代的确是很重要的事，可惜他的关于如何去“正名”的步骤却丝毫也没有留下。他生在大变革的时代，国内国外兼并无常，争乱时有，故尔他回答子贡问政，便主张“足食足兵”；他并不是空口讲礼乐的空想家，而在礼成乐作之前是要有一番基本工作的。“如有王者，必世而后仁，”要三十年之后才有仁政出现，则三十年间的基本工作，照逻辑上说来，也尽不妨有些地方类似乎不仁。“善人为邦百年，亦可以胜残去杀，”他誉为“诚哉是言”，不知道是他的前辈的那一位所说的话，这仁政成功的期间可说得更久远，要费三个三十年代上了。这些年限并不一定有数学般的准确，但足以证明他并不是不顾实际的绥靖主义者。尽管他在说“道(导)之以德，齐之以礼，有耻且格”，但也没有忘记“道之以政，齐之以刑，民免(勉)而无耻(没有可耻的事)”的。他的从政者的步骤，有“尊五美，屏四恶”的信条。五美中的一美“因民之所利而利之”是最值得重视的。四恶的“不教而杀谓之虐，不戒视成谓之暴，慢令致期谓之贼，犹之与人也，出纳之吝，谓之有司”(有司二字疑有误)，也的确都是值得屏弃的恶政。因之它们的反面便是要先教先戒，信守法令，惠与不吝了。该给人民的，不能不给人民，只要是为人民谋幸福的，不能吝啬而不与。虽然也主张“节用”，“道(导)千乘之国，敬事而信，节用而爱人，使民以时”，但这节用是有条件的，便是以爱人为条件。这只是在消极方面限制为政者的奢侈，而非节省必要的政治施设使人民不得康乐。故“有国有家者不患寡而患不均，不患贫而患不安”。不过在实际上他是患贫也患不安，患寡也患不均的，看他积极地主张“庶矣……富之，富矣……教之”，而强调“足食足兵，民信之矣”，也就可以明了了。离开实际的政治之外，还有一种理论的主张，便是“祖述尧、舜”。尧、舜的存在，除掉《尚书》里面所谓《虞书》、《夏书》之外，是很渺茫的。在可靠的殷、周文献里面没有提到他们，在甲骨文和金文里面也没有提到。甲骨文里面有“高祖夔”，经王国维考证，认为是殷人的祖先帝喾，但从《山海经》、《国语》等所保存的神话传说上看来，帝喾和帝舜并不是两人，而且他们都是神。孔子是特别称道尧、舜的，但孔门之外，如墨家、法家、道家、阴阳家，甚至如南方的《楚辞》都一样称道尧、舜，虽然批判的态度不尽相同。尧、舜的故事很显然是古代的神话，是先民口传的真正的传说，在春秋时被著诸竹帛，因而也就逐渐被信史化了。孔子的称道尧、舜，单就《论语》来说，有下列数项：</p>
<blockquote>
<p><strong><font color="#FF7256">大哉尧之为君也，巍巍乎唯天为大，唯尧则之。荡荡乎，民无能名焉。巍巍乎其有成功也，焕乎其有文章。(《泰伯》)</font></strong>  </p>
<p><strong><font color="#FF7256">巍巍乎，舜、禹之有天下而不与焉。同上无为而治者其舜也与?夫何为哉?恭己正南面而已矣。(《卫灵公》)</font></strong>  </p>
</blockquote>
<p>虽然很简单，但毫无疑问是把禅让传说包含着的。他之所以称道尧、舜，事实上也就是讴歌禅让，讴歌选贤与能了。尧、舜禅让虽是传说，但也有确实的史影，那就是原始公社时的族长传承的反映。《礼运篇》称之为“天下为公”的时代，充分地把这个阶段乌托邦化了，因而成为中国历史上的黄金时期。这动机，是值得我们讨论的。明显的是对于奴隶制时代的君主继承权，即父子相承的家天下制，表示不满，故生出了对于古代原始公社的憧憬，作为理想。假使能够办得到，最好是恢复古代的禅让，让贤者与能者来处理天下的事情。假使办不到，那么退一步，也要如“舜、禹之有天下而不与焉”，“恭己正南面”，做天子的人不要管事，让贤者能者来管事。这动机，在当时是有充分的进步性的，无疑，孔子便是他的发动者。认清了孔子的讴歌禅让，也才能够正视他的“君君、臣臣、父父、子子”的那个提示。那是说君要如尧、舜那样的君，臣要如舜、禹那样的臣，父也要如尧、舜那样的父(不以天下传子)，子也要如舜、禹那样的子(“幹父之蛊”)。齐景公不懂得他的深意，照着传统的奴隶社会的观念讲下去，便为：“信如君不君，臣不臣，父不父，子不子，虽有粟吾得而食诸?”只顾到自己要饭吃，没有顾到老百姓也要吃饭，但这责任不能归孔子来负。孔子倒是否认地上的王权的。这与其说是他的特出的主张，无宁是社会的如实的反映。当时的王权事实上是式微了，就是各国的诸侯事实上已多为卿大夫所挟制，而卿大夫又逐渐为陪臣所凌驾，大奴隶主时代的权威已经是被社会否认了。孔子想制作一个“东周”，并不是想把西周整个复兴，而是想实现他的乌托邦一一唐、虞盛世。地上的王权既被否认，天上的神权当然也被否认。中国自奴隶社会成立以来，地上王的影子投射到天上，成为唯一神的上帝，率领百神群鬼，统治着全宇宙。但到西周末年，随着奴隶制的动摇，上帝也就动摇了起来。《诗经》中没落贵族们埋怨上帝的诗不计其数。春秋年间，王者既有若无，实若虚，上帝也是有若无，实若虚的。妖由人兴，卜筮不灵了。一般执政者对于上帝，是在习惯上奉行故事地承认着，而内心的认识可用于产的一句话来统括，便是：“天道远，人道迩，非所及也。”天尽他去天吧，我却要尽我的人事。孔子对于天的看法反映了这种社会的动态。无疑地，他是把天或上帝否认了的，只看他说“天何言哉?四时行焉，百物生焉，天何言哉?”他所称道的天已和有意想行识的人格神上帝完全不同。故在他心目中的天只是一种自然或自然界中流行着的理法。有的朋友认为这种看法太看深了，那么我们请从反对学派的批评来看，便可以知道实在一点也不深。墨子所批评的“儒之道足以丧天下者四政”，第一政是：“儒以天为不明，以鬼为不神，天鬼不说。”这所说的不正是孔子的态度吗?</p>
<blockquote>
<p><strong><font color="#FF7256">子不语怪力乱神。（《论语·述而》）子路问事鬼神，子曰：“未能事人，焉能事鬼?”“敢问死。”曰：“未知生，焉知死?”（《论语·先进》）</font></strong>   </p>
</blockquote>
<p>但无论怎么说，至少孔子总得是一位怀疑派。不幸他的实际家或政治家的趣味太浓厚，尽管否认或怀疑鬼神，而他在形式上依然是敬远着它们。这是他的所谓智者的办法，“敬鬼神而远之，可谓知(智)矣。”但所谓“知”无疑并不是纯粹的理智，而是世俗的聪明。实际上比孔子更深的已经有老聃存在。他不仅否认了上帝，并建立了一种本体说来代替了上帝。他是孔子的先辈，而臣曾经做过孔子的先生。这是先秦诸子所一致承认着的。孔子自己也说“窃比于我老彭”，老就是老聃了。有的朋友因《道德经》晚出，遂并怀疑老聃的存在，或以为由思想发展的程序上看来，老聃的本体说是不应该发生在孔子之先。这些都仅是形式逻辑的推论而已。在春秋时代普遍地对于上帝怀疑，而在纷争兼并之中又屡有“一匡天下”的那种希望，正是产生老子本体说的绝好的园地。只是他的学说没有群众基础，不仅没有宰制到思想界，就连孔子也没有怎么接受它而已。老子的学说经过间歇之后，直到环渊、庄周又才得到充分的发展，并不是不可能的事。何况庄周之前还是宋■、彭蒙、彭蒙之师，以及杨朱等人存在呢?</p>
<p>孔子既否认鬼神，但有一个类似矛盾的现象，他却承认“命”。他把命强调得相当厉害，差不多和他所主张的仁，站在同等的地位。“子罕言利，与命与仁”一一他很少谈利，但称道命，称道仁。他既说“仁者不忧”，又说“知命不忧”。既说“君子无终食之间违仁”，又说“不知命无以为君子”。命与仁在他的思想中俨然有同等的斤两。命又称为天命。“君子有三畏：畏天命，畏大人，畏圣人之言”。他自己是“五十而知天命”。看来很像是一片神秘的宿命论(fatalism)。但问题是他所说的命究竟是什么。他既否认或怀疑人格神的存在，那么他所说的命不能被解释为神定的运命。他的行为是“学而不厌，诲人不倦”，“发愤忘食，乐以忘忧，不知老之将至”的；为政的理想是“先之劳之”而益以“无倦”；一切都是主张身体力行，颇有积极进取的精神，也不像一位宿命论者。故我们对于他所说的命不能解释为神所预定的宿命，而应该是自然界中的一种必然性。这种必然性有点类似于前定，是人力所无可如何的，故他说：“道之将行也与。命也；道之将废也与，命也。公伯寮其如命何?”而对于这种必然性的制御，则是尽其在我，子夏所转述的这几句话：“死生有命，富贵在天；君子敬而无失，与人恭而有礼；四海之内皆兄弟也”，也就是这个意思。不因为人必有死而贪生怕死，也不因为富贵可羡慕而妄求富贵，故敬以自处，恭以待人，爱人如弟兄骨肉，尽其在我，听其自然。《庄子?秋水篇》引孔子语：“知穷之有命，知通之有时，临大难而不惧者，圣人之勇也”。这或许是假托，但假托得恰合乎孔子的真意。这便是孔子的天命观，分明是一种必然论(necessitarianism)，和宿命论是有区别的。在孔子的整个思想体系上我们可以看出，他在主观的努力上是抱定一个仁，而在客观的世运中是认定一个命。在主观的努力与客观的世运相调适的时候，他是主张顺应的。在主观的努力与客观的世运不相调适的时候，他是主张固守自己的。</p>
<p>笃信好学，守死善道。（《论语·泰伯》）<br>志士仁人无求生以害仁，有杀身以成仁。（《论语·卫灵公》）<br>不义而富且贵，于我如浮云。（《论语·述而》）<br>君子义以为质，礼以行之，逊以出之，信以成之。(《论语·卫灵公》)<br>自古皆有死，民无信不立。（《论语·颜渊》）</p>
<p>他并不是低头于命定的妥协者，看这些辞句也就可以明了了。他只差这一点没有说明，便是一切都在变，命也在变；人的努力可以扬弃旧命而宰制新命。奴隶制时代的汤武能革命，使奴隶制崩溃了的人民也正在革命。孔子是生在这种革命潮流中的人，事实上他也正在参加着新必然性的控制的。他说他“五十而知天命”，或者也就是说他探索了五十年，到这时才自觉到了自然的趋势所赋与他的新使命的吧。</p>
<p>三 、墨子的思想体系墨子在孔子稍后，作为反对命题而出现。他们在基本立场上就有不同，因而在思想上也差不多立在完全相反的地位。孔子否认传统的鬼神，而墨子则坚决地肯定传统的鬼神，这神有意志，有作为，主宰着自然界和人事界的一切。我有天志，譬若轮人之有规，匠人之有矩。轮匠执其规矩以度天下之方圆，曰：中者是也，不中者非也。今天下士君子之书不可胜载，言语不可尽计，上说诸侯，下说列士，其于仁义则大相远也。何以知之?曰：我得天下之明法以度之。（《天志上》）他的“天志”，即天老爷之意志，也就是“天下之明法”，是他的规矩。这正是墨子思想的一条脊梁，也就如没有规矩不能成其为轮匠的一样，抽掉了这条脊梁，墨子便不能成其为墨子。天老爷的存在是地上王的投影。大奴隶主成为地上的统制者，发挥着无上的王权，他为巩固这王权，使它成为“它布”，让人不敢侵犯，除掉有形的赏罚以支配人的肉体之外，还要造出无形的赏罚来支配人的精神。因而利用人民的愚昧，便把由奴隶造成的人世的金字塔，化而成为由神鬼造成的天界的金字塔。人王之下有百官众庶，上帝之下有百神群鬼。于是明则有斧钺，幽则有鬼神，王权便得到了双重的保障。墨子在王权式微了的时代又来提倡“天志”，他这种态度无论怎样替他辩护，都不好说他不是在复古，而是在革新的。有的朋友说：“降至战国时代七雄并峙，天子已降为诸侯之附庸，因而在诸侯的心目中早已没有天或上帝了。但是在这一时代的农民，他们却幻想有一个最高的权力，来制裁这些无法无天的诸侯，于是出现了墨翟的天志。”这说法自然是有理由的，因为在古时，无论中国或外国，凡是代表农民利益的革命运动，每每假借宗教的力量以为号召，但这情形于墨子的场合不能适用。墨子的立场并不代表农民利益，而当时的农民倒比较欢迎当时“无法无天的诸侯”，甚至乱臣贼子的。“共伯和修其行，好贤仁，而海内皆以来为稽矣；周厉之难，天子旷绝，而天下皆来谓矣”（《吕氏·开春论》）。“妪乎采芑，归乎田成子”（《史记·田敬仲完世家》）。这些是历史上所告诉我们的实际情形。就在秦灭六国之后，六国的遗民都在思念他们的旧主，所以陈涉发难，六国王室的后裔便都一时纷纷复原了。陈涉不立楚后而自立受了批评，项梁立楚怀王孙心乃“从民所望”。这些所表示的是什么呢?便是当时的农民对于那些“无法无天的诸侯”倒并不是怎么怀恨的。何以会这样?理由却甚简单，便是因为人民从奴隶的命运解放出来还不很久的原故。有的朋友又说：墨子的天道观是很平等的，证据是《法仪篇》的“天下无大小国，皆天之邑也；人无幼长贵贱，皆天之臣也”，意思就是说，万人在天底下都是平等。这也是认识不足。《法仪篇》的那两句话就是“普天之下，莫非王土，率土之滨，莫非王臣”的扩大。假使前者是一种天道平等观，那么后者便是一种王道平等观。岂不是奴隶制度也可以说是平等的制度了吗?据我所见，那两句话其实正表示其大不平等。因为“邑”有大小的区别，“臣”有贵贱的等差一一至少古时是有十等的。假使我们拿“四海之内皆兄弟也”和“王司敬民，罔非天胤”的话和这比较起来，那就相差得天远。一边是王和老百姓都是天的儿子，故尔是兄弟行，一边是金字塔式的君臣主奴的关系，我们请以公平的态度来批判，到底那一边要较为平等呢?</p>
<p>这位朋友又说：“明鬼”也有平等的意思在里面，因为在墨子以前只认为王公大人死了才能为鬼，贱民死了是不得为鬼的。何以见得呢?他引用了《左传》昭七年“郑人相惊以伯有”的那段故事。子产说伯有取精用弘，族大凭厚，故强化为鬼。据此认为古代贱民没有做鬼的资格，是墨子提升了他们，使他们也能做鬼了，所以“明鬼”也是一种平等的主张。这见解倒十分新鲜，但是可惜完全是“自我作古”。古者人死为鬼，是自有文字以来的通例。鬼的字形就像一个大头人，表示着尸体浮肿的阶段而已。国君有牛享，大夫有羊馈，士有豚犬之奠；庶人有鱼炙之荐。笾豆脯醢则上下共之。（《楚语》引《祭典》）庶人如没有鬼，何用此“鱼炙之荐”和“笾豆脯醢”呢?</p>
<blockquote>
<p><strong><font color="#FF7256">大凡生于天地之间者皆曰命，其万物死皆曰折，人死曰鬼。此五代(唐、虞、夏、商、周)之所不变也。……庶士庶人无庙，死曰鬼。(《礼记·祭法》)</font></strong></p>
</blockquote>
<p>据这些看来，可见庶人死为鬼，是自古以来如此看法，那里会是墨子的新发明呢?事实上就是子产评伯有的那一段话里面，他已经明明说着：“匹夫匹妇强死，其魂魄犹能凭依于人，以为淫厉”，淫厉就是恶鬼，他何尝说庶人死了就没有资格做鬼呢?鬼世界和人世界是一实一虚，一形一影。人世界中既有庶人奴隶，岂能鬼世界中没有庶鬼奴隶?鬼也有等级倒是实在的。贵族在生前统治着世界，死后也统治着世界；庶人在生前事奉着贵族，死后也事奉着贵族。故庶人鬼没有贵族鬼那样的灵威赫赫，倒是实在的。假使说庶人没有资格做神，那就正确了。《墨子·明鬼篇》里面所举的一些鬼话，都只是一些贵族鬼，即所谓神，庶人倒真正没有资格做的。又有人说：墨子的信仰鬼神，多少是出于利用，所谓“神道设教”。因为《明鬼篇》里面这样说过：“今洁为酒醴粢盛以敬慎祭祀……虽使鬼神请(诚)亡(无)此犹可以合灌（马旁）聚众，取亲于乡里”，是的，这倒比前两说合理一些。但我们须得知道，这只是辩论时使用的所谓援推术而已。你认为鬼神是没有吗?好吧，就作为没有吧，而尊天明鬼却依然有它的妙处。这意思并不是承认了鬼神真正无，而只是加强了尊天明鬼有两倍的好。自然，在墨家本身也是有变化和发展的(这种看法正是我们新史学的原则)，等到墨家后学讲求名辩的时候，他们便差不多根本不谈鬼神了。这是他们的进步，然而在墨子本人却不能适用。墨子他是一位虔诚的信仰者，看他翻三覆四地证明鬼神之有，又翻三覆四地斥责主张无神无鬼论者之妄，也就尽足以证明他的诚意了。不错，老百姓是相信有鬼神的，那是因为受教育的机会被人剥夺了的原故。假使因为他们相信而再要站在“王公大人”的立场来存心利用，那正是愚民政策。“无法无天的贵族们”早就知道那一套是骗局，被你骇不倒，而老百姓们倒会被你骇得更加贴服了。为什么呢?顶可怕的是贵族鬼而不是庶人鬼呀。所以宗教，结果是奉事统治者的东西，要说墨子是存心利用，我看那倒是有点冤枉墨子了。在我的鄙见，问题不想那样去提出。我是感觉着中国有这样一位标准的教主人格，为什么没有产生出一个固有的宗教?世界上的几个大宗教差不多都发生在距今二千年前上下。墨子生在二干四五百年前，以他的精神和主张尽可以成立一个中国独特的宗教，而在战国年间的墨家学派也的确有过这样的趋势的，如等于教主的所谓“巨子”之衣钵传授即其一例。然而结果没有形成，后来反让儒家和道家来夺了他的席，而儒也并不成其为宗教，道也仅是印度教的拙劣的翻版。这在研究中国古代史上倒确实可成为一个问题。为什么在奴隶制解体以后中国不能产生一个独自的宗教呢?在这儿我的看法是，中国的地理条件有很大的关系。各个世界大宗教都产生在热带国家。那些地方的贵族们一样受着自然界的压迫，故尔容易在幻想中去讨生活，在生前想求得一种法悦以忘却现世的辛苦；在死后自己升上天堂，把敌对者打进地狱里去。中国是温带国家，天堂何如现世的宫殿?地狱何如现世的监牢?故尔中国贵族最质实，无须乎再有升天入地的必要了。因此中国的统治者早就知道欢迎比较更现实的统治工具，而冷落了那种虚无缥缈的东西。这，怕就是固有宗教虽是具体而微，而终竟未能完成的根本原因吧?</p>
<p>世界是一元的，阴阳只隔一张玻璃纸。人世界即鬼世界，鬼世界即人世界。既承认鬼世界的神鬼的权威，当然早就在承认着人世界的“王公大人”的权威。既在尊天明鬼，当然也早就得尚同尚贤。尚同与尊天相应，尚贤与明鬼相应。天之下有群鬼百神，王之下有群贤百辟，都是两两相应的。尊天既是绝对的神权统治，尚同便是绝对的王权统治。王权为天所授与。“一同天下之义。”“上之所是，亦必是之，上之所非，亦必非之。”“上同而不下比”（《尚同》）。以王的意志统一天下的意志，以王的是非统一天下的是非。当然王之上也还有天，王也得上同于天。但，天是什么呢?天不过是王的影子。故结果是王的意志就是天的意志，王的是非就是天的是非。而反过来，所谓“天志”实在也不过就是王志了。当然王也须得为义，不为不义，这是是非善恶的标准。但这义不义的标准又从什么地方出来的呢?“义不从愚且贱者出，必自贵且知者出”（《天志中》）。是故“自贵且智者为政乎愚且贱者则治，自愚且贱者为政乎贵且智者则乱”（《尚贤中》）。“然则孰为贵?孰为智?曰天为贵，天为智而矣”（《天志中》）。天又是什么呢?真是天晓得，还不是就是王者的特写吗?所以说来说去，仍不外是以一人的意志为天下人的意志，以一人的是非为天下人的是非。这一人假使是绝顶的天才或者没有问题，然而天地间那有这样绝顶的天才呢?有这样绝顶的天才，又能世世代代相继续的吗?</p>
<p>王者是绝对不能虚位的，必须力疾躬行。为了一同天下之视听尤须奖励告密与厉行连坐，“见淫僻不以告者，其罪亦犹淫僻者”（《尚同下》）。使“天下之人皆恐惧振动惕慄，不敢为淫暴。日天子之视听也神”（《尚同中》）。“淫僻”或“淫暴”翻译成现代语就是过激。墨子是最恨“寇乱盗贼”的人，他的书中返之复之地屡以盗贼为戒。这倒是时代的反映。因为土地财产私有权既经法定成立，则私有权的保卫便不能不强调。在墨子时代还仅是“天下之为寇乱盗贼者，周流天下无所重足”（《尚同下》），而到墨家后学竟发展到“杀盗非杀人”（《小取》）的地步了。故尔他替“王公大人”所设想的，就是在怎样“主社稷，治国家，欲修保而勿失”（《尚贤中》），“传以遗后世子孙”（《尚贤下》），“业万世”（《天志上》）。社稷是王的社稷，国家是王的国家，人民是王的人民。“士君子”之流便拥戴着王的权威，保卫着王的私产。在这样的情形之下当然不许有一人敢为“淫僻”或“淫暴”，敢为“寇乱盗贼”。而能够替王保卫私产，遏制“淫暴”，消弭“寇乱盗贼”的人也就是所谓“贤”了。这样的“贤”不用说比那些“骨肉之亲，无故富贵，面目美好者”还要值得贵重。“虽在农与工肆之人，有能则举之，高于之爵，重予之禄，任之以事，断予之令”（《尚贤上》），使老百姓们尊敬他，信仰他，害怕他。这倒也是奴隶解放时的一部分实际情形。“官无常贵，而民无终贱”，这两句话每被人引用来证明墨子主张的革命性，然而实际是社会现实的反映而已。而墨子却把这个现实引向“王公大人”本位上去了。在墨子思想中最为特色而起着核心作用的要算是他的“兼爱”与“非攻”的一组。这两种主张其实只是一个提示的正反两面：“兼爱”是由积极方面来说，“非攻”是由消极方面来说。这无疑也是时代精神的反映。但尽管同样在说爱，同样在说爱人，而墨子的重心却不在人而在财产。墨子是把财产私有权特别神圣视的。人民，在他的观念中，依然是旧时代的奴隶，所有物，也就是一种财产。故他的劝人爱人，实等于劝人之爱牛马。请看他说吧：盗爱其室不爱异室，故窃异室以利其室。贼爱其身不爱人身，故贼人身以利其身。大夫各爱其家不爱异家，故乱异家以利其家。诸侯各爱其国不爱异国，故攻异国以利其国。（《兼爱上》）这就是说：你不尊重我的所有权，我不尊重你的所有权，结果是互为盗贼，互相攻乱；你也侵犯我的所有权，我也侵犯你的所有权。要怎样来救止这种弊病呢?要“兼相爱，交相利”。这也就是说：你尊重我的所有权，我也尊重你的所有权；彼此互相尊重，于是也就互相得到好处。故所以说：</p>
<blockquote>
<p><strong><font color="#FF7256">视人室若其室，谁窃?</font></strong><br><strong><font color="#FF7256">视人身若其身，谁贼?</font></strong><br><strong><font color="#FF7256">视人家若其家，谁乱?</font></strong><br><strong><font color="#FF7256">视人国若其国，谁攻?（《兼爱上》）</font></strong></p>
</blockquote>
<p>兼爱的结果便不会攻乱贼窃，不兼爱呢便会有攻乱贼窃；反对攻乱贼窃便是反对不兼爱，故尔“非攻”只是“兼爱”的另一种说法而已。因而在本质上，“非攻”也依然是对于所有权的尊重。翻译成适当的口语，也就是反对侵犯所有权。且看原文吧。今有一人，入人园圃，窃其桃李，众闻则非之，上为政者得则罚之。此何也?以亏人自利也。至攘人犬豕鸡豚者，其不义又甚入人园圃窃桃李。是何故也?以亏人愈多，其不仁滋甚，罪益厚。至入人栏厩，取人马牛者，其不仁义又甚攘人犬豕鸡豚。此何故也?以其亏人愈多。苟亏人愈多，其不仁滋甚，罪益厚。至杀不辜人也，拖其衣裘，取戈剑者，其不义又甚入人栏厩，取人牛马。此何故也?以其亏人愈多。苟亏人愈多，其不仁滋甚矣，罪益厚。（《非攻上》）就这样逐渐把范围扩大下去，说到攻人之国为大不义。故“攻伐无罪之国，入其国家边境，芟刈其禾稼，斩其树木，堕其城郭，以湮其沟池，攘杀其牲栓，燔溃其祖庙，劲杀其万民，覆其老弱，迁其重器”（《非攻下》），这比杀人越货是更加不义了。“劲杀其万民”与“攘杀其牲栓”并列，而与“攘人犬豕鸡豚者”，“取人牛马者”同等，故人民依然还是所有物；而攻人之国实等于侵犯最大的私有权而已。这就是兼爱与非攻说的核心，尊重私有财产权并保卫私有财产权。故他这一套学说并不重在爱人，而是重在利己，不是由人道主义的演绎，而是向法治刑政的归纳。他之主张告密连坐（《尚同》中及下），“劝之以赏誉，威之以刑罚”（《兼爱下》）或“富贵以道(导)其前，明罚以率其后”（《尚同下》）的办法，后来为商鞅、申不害、韩非之流的法家所极端扩大了，那并不是没有理由的。攻是侵犯私有权，非攻是反对侵犯私有权，因而非攻本身就是战争。道家早就揭穿了这一层，认为“为义偃兵，造兵之本”（《庄子·徐无鬼》），而墨家自己也赞奖周武王之伐殷纣，认为是“诛”，与攻不同。这也就是儒家所说的义战与非义战的区别了。我曾说“他的非攻其实就是美攻”；朋友们多说我故为“偏恶之辞”，其实我倒是尽了客观研讨的能事的。既普遍承认私有权的神圣，因而他的主张结果是对于私有权大者帮了大忙，这是逻辑的必然。我曾说“他的兼爱其实是偏爱”，朋友们多说我故为“偏恶之辞”，其实我倒是尽了客观研讨的能事的。在由奴隶制转移为封建制的过渡时期，私有财产权还未十分稳固，要建立一种学说体系来使它神圣化，倒确实不好轻率地谥为“反动”一一在这一部分我可以取消我的这个判断。但要说墨子是奴隶解放者，是农工革命的前驱，是古代的布尔什维克，虽然明显地不是出于“偏恶”，然而只是把黑脸张飞涂成了红脸关羽。不仅依然在涂着脸谱，而且涂错了脸谱。“节用”与“节葬”是一套消极的经济政策，这和老百姓的生活并没有直接的关系。因为老百姓的用是节无可节，葬也是节无可节的。他的整套学说都是以“王公大人”为对象的，“王公大人”的不合理的消费如果节省一些，当然也可以节省一些民力。从这么一点间接的恩惠说来，墨子倒可算在替人民设想了。大家也就抓紧了这一点，认为墨子是人民的朋友。譬如《节用》中篇所反复着的一句话，“诸加费而不加民利者圣王弗为”，好些朋友认为这就是墨子事事为“民利”着想的证据。但我却丝毫也不能够在这句话里面找到满足。一国的政治如果真是为“民利”设想的话，你只愁用费不够。那里会有什么浪费的忧虞?他之所以忧虑浪费者，只是为的王利而不是“民利”，如何在老百姓身上多用一点，他从不曾这样想过。他只是把人民的生活限在极苟简的阶段，一切器用“足以奉给民用则止”，只求他们冻不死，饿不死。假使王者不节约，把老百姓榨取到冻死饿死的程度，那怎么办?这就是他所担心的。你以为他真在替人民设想吗?但这，我也并不想专怪他，因为这限度要想打破，历史还须得再推进两千多年。但我们如果不认定这个限度而要说墨子是“最民主”，是“布尔什维克”，那却是中饱了二千多年的历史。当时的生产情形，在墨子的眼中看来，是人民少而土地多，因而生产力不足，生产不敷消费。请看他说吧：</p>
<blockquote>
<p><strong><font color="#FF7256">今万乘之国，虚(墟)数于千，不胜而人，广衍数于万，不胜而辟；然则土地者所有余也，士民者所不足也。（《非攻中》）</font></strong></p>
</blockquote>
<p>荒地以千计，没有那么多的人来住；平地以万计，没有那么多的人来开垦。土地有余而人民不足。故尔拿人民去打仗，去“争虚城”，在他看来是“弃所不足而重所有余”。因此他的节用，是把人民当作生产工具而包括在里面的，不仅要节省民力，而且还得倍加人口的生产。于是他便想出了早婚的方法，要用国家的法令来限定早婚。“丈夫年二十毋敢不处家，女子年十五毋敢不事人”（《节用上》），我们不要看忽略了那“毋敢不”三个字。战争除劳民伤财而外，还使“男女久不相见”，久丧也因“败男女之交多”，故都在所反对之列。看来蕃殖人口倒确是墨子的一项积极的经济政策。人民既是“王公大人”的私有，使人民蕃殖，也不过如使牛马蕃息一样，尽管“女子十五”便要“事人”，未免有点不入道，他也顾不了那么多了。有的朋友说：这比三年之丧禁止男女三年不交接的似乎还要“人道”一些。这倒也想得周到。但我并没有意思替三年之丧辩护，我也并不是什么新儒家，谁人道谁不人道，倒不是争门户的事情。不过公平一点说，人道不人道的标准是应该拿利己与利人及自愿与非自愿来判定的。我们请从这一方面来考虑一下吧。“节用”与“节葬”的另一个目的，是在反对儒家的礼。“节葬”是反对丧礼，尤其三年之丧，固不用说；“节用”反对其它的礼，所谓“侥仰周旋威仪之礼，圣王弗为”（《节用中》）。本来对于形式上的繁文缛礼，孔子也是反对的，所谓“礼与其奢也宁俭，丧与其易(治)也宁戚”，和墨子的节用节葬似乎也没有什么不同。只是孔子的出发点是心理的安不安，而墨子却是经济的利不利。就拿三年之丧来说吧，当宰予反对的时候，孔子也只说：“于汝安乎，汝安则为之。”由这一点上要说孔子是唯心，墨子是唯物，是毫无问题的。只是墨子这位大师似乎是一位爱走极端的天才，他在生活上和言论上都爱走极端，有时候每每自相矛盾。例如他的“节葬”和“明鬼”冲突，东汉末年的王充已经指摘过，而他的“节用”和“尚贤”也是冲突的。《尚贤》里面讲王天下正诸侯者必须置三本。所谓三本是：“高予之爵，重予之禄，任之以事，断予之令。”他在那儿晓得说：“爵位不高则民不敬也，蓄禄不厚则民不信也，政令不断则民不畏也”（《尚贤中》）。但他说到节用节葬上来，却要采取平均主义，瘠觳到万分，不仅是于事行不通，而且是于理也说不通的。大约因为是出于反对命题，故每每不惜过甚其辞，矫情立异的吧。他是同情公室而反对私门的人。他站在同情公室的立场上，所见到的只是腐败了的奴隶生产，因而看不出人民生产力的伟大。他对于人类的前途是悲观的，因而他反对周家的文，而要返回夏家或其以前的质。他只能在节省和蕃殖人口或防止人或减少上着想；怎样去开发民智，怎样去改良生产工具，怎样使人民娱乐以增加其生产效率，他不唯不肯去用心，而且反对向这些方面去用心。事实上他是在开倒车，因而我说他“反动”，倒并不限于他迷信鬼神的那一点。我们再请看他的“非乐”和“非命”理论吧。“非乐”不仅在反对音乐，完全在反对艺术，反对文化。他说：“仁者之为天下度也，非为其目之所善，耳之所乐，口之所甘，身体之所安。以此亏夺民衣食之财，仁者弗为也”（《非乐上》）。这是对的。但如果是谋人民的目之所美，人民的耳之所乐，人民的口之所甘，人民的身体之所安，这不仅不会“亏夺民衣食之财”，而且可以增加其衣食之源，何尝便可以一概反对？但墨子是一概反对了。虽然他也在说“下度之，不中万民之利”，事实上他并不是站在万民的立场以度其利，而是站在“王公大人”的立场以度其利。那样从楼上滴点眼药下来的方法，只是让老百姓有碗饭吃，有件衣穿，便是在大德大利了。“与民同乐”的观念，在墨子的思想中是毛根也没有的。所谓“与君子听之，废君子听治；与贱人听之，废贱人之从事”；结果只剩下一群牛马和一条鞭子。贱人是管耕稼树艺，纺绩织纴的；君子是“内治官府，外收敛关市山林梁之利以实仓廪府库”的，一句话归总，便是榨取老百姓的。“君子不强听治，即行政乱；贱人不强从事，即财用不足。”刑政在管贱人，财用在养君子，故“非乐”的高论只是在更多多榨取老百姓而已。“中万民之利”吗?真是天晓得呀！关于“非乐”，墨儒之间有一段小小的议论，甚为学者所称道。子墨子问于儒者曰：“何故为乐?”曰：“乐以为乐也。”子墨子曰：“子未我应也。今我问曰：何故为室?曰：冬避寒焉，夏避暑焉，且以为男女之别也，则子告我为室之故矣。今我问曰：何故为乐?曰：乐以为乐也，是犹曰何故为室，曰室以为室也。”（《公孟篇》）首先是胡适根据这个故事认为墨子是很科学的，对于事物要追求根源，问他一个为什么。不错，墨子似乎很有这样的精神，不过在这个缺席裁判的故事里面，他或他的后学却不免有点上下其手。“乐以为乐也”是说音乐为的是凰快乐，正说出了它的为什么来。墨子故意把音乐与快乐混为一谈。而反诘以“室以为室”，那无宁是诡辩。这是因为中国字有毛病，古时音乐的“乐”与快乐的“乐”，连发音都相同。这样的情形就在《墨子》的《经说上》里面也正有同样的一例，便是“知也者所以知也而［不］必知”，我们可以了解第一个“知”字是智字，但如也要弄点诡辩的话，岂不也是“室也者所以室也而［不］必室”吗?<br>儒家谈音乐倒并不那么幼稚，孔子本人虽没有留下什么高深的音乐理论，但到他的弟子或再传弟子，公孙尼子，他的《乐记》一篇便把乐的功用发挥得很为详尽的。我有一篇《公孙尼子与其音乐理论》一文可以参考，在这儿不必赘述。中国古代的学问，认真够得上称为有点科学性质的，只有音乐的乐律和历法。这两种东西儒家都看得很重。在墨子方面呢?历法不曾提到，而庄子说他“不晖于数度”（《天下》）。音乐则极端反对。我们就单以这项为标准，要说墨子是“一位科学家”，至少在我个人是不能不踌躇的。墨子的所谓三表法，朋友们也大多认为是墨子的很有光辉的逻辑。这三表法叙述在《非命篇》里面，上中下三篇的字面略有不同，我现在一并把它们抄在下边。</p>
<blockquote>
<p><strong><font color="#FF7256">《上篇》言必有三表。何谓三表?</font></strong></p>
<p><strong><font color="#FF7256">《中篇》墨子言曰：有本之者，有原之者，有用之者。于何本之?上本之于古者圣王之事。于何原之?下原察百姓耳目之实。于何用之?废［发］以为刑政，观其中国家百姓人民之利。</font></strong></p>
<p><strong><font color="#FF7256">《中篇》言有三法。三法者何也?</font></strong></p>
<p><strong><font color="#FF7256">有本之者，有原之者，有用之者。于其本之也?老之天鬼之志，圣王之事。于其原之也?征以先王之书。用之奈何?发而为刑政。</font></strong></p>
<p><strong><font color="#FF7256">《下篇》言有三法。何谓三法?</font></strong></p>
<p><strong><font color="#FF7256">曰：有考之者，有原之者，有用之者。恶乎考之?考先圣大王之事。恶乎原之?察众之耳目之情。恶乎用之?发而为政乎国。察万民而观之。</font></strong></p>
</blockquote>
<p>《下篇》和《上篇》比较接近，三占从二，我就根据这两篇来说话吧。有的朋友说这是最科学的方法，因为它有本有原，“都把经验当成真理的标准”。不错，从表面上看来，似乎很合乎科学，在早期一点的学者还有人把它比成逻辑的三段论法的。但可惜这个步骤是由上而下的演绎，而不是由下而上的归纳。他那一“本”，根本就是问题。“天鬼之志”且不说，“圣人之事”是什么事?他所举出的不是一些奴隶制时代的故实吗?把一些渺茫不足凭的故实认为是真理或真实作为自己学说的出发点，这倒是最不合乎科学的。而他的“察百姓耳目之实”也很能上下其手。譬如他要证明鬼神是有吧，除古书所载之外，他可以说百姓在什么地方见过鬼，见过神，于是乎鬼神也就真正有了。又譬如他要证明命是无吧，除古书上的暴王所作之外，百姓在什么地方也没有见过命的面貌，听过命的声音，于是乎命也就真正没有丁。这议论真是素朴得可爱。“发而为刑政”，可无须乎再说，所谓“国家百姓人民之利”究竟是谁的国家?谁的百姓人民?谁的利？浅薄的“经验”是绝对不能成为“真理的标准”的呵!</p>
<p>人民百姓是应当强力疾作的，不强力疾作则“天下衣食之财将必不足”。在这儿所非的乐与所非的命都是使人民百姓“怠倦”的东西，当然也使王公大人卿大夫怠倦；假使管理人民百姓的王公大人卿大夫怠倦了，那人民百姓便更加怠倦了。所以乐与命是要不得的东西。乐，我们知道是音乐，是文化。命又是什么呢?这很不容易令人把握。他是把否认鬼神，提倡三年之丧，尊重音乐，主张有命等，作为“儒之道足以丧天下者四政”的。那么“非命”，论理是以儒家的命为攻击对象的了。但儒家的命是一种素朴的必然论，而墨子所攻击的却强半是宿命论，这是有点令人苦于索解的。宿命论固然应当反对，墨子学说里面似乎也以这一项为最有光辉。但奇妙的是和他的学说系统很不调和。说：“命者，暴王所作，穷人所述”，在命是指宿命论的时候，这是一点也不错的。譬如自古相传为标准暴王的殷纣，他便说过这样的话：“我生不有命在天”《尚书·西伯戡黎》。宿命论是和宗教的迷信不可分的，而倡导非命的墨子却是尊天明鬼的人，这不是一种奇事吗?凡是相信鬼神的人每每也要走到“百门而闭一门”的地步。《阅微草堂笔记》里面有一段故事，有一位老太婆无恶不作，却诚心信奉观音大士，以为这一功德便可以消除她一百项罪过。这和殷纣王的事真可以说是半斤八两了。孔子不相信鬼神，他所说的命是种必然论而非宿命论，在上面已经叙述过。所谓“死生有命”便是打破天上的权威，不相信崇敬鬼神便可以延年，不崇敬便会折寿。所谓“富贵在天”便是打破地上的权威，不走谄上傲下的路去求不义的富贵。这和墨子的学说倒有点不两立的。在我看来，墨子显然是在用手段，他利用命的含义有两种，便先把论敌涂饰成宿命论者，而在骨子里则尽力打击必然论，为鬼神张目。你看他叫人去查先王之书吧。他说所有先王之宪、先王之刑、先王之誓里面“亦尝有曰：福不可请，而祸不可讳(违)，敬无益，暴无伤者乎?”他反复地这样问。当然也就是说：“福可请也，祸可违也，敬有益也，暴有伤也”了。但暴是向谁暴?敬是向谁敬?祸是从何违?福是从何请呢?曰：“上帝山川鬼神”和上帝山川鬼神的“幹主”。他所称道的“先王”不用说就是奴隶时代的一些“幹主”。你要敬他，暴不得，那福就可请，祸就可违了。假使你不敬他，你要暴他，那你就该死不得活!所以结果是死生无命，富贵在王。除了王权也就是神权之外，更没有什么必然性。必然性的那种“命”实在是“上不利于天，中不利于鬼，下不利于人”的一一人者谁?“王公大人卿大夫”也!因此我曾说：“墨子的非命其实是皈命。”朋友们多说我是出于“偏恶”，但在我自己倒是尽了客观研讨的能事的。</p>
<pre><code>记于一九四四年八月一日
</code></pre><hr>
<h5 id="儒家八派的批判"><a href="#儒家八派的批判" class="headerlink" title="儒家八派的批判"></a><strong><font color="#FF7256">儒家八派的批判</font></strong></h5><p>孔子死后，据《韩非子·显学篇》说：儒家是分为八派的，“有子张之儒，有于思之儒，有颜氏之儒”有孟氏之儒，有漆雕氏之儒，有仲良氏之儒，有孙氏之儒，有乐正氏之儒”。八派中把子夏氏之儒除外了，这里有一个重要的关键。这是韩非承认法家出于子夏，也就是自己的宗师，故把他从儒家中剔除了。现在只根据这八派来阐述儒家思想的展开。子夏氏之儒，我准备把它蕴含在《前期法家的批判》里面去叙述。</p>
<p><strong><font color="#FF7256">一、“子张之儒”，</font></strong>《荀子·非十二子篇》曾加以痛骂，谓：“弟佗其冠，神罈其辞，禹行而舜趋，是子张氏之贱儒也。”荀子骂人每每不揭出别人的宗旨，而只是在枝节上作人身攻击，这是一例。像这，我们就不知道，子张一派的主张究竟有些什么特色。照《论语》里面所保存的子张的性格看来，他似乎是孔门里面的过激派。孔子说“师也辟”，辟者偏也；又和子夏的“不及”对比起来说他是“过”。但他的偏向是怎样呢?他是偏向于博爱容众这一方面的。子夏之门人问交于子张。子张曰：“子夏云何?”对曰：“子夏曰：可者与之，其不可者拒之”。子张曰：“异乎吾所闻。君子尊贤而容众，嘉善而矜不能。我之大贤与?于人何所不容?我之不贤与?人将拒我，如之何其拒人也?”(《子张》)</p>
<p>看他这调子不是很有包容一切的雅量吗?曾子曾经说过：“以能问于不能，以多问于寡，有若无，实若虚，犯而不校，昔者吾友尝从事于斯矣”。这所说的“吾友”，虽然有人以为指的是老子，但其实应该就是子张。你看他“神譚其辞”，不就是“有若无、实若虚”的表现?“禹行而舜趋”不就是“犯而不校”的表现?禹之父鲧为舜所诛戮，而禹臣服于舜。舜之弟象作恶不悛，而舜封之有庳。这些都是“犯而不校”的好榜样，所以子张氏之儒在摹仿他们，亦步亦趋。这在孔门的中庸之徒看来，应该是有点过火的，所以曾子批评他“堂堂乎张也，难与并为仁矣”，子游也批评他：“吾友张也为难能也，然而未仁”。他那样的宽容，而说他不合乎仁道；大约是嫌他有点近于乡愿吧?然而“堂堂乎张也”，倒确确实实是有所自立的。他本人的主张，残留得很少，《论语》里面有下列的两项，却充分地可以表现他的精神。</p>
<blockquote>
<p><strong><font color="#FF7256">士，见危致命，见得思义，祭思敬，丧思哀，其可已矣。(《子张》)</font></strong></p>
<p><strong><font color="#FF7256">执德不宏，信道不笃，焉能为有？焉能为亡(无)？(《子张》)</font></strong></p>
</blockquote>
<p>临到危难的时候要把自己的生命拿出来，有所利得的时候先要考虑该不该受，度量要宽大，操持要坚忍这些，岂是乡愿所能够做得到的！《艺文类聚》引《庄子》佚文“子路勇且力，其次子贡为智，曾参为孝，颜回为仁，子张为武”，作为孔子向老子的介绍。这不一定是孔子自己的话，但可作为庄子或其后学对孔门五子的批评。“子张为武”，所根据的大约就是上面所述的那些精神吧。武与勇有别，屈原《国殇》“诚既勇兮又以武”，也是把武与勇分开来的。这就明显地表明：勇指胆量，武指精神了。此外在《论语》中有关于子张和孔子的问对好多条，有“子张学干禄”，“问十世可知”，“问令尹子文”，“问善人之道”，“问明”，“问崇德辨惑”，“问政”，“问士何如斯可谓之达”，“问高宗谅阴”，“问行”，“问仁”，“问从政”，大约是子张氏之儒所保留下来的一些纪录。虽然主要是孔子所说的话，但可见于张所关心的是些什么问题，而且就是孔子的答辞也一定是经过润色，或甚至傅益的。例如像“问仁”和“问从政”两条，在《论语》中比较博衍，而和子张的精神却十分合拍，可能也就是出于傅益的例子。我现在把这两条整抄录在下边。</p>
<blockquote>
<p><strong><font color="#FF7256">一、问仁：子张问仁于孔子。孔子曰：“能行五者于天下，为仁矣。”请问之。曰：“恭、宽、信、敏、惠。恭则不侮，宽则得众，信则人任焉，敏则有功，惠则足以使人。”（《阳货》）)</font></strong></p>
<p><strong><font color="#FF7256">二、问从政：子张问于孔子曰：“何如斯可以从政矣?”予曰：“尊五美，屏四恶，斯可以从政矣”。子张曰：“何谓五美?”子曰：“君子惠而不费，劳而不怨，欲而不贪，泰而不骄，威而不猛”。子张曰：“何谓惠而不费?”子曰：“因民之所利而利之，斯不亦惠而不费乎?择可劳而劳之，又谁怨?欲仁而得仁，又焉贪?君子无众寡，无小大，无敢慢，斯不亦泰而不骄乎？君子正其衣冠，尊其瞻视，俨然人望而畏之，斯不亦威而不猛乎?”子张曰：“何谓四恶?”子曰：“不教而杀谓之虐，不戒视成谓之暴，慢令致期谓之贼，犹之与人也，出纳之吝，谓之有司。”（《尧曰》）)</font></strong></p>
</blockquote>
<p>这最后的“有司”两个字恐怕有错误，和“虐、暴、贼”不类。《荀子·宥坐篇》载孔子语“慢令谨诛，贼也；今生也有时，敛也无时，暴也；不教而责成功，虐也；已此三者，然后刑可即也”，和这儿所说的前三恶相近，但无“有司”一项。两者参照，《论语》的文句较为整饬，可以知道润色傅益是在所不免的了。照这些资料看来，子张氏这一派是特别把民众看得很重要的。仁爱的范围很广，无论对于多数的人也好，少数的人也好，小事也好，大事也好，都不敢怠慢。严于己而宽于人，敏于事而惠于费。这在表面上看来和墨家有点相似。大约就因为有这相似的原故，子张氏的后学们似乎更和墨家接近了。《荀子·儒效篇》里面有骂“俗儒”的这么一段文字：</p>
<blockquote>
<p><strong><font color="#FF7256">（一）逢衣浅带，解果其冠，略法先王而足乱世术。</font></strong></p>
<p><strong><font color="#FF7256">（二）繆学杂举，不知法后王而一制度，不知隆礼义而杀《诗》、《书》。其衣冠行伪(为)已同于世俗矣，然而不知恶者；其言议谈说已无以异子墨子矣，然而明不能别。</font></strong></p>
<p><strong><font color="#FF7256">（三）呼先王以欺愚者而求衣食焉，得委积足以掩其口，则扬扬如也；随其长子，事其便辟，举其上客(举读为与，言参与也)，亿然若终身之虏而不敢有他志。是俗儒者也。(数目字余所加。)</font></strong></p>
</blockquote>
<p>这应该是统括着“子张氏之贱儒”、“子夏氏之贱儒”、“子游氏之贱儒”而混骂的。我们把《非十二子篇》对于三派的分骂和这对照起来，便可以看出这里面的分别。子夏氏之贱儒是“正其衣冠，齐其颜色，嗛然而终日不言”，和第一项相当。子游氏之贱儒是“偷儒惮事，无廉耻而嗜饮食，必曰君子固不用其力”，和第三项相当。那么第二项必然是指子张氏之贱儒了。因此子张氏之儒的“弟佗其冠”即是颓唐其冠，这和“解果其冠”不同，杨倞引或说“解果盖高地”，即是高拱起来的意思。故“解果其冠”即巍峨其冠，正与“逢衣浅带”为配。据此可知子夏氏一派讲究戴高帽子，宽衣博带，气象俨然；而子张氏一派讲究戴矮帽子，随便不拘，同乎流俗。“言议谈说已无以异于墨子”，可见这一派的后生已经是更和墨家接近了。《庄子·盗跖篇》有子张与满苟得对话的一节，从子张的口里面说出了这样的话：仲尼、墨翟穷为匹夫，今谓宰相曰：“子行如仲尼、墨翟”，则变容易色称不足者，士诚贵也。把墨翟和仲尼对举，而让子张说出，可见做这个寓言者的心目中也是把子张看来和墨翟接近的。墨翟应该比子张迟，他在初本来是学过儒术的人，照时代上看来，倒应该说墨翟受了子张的影响。不过他们尽管有些相似，在精神上必然有绝对不能混同的地方，不然他们应该早就合流了。子张氏之儒的典籍缺乏，我们不能畅论其详，但我想，他们如有不容混同的差别，那一定是立场问题。子张氏在儒家中是站在为民众的立场的极左翼的，而墨子则是站在王公大人的立场。这应该是他们的极严峻的区别。</p>
<p><strong><font color="#FF7256">二、“子思之儒”和“孟氏之儒”、“乐正氏之儒”，</font></strong>应该只是一系。孟氏自然就是孟轲，他是子思的私淑弟子。乐正氏当即子弟子的乐正克。但这一系，事实上也就是子游氏之儒。宋代程、朱之徒虽然把思、孟归为曾子的传统，但他们的根据是薄弱的。他们所表张的《大学》其实并不是“孔子之言而曾子录之”及“曾子之意而门人记之”。他们之所以如此立说者仅因所谓传文里面有两处“子曰”和一处“曾子曰”，而已。其实假如全是“曾子之意而门人记之”，那就不必还要特别表著一句曾子的话了。既特别引用了一句曾子的话，那就可以知道全文决不是“曾子之意”的记录了。照我的看法，《大学》一篇无宁是“乐正氏之儒”的典籍，这且留在下面再加说明。先来讨论思、孟何以出于子游氏。略法先王而不知其统，犹然而材剧志大，闻见杂博，案往旧造说，谓之“五行”，甚僻违而无类，幽隐而无说，闭约而无解。案饰其辞而祗敬之曰：“此真先君子之言也”。子思倡之，孟軻和之。世俗之沟犹瞀儒，嚾嚾然不知其所非也，遂受而传之，以为“仲尼、子游为兹厚于后世”。是则子思、孟轲之罪也。（《荀子·非十二子篇》）既言思、孟之学乃“仲尼、子游为兹厚于后世”，这便是他们出于子游氏之儒的证据了。这一派也正是荀子所痛骂的“偷儒惮事，无廉耻而嗜饮食，必曰君子固不用其力”的“子游氏之贱儒”。称之为“子游氏之贱儒”不必便是骂子游，只是骂他的后学，说不定也就是指的孟轲。这种人，他在《修身篇》里面又骂为“恶少”一一“偷儒惮事，无廉耻而嗜乎饮食，则可谓恶少者矣”。虽然孟子的年辈比起荀子来并不“少”，但孟子的门徒当然又有“少”的存在。这项极现成的重要资料，二千多年来都被人忽略了，甚至还有人说“子游”是错误了的。郭嵩焘云：“荀子屡言仲尼、子弓，不及子游；本篇后云‘子游氏之贱儒’，与子张、子夏同讥，则此子游必子弓之误”（王先谦《荀子集解?非十二子》所引）。这真是以不狂为狂了。问题是很简单的。别处之所以屡言“仲尼、子弓”者，是荀子自述其师承；本处之所以独言“仲尼、子游”者，乃指于思、孟轲的道统。这是丝毫也不足怪的。子游是孔门的高足，少孔子四十五岁。他和子夏、子张、曾子等同年辈，是孔门中的少年弟子。孔门有四科，在文学一科中他占第一位一一“文学子游、子夏”。他的气概和作风，也与子夏不同。子夏是拘于小节的，是孔门中讲礼制的一派，荀子骂他们为“贱儒”，说他们“正其衣冠，齐其颜色，嗛然而终日不言”。子游也有类似的批评：“子夏之门人小子，当洒扫应对进退，则可矣，抑末也；本之则无，如之何!”可见子游是重本轻末，末既是礼数小节，本应该是大处落墨的思想问题了。他曾为武城宰，而以弦歌施于民间，十分奖励教育。孔子讥笑他“割鸡用牛刀”。这样也就相当地“犹然而材剧志大”了，故尔可能更教育出了一批“犹然而材剧志大”的人物出来。《礼记?礼运》一篇，毫无疑问，便是子游氏之儒的主要经典。那是孔子与子游的对话。开首几句是“昔者仲尼与于蜡宾，事毕，出游于观之上，喟然而叹。仲尼之叹盖叹鲁也，言偃在侧”云云。王肃伪撰《家语》谓“孔子为鲁司寇”时事，有人据此以为说，谓孔子为司寇时年五十一，子游年仅六岁，孔子五十五岁去鲁，子游年十岁，孔子决不会与十岁以下的孩子谈大同小康；因疑大同之说非孔子当日之言。这样的推断是大有问题的。《家语》伪书，本不足据，为鲁司寇时之推测虽亦本于《礼运注》“孔子仕鲁，在助祭之中”而来，此亦郑康成一时疏忽之语，同一不足为据。蜡乃岁终报田大祭，一国之人皆得参与。《杂记》：“子贡观于蜡，孔子曰：赐也，乐乎?对曰：一国之人皆若狂”。此可见孔子与于蜡非必一定要在“仕鲁”或“为鲁司寇”时才有资格。孔子晚年返鲁，与鲁国君臣上下之关系在师宾之间。孔子死时，鲁哀公赐诔，竟大呼“旻天不吊，不慗遗一老”，敬之实深，“与于蜡宾”的资格，当然是有的。那么在孔子晚年要同门弟子谈谈大同小康的故事，是没有什么不可能的了。大同小康之说其实也并不怎样深远，那只是从原始公社和奴隶制所反映出来的一些不十分正确的史影而已。虽然已经脍炙人口，不妨仍把那段文字来抄在下边。大道之行也，与三代之英，丘未之逮也，而有志焉。大道之行也，天下为公，选贤与(举)能，讲信修睦。故人不独亲其亲，不独子其子，使老有所终，壮有所用，幼有所长，矜寡孤独废疾者皆有所养。男有分，女有归。货恶其弃于地也，不必藏于己；力恶其不出于身也，不必为己。是故谋闭而不兴，盗窃乱贼，(止)而不作，故外户而不闭。是谓大同。今大道既隐，天下为家。各亲其亲，各子其子，货力为己。大人世及以为礼，城郭沟池以为固，礼义以为纪，以正君臣，以笃父子，以睦兄弟，以和夫妇，以设制度，以立田里，以贤勇知，以功为己。故谋用是作，而兵由此起。禹、汤、文、武、成王、周公由此其选也。此六君子者未有不谨于礼者也。以著其义，以考其信，著有过。刑(型)仁讲让，示民有常。如有不由此者，在势者去，众以为殃。是谓小康。这席话就是新史学家们也很能重视，有的更认为“十分正确”。其实正确的程度实在有限：因为它把原始公社太理想化了。这是一种人类退化观，不用说也就是因为有唯心论的成分搀杂进去了的毛病。把原始公社认为人类的黄金时代，以后的历史都是堕落，那是不合实际的。但这却合乎孔子“祖述尧、舜”的实际。他推崇尧、舜，根本是把原始公社的唐、虞时代作为了理想乡看的。又有的人甚至说大同思想是由墨子的“尚同”所派衍，那更是风马牛不相及的事：不仅对于这种见解没有作出正确的评价，连墨子的“尚同”是什么意思根本没有懂到。二者的相似就只有一个“同”字而已。《礼运篇》）毫无疑问，是子游氏之儒的主要经典。那不一定是子游所记录，就在传授中著诸竹帛也一定是经过了润色附益的。但要说孔子不能有那样的思想，子游也不能有那样的思想，那是把它的内容太看深远了。篇中也强调着五行，和《荀子》非难子思、孟轲“案往旧造说，谓之五行”的相合。人者，其天地之德，阴阳之交，鬼神之会，五行之秀气也。天秉阳，垂日星。地秉阴，窍于山川。播五行于四时，和而后月生也。是以三五而盈，三五而阙，五行之动，迭相竭也。五行、四时、十二月，还(旋)相为本也。五声、六律、十二管，还相为宫也。五味、六和、十二食，还相为滑(原误“质”，依阮元校改)也。五色、六章、十二衣，还相为质也。人者，天地之心也，五行之端也。像这样反复说到五行，而且把“五”这个数字业已充分神秘化了。色、声、味、季，都配以五行，月之一圆一缺也说为“五行之动”，真是配得上被批评为“甚僻违而而无类。幽隐而无说，闭约而无解”。看到“五行、四时、十二月，还相为本”的一项，足以证明《月令》一篇也必然是这一派人的撰述。他们是主张五行相生的，春为木，夏为火，中气为土，秋为金，冬为水。木火土金水周而复始，岁岁循环。《月令》的五虫为鳞羽倮毛介，倮虫以人为首，除这人而外，《礼运》的龙凤麟龟四灵，也恰为鳞羽毛介的代表。“人者五行之端”，可见也就是说人为五虫之首了。其它五声、五色、五味、五祀，了无不同。思、孟所造的五行说，在现存的思、孟书一一《中庸》和《孟子》一一里面，虽然没有显著的表现，但也不是全无痕迹。《中庸》首句“天命之谓性”，注云：“木神则仁，金神则义，火神则礼，水神则智，土神则信”。章太炎谓“是子思遗说”（见章著《子思孟轲五行说》），大率是可靠的。孟子说：“惻隐之心人皆有之，羞恶之心人皆有之，恭敬之心人皆有之，是非之心人皆有之。惻隐之心仁也，羞恶之心义也，恭敬之心礼也，是非之心智也。仁义礼智非由外铄我也，我固有之也”（《告子上》）。又说：“无惻隐之心非人也，无羞恶之心非人也，无辞让之心非人也，无是非之心非人也。恻隐之心仁之端也，羞恶之心义之端也，辞让之心礼之端也，是非之心智之端也。人之有是四端也，犹其有四体也”（《公孙丑上》）。又说：“君子所性，仁义礼智根于心”。他把仁义礼智作为人性之所固有，但缺少了一个“信”，恰如四体缺少了一个心。然而这在孟子学说系统上并没有缺少，“信”就是“诚”了。他说：“仁之于父子也，义之于君臣也，礼之于宾主也，知之于贤者也，圣人之于天道也，命也，有性焉，君子不谓命也”（《尽心下》）。这儿与仁义礼智为配的是“天道”。“天道”是什么呢?就是“诚”。“诚者天之道也，思诚者人之道也，至诚而不动者未之有也，不诚未有能动者也”（《离娄下》）。其在《中庸》）则是说：“诚者天之道也，诚之者人之道也，诚者不勉而中，不思而得，从容中道，圣人也”。这“从容中道”的圣人，也就是“圣人之于天道”的说明，是“万物皆备于我矣，反身而诚，乐莫大焉”的做人的极致。再者，诚是“中道”，这不合乎“土神则信”，而土居中央的吗?子思、孟轲都强调“中道”，事实上更把“诚”当成了万物的本体，其所以然的原故不就是因为诚信是位乎五行之中极的吗?故尔在思、孟书中虽然没有金木水火土的五行字面，而五行系统的演化确实是存在着的。正是因为从这样的理论根据出发，所以孟子道“性善”，而《中庸》主张“尽性”，在他们自己是有其逻辑上的必然的。在儒家的典籍里面除去上所举出者外，五行资料保存得最多的应当数《尚书》中的《洪范》、《尧典》、《皋陶谟》、《禹贡》诸篇。这几篇都是战国时的儒者所依托，近来已为学术界所公认了。但依托者为谁则尚无成说。据我的看法，这人也就是思、孟这一派的人。《洪范》说明着五味由五行演化的程序，所谓“水曰润下。火曰炎上，木曰曲直，金曰从革，土爰稼穡。润下作咸，炎上作苦，曲直作酸，从革作辛，稼穑作甘”。这是只举了一隅。此外如人身上的五事一一貌言视听思，发扬而为恭从明聪睿，肃乂哲谋圣；又应到天时上的五征一一雨肠燠寒风，也都是和水火木金土配合着的。“五”字本身也就成为了神秘的数字。就这样一个公式发展下去，便产生出五辰、五岳、五礼、五玉、五教、五典、五服、五刑（以上见《尧典》），五采、五色、五声、五言（以上见《皋陶谟》），“弼成五服，至于五千”，每服五百里（以上见《禹贡》），真是五之时义大矣哉了!</p>
<p>“五”以皇极居中，而“五”之本身复具有中数，凡居中者具有支配性质。《中庸》所谓“诚者从容中道”，《礼运》所谓“王中心无为也，以守至正”，也就是《洪范》的“皇建其有极，……无偏无党，王道荡荡；无党无偏，王道平平；无反无侧，王道正直；会其有极，归其有极”的意思了。这种强调“中”的观念，也正和子思书一一《中庸》的思想完全合拍。《史记·孟轲列传》谓孟子“所如者不合，退而与万章之徒，序《诗》、《书》，述仲尼之意，作《孟子》七篇”。既言“序《诗》、《书》”，可知《诗》、《书》的编制是孟氏之儒的一项大业，而荀子所以要“隆礼义而杀《诗》、《书》”，一多半也就是因为这样的原故吧。故尔像《尧典》、《皋陶谟》、《禹贡》、《洪范》诸篇，在我看来，就是思、孟之徒的作品。在这儿颇适宜于研讨《大学》。这篇文字除宋儒的旧说，如上所述，已属不可信外，近人冯友兰认为是“荀学”。主要的根据是荀子言为学当“止诸至足。曷谓至足?曰圣也”（《解蔽篇》），而《大学》言“大学之道在止于至善”。又如荀子言心术须“虚壹而静”（同上），而《大学》言“正心”，主要均须无好恶。又荀子言“君子养心莫善于诚”（《不苟篇》）而《大学》言“心诚求之”，言“诚意”。但这些证据是有问题的。因为父子固可以相似，而兄弟亦可以相似，我们不能单因相似，便断定父子为兄弟，或兄弟为父子。知止之说实原于孔子的“多闻阙疑，多见阙殆”，及老子的“知足不辱，知止不殆”。正心之说原于孟子的“养心莫善于寡欲”，及宋子的“情欲寡浅”。诚意之说则出于《中庸》与《孟子》之中心思想：是则冯氏的判断可以说是等于以兄为父了。《大学》在我看来实是孟学。它是以性善说为出发点的，正心诚意都原于性善，如性不善则心意本质不善，何以素心反为“正”，不自欺反为“诚”?又看它说，“好人之所恶，恶人之所好，是谓拂人之性，苗必逮夫身！”如性为不善，则“拂人之性”正是好事，何以反有灾害?性善性恶，本来都是臆说，但孟派尚能自圆其说，而苟派则常常自相矛盾，如既言性恶矣，而复主张心之“虚壹而静”，如何可以圆通?“虚壹而静”之说采自《管子》的《心术》、《内业》诸篇，这些都是宋荣子的遗著(余别有说)，荀子只是在玩接木术而已。格物致知的两个条目，好像是《大学》的新发展了，伯也采自《心术篇》的“舍己而以物为法”。孟子改变了一个说法，便是“舍己从人，乐取于人以为善”。古书格假二字通用之例至多，“格物”者“假物”，假借于物之意。人心只是一张白纸(在孟子是白所以为善)，要假借于物才有知识，而知识也才能达到尽头。使知识达到尽头是“致知”，知识达到了尽头是“知至”，到这时候便是“万物皆备于我”（《孟子》）了；故尔“反身而诚，乐莫大焉”（同上）。到这时候，也就是《中庸》所说的“能尽其性者，则能尽物之性”了。只是思、孟是由成功而言，《大学》是由人手而言，故尔有顺有逆。假使不是假物以致知，则孟子何必主张“博学而详说”呢?《中庸》的博学、审问、慎思、明辨、笃行，也就毫无着落了。修齐治平的四条目，分明是由孟子演绎出来的，孟子曾说：“天下之本在国，国之本在家，家之本在身。”（《离娄上》）这便是修身、齐家、治国、平天下之所本。《尧典》赞唐尧的圣德也恰恰包含着这些次第。粤若稽古帝尧，曰放勋。钦明文思，安安允恭克让，光(横)被四表，格于上下，克明峻德。以亲九族，九族既睦。平章百姓，百姓昭明。协和万邦，黎民於变，时雍。这儿很明显地也说的是修齐治平。“钦明文思”四字旧注称为“四德”，马融谓：“威仪表备谓之钦，照临四方谓之明，经纬天地谓之文，道德纯备谓之思”。然在《史记?尧本纪》则采用《五帝德》之语，翻译为“其仁如天，其知如神，就之如日，望之如云”，似乎就是礼智仁义的变文了。克己复礼为仁，故以仁当乎钦；智而如神则明，故以知当乎明；如日之当乎文者，如日之有威仪，礼也；如云之当乎思者，思或作塞，孟子谓“浩然之气塞于天地之间，是集义所生者”，（《公孙丑上》），则是义了。这些正表明《尧典》出子思、孟之徒的又一证。而《大学》的首章，差不多也就是《尧典》这一节文字的翻译，下面把“《尧典》曰克明峻德”点明了出来，更加指示了它的思想的来源了。复次，荀子是（（隆礼义而杀《诗》、《书》”的，然而《大学》全篇里面却没有一个礼字，而《诗》、《书》则翻来覆去的引用，《诗》引了十二次，《书》引了七次(其中《康诰》四）《太甲》、《尧典》、《泰誓》各一)，单只这一点也就和荀子大有距离了。故在我看来，《大学》是孟学，而且是乐正氏之儒的典籍。何以见得呢?第一，在孟派里面乐正克是高足。第二，以乐正为氏是学官的后裔，《王制》云“乐正崇四术，立四教”，其职与《周官》的乐师相当。而次于大乐正。先代既为学官，当有家学渊源，故论“大学之道”。第三，乐正克，孟子称之为“善人”，为“信人”，又说“其为人也好善”。而《大学》仅仅一七四三字的文章便一共有十一个善字露面。准同样的理由，《礼记》中的《学记》一篇，我也认为是乐正氏所作。《学记》）亦言“大学之道”，与《大学》相为表里。古之教者，家有塾，党有庠，术有序，国有学，比年入学，中年考校。一年视离经辨志，三年视敬业乐群，五年视博习亲师，七年视论学取友，谓之小成。九年知类通达，强立而不反，谓之大成。夫然后足以化民成俗，近者悦服，而远者怀之。此大学之道也。“离经辨志，敬业乐群，博习亲师，论学取友，”便是“格物”，都是有所假于外物的。“知类通达”，便是“物格而知至”。“强立而不反”，便是“知至而意诚，意诚而心正”。这些是“修身”的事。“化民成俗，近者悦服，而远者怀之”，便是“齐家、治国、平天下”的事了。这样和《大学》的“大学之道”相印证，于是“格物”的意义也就更加明了了。但在冯友兰氏，则依据“强立而不反”一语，以为与《荀子。不苟篇》“长迁而不反其初，则化矣”相类，乃性恶说之引伸，故认《学记》为苟学。且因《学记》言（（大学之道”，《大学》亦言“大学之道”，《学记》既为苟学，遂断言鼍大学》亦不得不为荀学。其《大学》为荀学说在事实上即以此为发端，继后才由《大学》中摘取与《荀子》相似之义以为证佐。故《学记》为荀学，实是《大学》为荀学说的大前提。然此大前提，也同样的靠不住。“强立而不反”即《洪范》所谓“无反无侧，王道正直”，《中庸》所谓“中立而不倚，强哉矫”，亦即《孟子》所谓“强恕而行”或“中道而立，能者从之”。行是前进，也就是“不反”。物不进必退，无所自立，必反于不学无术，故“强立而不反”一语不一定要性恶说才能适用。《学记》对于教育与学习是主张自发的，言“道(导)而弗牵，强而弗抑，开而弗达”。这和孟子的“君子深造之以道）欲其自得之也，自得之则居之安，居之安则资之深，资之深则取之左右逢其原”（《离娄下》），在精神上是完全合拍的。这是性善说者的内发主义，与荀子的偏重外铄，毕竟不同。故要把《学记》认为荀学，依然是大有距离的。顺便再把《中庸》一篇研讨一下吧。《中庸》一篇，冯友兰氏虽认为“与孟子之学说为一类”，而疑“似秦、汉孟子一派的儒者所作”。证据是“今天下车同轨，书同文，行同伦”为秦、汉统一中国后之景象。又有“载华岳而不重”亦疑非鲁人之言。“载华岳而不重”，一语无关重要。请看与子思约略同时而稍后的宋钘，便“作为华山之冠以自表”，足见东方之人正因未见华山而生景慕。忽近而求远，乃人情之常，鲁人而言华岳，亦犹秦人而言东海而已。“书同文，行同伦”，在春秋、战国时已有其实际，金文文字与思想之一致性便是证明，不必待秦、汉之统一。仅“车同轨”一语或有问题，但在目前亦尚无法足以断言秦以前各国车轨决不一致。秦入统一天下之后，因采取水德王之说，数字以六为贵，故定“舆六尺。六尺为一步，乘六马”（《始皇本纪》）。以此统一天下之车轨，此乃一种新的统一面已。故如冯氏所论，实不足以否定子思的创作权。不过《中庸》经过后人的润色窜易是毫无问题的，任何古书，除刊铸于青铜器者外，没有不曾经过窜易与润色的东西。但假如仅因枝节的后添或移接，而否定根干的不古，那却未免太早计了。三“颜氏之儒”当指颜回的一派。颜回是孔门的第一人，他虽然早死，但在他生前已经是有“门人”的。这一派的典籍和活动情形，可惜已经失传了。只有关于颜回个人，我们在《论语》和其它的书籍里面可以找得到一些资料。我们知道他是“其心三月不违仁”的人，“一箪食，一瓢饮，在陋巷，人不堪其忧）而回也不改其乐”。他很明显地富有避世的倾向，因而《庄子》书中关于他的资料也就特别多，全书计凡十见，《人间世》、《天运》、《至乐》、《达生》、《田子方》、《知北游》诸篇各一，《大宗师》、《让王》二篇各二。这些资料在正统派的儒家眼里都被看成为“寓言”去了。其实庄子著书的条例是：“寓言十九，重言十七”。“重言”是“耆艾之言”，要占目分之七十。因之，不见于正统儒书的记载，我们是不好全部认为假托的。特别值得重视的是论“心斋”与“坐忘”的两节文章，我且把它们摘录在下边。</p>
<blockquote>
<p><strong><font color="#FF7256">一、论心斋：回曰：“敢问心齐(斋)”。仲尼曰：“一若志。无听之以耳而听之以心，无听之以心而听之以气。听止于耳，心止于符。气也者，虚而待物者也，唯道集虚，虚者心齐也”。颜回曰：“回之未始得使，实自回也。得使之也，未尝有回也，可谓虚乎?”夫子曰：“尽矣”。（《人间世》）</font></strong></p>
<p><strong><font color="#FF7256">二、论坐忘：颜回曰：“回益矣”。仲尼曰：“何谓也?”曰：“回忘仁义矣”。曰：“可矣，犹未也”。他日复见，曰：“回益矣”。曰：“何谓也?”曰：“回忘礼乐矣”。曰：“可矣，犹未也”。他日复见，曰：“回益矣”。曰：“何谓也?”曰：“回坐忘矣”。仲尼蹴然曰：“何谓坐忘?”颜回曰：“堕肢体，黜聪明，离形去知，同于大通，此谓坐忘”。仲尼曰：“同则无好也，化则无常也，而(尔)果其贤乎，丘也请从而(尔)后也”。(《大宗师》）</font></strong></p>
</blockquote>
<p>这两节都是在《内篇》里面的文字。要说是假托，庄子为什么要把这些比较精粹的见解托之于孔、颜而不托之道家系统的人，或率性假拟一些人名呢?因而我想，这些应该都是“颜氏之儒”的传习录而在庄子是作为“重言”把它们采用了的。孔、颜当时不一定便真正说过这样的话，但有过这样的倾向，而被颜氏之儒把它夸大了，这不能说是不可能。凡是形成了一个宗派的学说，对于本派的祖师总是要加以夸大化的，古今中外都是如此。孔子本人原来就是有些超现实的倾向的人，他曾说：“饭蔬食，饮水，屈肱而枕之，乐亦在其中矣”。他又赞成曾皙的“暮春者春服既成，冠者五六人，童子六七人，浴乎沂，风乎舞雩，咏而归”的那种飘逸。这和颜回的“一箪食，一瓢饮，在陋巷，不改其乐”的态度确有一脉相通的地方。有像这样的师弟，又何故不能流衍出一批更超现实的后学呢?假如我们想到王阳明的弟子，不一二传便流于狂禅，这段史影是更容易令人首肯了。孔子之门，在初斯时实在很复杂，里面颇有不少的狂放的人物。孟子说：“如琴张、曾皙，牧皮者，孔子之所谓狂矣”（《尽心下》）。曾皙即曾点，是曾参的父亲，《檀弓》言季武子之丧，“曾点倚其门而歌”。这是见于儒家经典的事，其狂态已经可掬。琴张、牧皮见《庄子·大宗师》篇：子桑户、孟子反、子琴张，三人相与友。曰：“孰能相与于无相与，相为于无相为?孰能登天游雾，挠挑无极，相忘以生，无所终穷?”三人相视而笑，莫逆于心，遂相与友。莫然有间而子桑户死，未葬，孔子闻之，使子贡往侍事焉。或编曲，或鼓琴，相和而歌曰：“嗟，来，桑户乎。嗟，来，桑户乎。而(尔)已反其真，而我犹为人猗?”这和曾点“倚门而歌”的态度正相仿佛。孟子反即《论语》孟之反，马叙伦谓即牧皮，牧孟双声，皮反对转或因形近而误。这是说得很有道理的。曾哲是孔子弟子可不用说，由孟子看来，就连琴张、孟子反，也是孔门弟子丁。这不是比颜回、原宪之徒已经更进了一境吗?</p>
<p>事实上就是曾参、子思、孟子也都是有这种倾向的人。《荀子·解蔽篇》替我们保存了他们的一些生活资料，照那情形看来，他们都是禁欲主义者，虽不能说是狂，却是有十分的狷。曾子曰：“是其庭可以捕鼠，恶能与我歌矣?”空石之中有人焉，其名曰般，其为人也善射(猜谜)以好思。耳目之欲接则败其思，蚊虻之声闻则挫其精。是以僻耳目之欲而远蚊虻之声，闲居静思则通。思仁若是，可谓微乎?</p>
<blockquote>
<p><strong><font color="#FF7256">孟子恶败而出妻，可谓能自强矣。有子恶卧而焊掌，可谓能自忍矣。未及好也。僻耳目之欲，可谓能自强矣，未及思也。蚊虻之声闻则挫其精，可谓危矣，未可谓微也。夫微者至人也。至人也，何强?何忍?何危?故浊明外景(影)，清明内景。圣人纵其欲，兼其情，而制焉者理矣。夫何强？何忍？何危？</font></strong></p>
</blockquote>
<p>这一段文字有些错乱，前后脉络不甚清晰，但大体上是可以领会的。“孟子恶败出妻”，毫无疑问是一位禁欲主义者的行径，败是嫌男女之际败坏精神或身体，而不是妻有“败德”。这由上下文的“僻欲”、“淬掌”等便可以得到旁证。更值得注意的是在曾子、孟子、有子之间，夹一位“空石之中”的殿先生。这人决不会是子虚乌有，而且必然也是相当有名的孔门之徒，然后才合乎文理。因此我发觉，这位先生所隐射的正是子思。子思名伋，与殿同音，“空石之中”即为孔，荀子是痛骂子思的人，故因其“善射以好思”，故意把他姓名来“射”了一下。据此，足见子思也是一位禁欲主义者了。曾子的一句话颇费解，但在《庄子·让王篇》有一段故事可相印证。“曾子居卫，缊袍无表，颜色肿哙，手足胼胝，三日不举火，十年不制衣，正冠而缨绝，捉衿而肘见，纳屦而踵决，曳縰而歌《商颂》，声满天地，若出金石。……据此可见“是其庭可以捕鼠，乃表示食米狼藉，以致老鼠纵横，所斥责者的生活是与曾子相反的。曾参的作风，和他父亲曾点，不是颇相类似吗?</p>
<p>连曾子、子思、孟子都有这样严格禁欲的倾向，颜氏之儒会有心斋坐忘一类的玄虚，那是不足为异的。四“漆雕氏之儒”是孔门的任侠一派。《显学篇》言：“漆雕之议，不色挠，不目逃，行曲则违于臧获，行直则怒于诸侯”。这种矜气尚勇的态度和孟子所说的“北宮黝之养勇也”相仿佛，后者也是：“不肤挠，不目逃，思以一毫挞于人，若挞之于市朝。不受于褐宽博，亦不受于万乘之君，视刺万乘之君若刺褐夫。无严诸侯，恶声至，必反之”。北宫黝虽然没有“行曲则违于臧获”的一层，但孟子所说的是他受了委曲时的态度，假使他不是受了委曲，毫无“一毫挫于人”的地方，我相信他对于“褐宽博”也是决不会侵犯的。孟子又说“北宮黝似子夏”，大约这位北宫先生也就是漆雕氏之儒的一人了。漆雕究竟是谁呢?孔门弟子中有三漆雕，一为漆雕开，一为漆雕哆，又一为漆雕徒父，但从能构成为一个独立的学派来看，当以漆雕开为合格。他是主张“人性有善有恶”的人，和宓子贱、公孙尼子、世硕等有同一的见解。王充《论衡·本性篇》替我们保存了这项资料。周人世硕，以为“人性有善有恶，举人之善性养而致之则善长，恶性养而致之则恶长”。如此，则性各有阴阳善恶，在所养焉，故世子作《养书》一篇。宓子贱、漆雕开、公孙尼子之徒亦论情性，与世子相出入，皆言性有善有恶。这几位儒者都是有著作的。《艺文志》儒家中有下列著录：</p>
<blockquote>
<p><strong><font color="#FF7256">《漆雕子》十三篇：孔子弟子漆雕■後(後字乃衍文。盖■原作启，抄书者旁注■字，嗣被录入正文，而启误认为后，乃转讹为後也)。</font></strong></p>
<p><strong><font color="#FF7256">《宓子》十六篇：名不齐，字子贱，孔子弟子。《世子》二十一篇：名硕，陈人也，七十子之弟子。</font></strong></p>
<p><strong><font color="#FF7256">《公孙尼子》二十八篇：七十子之弟子。</font></strong></p>
</blockquote>
<p>这些书，除公孙尼子有《乐记》一篇传世外，可惜都失传了，《乐记》也是经过窜乱的。这几位儒者大约都是一派吧。漆雕子与宓子虽同是孔子弟子，但前者少孔子十一岁，后者少孔子四十九岁，两人之间可能是义兼师友的。两人不仅学说相同，遭遇亦颇近似。《墨子·非儒篇》言“漆雕刑残”，《孔丛子·诘墨篇》引作漆雕开，而《韩非·难言篇》）言“宓子贱不斗而死人手”。这显然是由于矜气尚廉，藐视权威的原故所致了。又《礼记》有《儒行篇》盛称儒者之刚毅特立，或许巾。就是这一派儒者的典籍吧。五“仲良氏之儒”无可考，或许就是陈良的一派。孟子说：“陈良，楚产也。悦周公、仲尼之道，北学于中国。北方之学者未能或之先也”，（《滕文公上》）。他是有门徒的，陈相与其弟辛，“事之数十年”，足见他在南方讲学甚久，门徒一定不少的。以年代言，屈原就应该出于他的门下。屈原的思想纯是儒家思想，他在南方必得有所承受。唯仲良而氏之，与陈良复有不同。或许“陈”是误字，因有陈相、陈辛而抄书者联想致误的吧。六“孙氏之儒”，就是荀子的一派，苟卿又称孙卿。他这一派在战国后半期是一大宗。他是赵国的人，游学于齐，曾为稷下先生，后应春申君之邀，入楚而为兰陵令。他后来回过赵国，在孝成王之前同临武君议兵；又曾游秦，向昭王和应侯传道，但结果没有被采用。他的死是在秦始皇兼并天下以后，焚书坑儒之祸说不定都是在他的生前出现的。《荀子》书末附有一段赞辞，便是明证。为说者曰：“孙卿不及孔子，”是不然。孙卿迫于乱世，醋于严刑，上无贤主，下遇暴秦。礼义不行，教化不成，仁者诎约，天下冥冥，行全刺之，诸侯大倾。当是时也，知者不得虑，能者不得治，贤者不得使，故君上蔽而无睹，贤人距而不受。然则孙卿怀将圣之心，蒙佯狂之色，视(示)天下以愚。《诗》曰：“既明且哲，以保其身”，其此之谓也。是其所以名声不白，徒与不众，光辉不博也。今之学者得孙卿之遗言余教，足以为天下法式表仪。所存者神，所过者化。观其善行孔子弗过。世不详察，云非圣人。奈何，天下不治，孙卿不遇时也。(《尧问》)<br>这自然是荀子门人对于老师的赞颂，在他们心目中荀子简直是超过了孔子的。他“下遇暴秦”，“蒙佯狂之色”，足见确是领略过秦始皇的暴政滋味。《盐铁论?毁学篇》言“方李斯之相秦也，荀卿为之不食”，说者多以为为时过晚，其实那是由于把荀子的生年太定早了的原故。荀子门徒虽然把他当成圣人，但荀子本人却不曾这样地夸大。他是时常称道仲尼，把仲尼认为儒家的总教祖的。他又屡次称道子弓，和仲尼并举，足见他又是子弓的徒属了。</p>
<blockquote>
<p><strong><font color="#FF7256">圣人之不得势者，仲尼、子弓是也。上则法舜、禹之制，下则法仲尼、子弓之义。《非十二子篇》通则一天下，穷则独立贵名，天不能死，地不能埋，桀、纣之世不能污。非大儒莫之能立，仲尼、子弓是也。(《儒效篇》)</font></strong></p>
<p><strong><font color="#FF7256">仲尼长，子弓短。(《非相篇》)</font></strong></p>
</blockquote>
<p>这样的一位“天不能死，地不能埋”的与仲尼并列的子弓，有人说，就是仲弓，本子路亦称季路之例，则仲弓亦可称为子弓。但这个例实在不好援用。因为仲尼不见称子尼，伯鱼不见称子鱼，而子思亦不见称季思，则子路仅亦字季路而已。子弓确有这么一个人，便是传《易》的馯臂子弓。《史记·仲尼弟子列传》云：商瞿，鲁人，字子木，少孔子二十九岁。孔子传《易》于瞿；瞿传楚人馯臂子弘；弘传江东人矫子庸疵；疵传燕人周子家竖。又《汉书?儒林传》云：自鲁商瞿子木受《易》孔子，以授鲁桥庇子庸；子庸授江东馯臂子弓；子弓授燕周醜子家。这两个传统是一套，《史记》的人名是字上名下的古式，《汉书》是名上字下的新式，足见《史记》的资料有双重的古意。第三代和第四代，两种传统互易了，我看当从《史记》，但《史记》的“馯臂子弘”应作“馯(姓)子弘(字)臂(名)”才能划一，那一定是后来的人照《汉书》的新式抄错了的。《易经》在秦时未遭火焚，传《易》者当然也不犯禁，故尔有它的详细传统，但谓“孔子传《易》于瞿”，那只是《易》家后学的附益而已。孔子不曾见过《易》）连商瞿也不见得见过。我认为《易》是子弓创作的，详见拙作《周易之制作时代》一文。在先秦儒家中，荀子为谈到《易》的唯一的人，在《非相篇》与《大略篇》各引“《易》曰”一句，《大略篇》又论到“《易》之咸见夫妇”，和《易象传》的见解相符。大率在荀子晚年“蒙佯狂之色”的时候，他才攒进了《易》里面去的。他在别的地方并不曾把《易》来和《诗》、《书》、《礼》、《乐》、《春秋》并列（参看《劝学篇》），似乎在他的初年还不曾把《易》当成经。但等待他一攒进《易》去之后，便受了很深的影响，《易传》强半是出于他的门徒之手，因而《易传》中的许多“子曰”，应该就是荀子在说。正因此，他是那样地把子弓神圣视了。商瞿对于子弓，有些思想上的影响，是不成问题的。《孟子》书中曾言“子莫执中”（《尽心上》）。这位子莫虽然有人说是魏公子牟或者端孙子莫，但在我看来可能就是商瞿子木。又《尸子?广泽篇》有云“皇子贵衷”，贵衷与执中同义，则皇子当即商子，商皇古音同在阳部。中之义为《易》所摄取，作《易》者的基本认识，是以为宇宙万物均在变化之中，变化是宇宙过程，而变化之所由生则因有阴阳刚柔相反二性之对立，由于无数对立物之相推相荡而变化因以无穷际。这是对于自然界的看法。但说到人事界来，便要参加一层斟酌的意义。人乘此变化，当处于中正之地位，使对立物无过无不及，使在人事界的变化，可以不至于走到极端(“亢”)，因而变化便可以静定下来，地位便可以长久安定(“永贞”)下去。这样便有百利而无一害。这大约也就是子莫所执的“中”，皇子所贵的“衷”了。这分明是一种直线式的折半主义，处己贵不刚不柔，称物是裒多益寡，那样便每每使变化静定，即使有变化也不能发展而为进化。所谓“《易》之道逆数也”，传《易》者也早就明白它是反乎自然的。虽然乾卦的《象传》在说“天行健，君子以自强不息”，但那只是做《象传》者的意思，而不是经的本意。要那样不息下去，经会警告你：“亢龙有悔”呵。孟子是反对这种“执中”形式的，他说“执中无权犹执一也”，执一便是僵定，“举一而废百”。孟子既反对“无权”，则他必然主张“有权”。权就是天秤的砝码，无权者是不用砝码，把两端的轻重去取一下，使其画一。有权者是要用砝码，增加轻的一端，使与重的一端平衡。这样所得到的平衡便是更高的一个阶段。在孟子确是有过这样的主张：他要“与民同乐”，要“使有菽粟如水火”，这大约就是两派虽同样主张“执中”而又互相非难的原故吧。作《易经》的人很明显的是已经知道了五行说的。坤卦六五“黄裳元吉”，离卦六二“黄离元吉”，逐卦六二“用黄牛之革”，解卦九二“得黄矢”，鼎卦六五“鼎黄耳金铉”。二与五居下卦与上卦之中，不仅爻多吉辞，且以黄色表位，这分明是作者已经知道五方五色的配合的证据。照年代说来，子弓和子思同时，他能知道五行说的梗概，是毫无问题的。这两派，在儒家思想上要算是一种展开，就在中国的思想史上也要算是最初呈出了从分析着想的倾向。他们同认宇宙是变化过程，而在说明这种过程上，子思提出了五行相生，子弓提出了阴阳对立。这两种学说后为邹衍所合并，而又加以发展，便成为了所谓阴阳家。接着，更加上迷信的成分，于是便成为二干多年的封建社会的妖魔窟。这是子思和子弓所初料不及的。关于荀子思想的批判，当另为专文以论之，兹不赘述。</p>
<pre><code>记于一九四四年九月十一日 
</code></pre><hr>
<h4 id="郭沫若《十批判书》（3）"><a href="#郭沫若《十批判书》（3）" class="headerlink" title="郭沫若《十批判书》（3）"></a>郭沫若《十批判书》（3）</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#FF7256&quot;&gt;郭沫若 著作&lt;/font&gt;&lt;/strong&gt;        &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;郭沫若《十批判书》（1）&quot;&gt;&lt;a href=&quot;#郭沫若《十批判书》（1）&quot;
    
    </summary>
    
      <category term="郭沫若" scheme="http://yoursite.com/categories/%E9%83%AD%E6%B2%AB%E8%8B%A5/"/>
    
    
      <category term="国学" scheme="http://yoursite.com/tags/%E5%9B%BD%E5%AD%A6/"/>
    
      <category term="天下乌贼" scheme="http://yoursite.com/tags/%E5%A4%A9%E4%B8%8B%E4%B9%8C%E8%B4%BC/"/>
    
  </entry>
  
  <entry>
    <title>HTTP/HTTPS/SOCKET</title>
    <link href="http://yoursite.com/2016/09/03/HTTP-HTTPS-SOCKET/"/>
    <id>http://yoursite.com/2016/09/03/HTTP-HTTPS-SOCKET/</id>
    <published>2016-09-03T08:49:51.000Z</published>
    <updated>2016-09-16T16:23:10.703Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong><font color="#FF7256">写在本文之前先声明一点：本文是作者通过收集的文章以及自己的看法统一精心整理而成的，主要的参考链接已给出，若想更加全面的理解HTTP协议，建议阅读《图解HTTP》一书，本文花费作者大量时间和精力，未经作者允许禁止转载！</font></strong></p>
</blockquote>
<p><a href="http://www.androidchina.net/4710.html" target="_blank" rel="external">http://www.androidchina.net/4710.html</a><br><a href="http://www.androidchina.net/3934.html" target="_blank" rel="external">http://www.androidchina.net/3934.html</a><br><a href="http://www.androidchina.net/5469.html" target="_blank" rel="external">http://www.androidchina.net/5469.html</a><br><a href="http://www.jianshu.com/p/de262cfbb4ef" target="_blank" rel="external">http://www.jianshu.com/p/de262cfbb4ef</a><br><a href="http://www.jianshu.com/p/e544b7a76dac" target="_blank" rel="external">http://www.jianshu.com/p/e544b7a76dac</a><br><a href="http://www.jianshu.com/p/8565912949bb#" target="_blank" rel="external">http://www.jianshu.com/p/8565912949bb#</a><br><a href="http://my.oschina.net/yuanxulong/blog/355055" target="_blank" rel="external">http://my.oschina.net/yuanxulong/blog/355055</a><br><a href="http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html" target="_blank" rel="external">http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html</a></p>
<h3 id="一、HTTP"><a href="#一、HTTP" class="headerlink" title="一、HTTP"></a><strong><font color="#FF7256">一、HTTP</font></strong></h3><p>http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。它不涉及数据包传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p>
<p><img src="http://storage1.imgchr.com/images/TCP-IP1cee2.png" alt="enter image description here"></p>
<p>HTTP主要缺点：</p>
<ol>
<li><p>通信使用明文（不加密），内容可能会被窃听</p>
</li>
<li><p>不验证通信方的身份，因此有可能遭遇伪装</p>
</li>
<li><p>无法证明报文的完整性，所以有可能已遭篡改</p>
</li>
</ol>
<p>这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题。</p>
<p>除此之外，HTTP 本身还有很多缺点。而且，还有像某些特定的 Web 服务器和特定的 Web 浏览器在实际应用中存在的不足（也可以说成是脆弱性或安全漏洞），另外，用 Java 和 PHP 等编程语言开发的 Web 应用也可能存在安全漏洞。</p>
<p><strong><font color="#FF7256">通信使用明文可能会被窃听</font></strong></p>
<ol>
<li><p>TCP/IP 是可能被窃听的网络<br>如果要问为什么通信时不加密是一个缺点，这是因为，按 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。</p>
</li>
<li><p>加密处理防止被窃听<br> 通信的加密<br> 内容的加密</p>
</li>
</ol>
<p><strong><font color="#FF7256">不验证通信方的身份就可能遭遇伪装</font></strong></p>
<ol>
<li>任何人都可发起请求</li>
</ol>
<p>在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下）。</p>
<p>HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。</p>
<p>a. 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</p>
<p>b. 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</p>
<p>c. 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。</p>
<p>d. 无法判定请求是来自何方、出自谁手。</p>
<p>e. 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。</p>
<ol>
<li>查明对手的证书</li>
</ol>
<p><strong><font color="#FF7256">无法证明报文完整性，可能已遭篡改</font></strong></p>
<ol>
<li>接收到的内容可能有误<br>由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。<br>换句话说，没有任何办法确认，发出的请求 / 响应和接收到的请求 / 响应是前后相同的。<br>比如，从某个 Web 网站上下载内容，是无法确定客户端下载的文件和服务器上存放的文件是否前后一致的。文件内容在传输途中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的。<br>像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）。</li>
<li>如何防止篡改<br>a. 虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。<br>b. 提供文件下载服务的 Web 网站也会提供相应的以 PGP（Pretty Good Privacy，完美隐私）创建的数字签名及 MD5 算法生成的散列值。PGP 是用来证明创建文件的数字签名，MD5 是由单向函数生成的散列值。不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。浏览器无法自动帮用户检查。</li>
</ol>
<p>可惜的是，用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。</p>
<p>为了有效防止这些弊端，有必要使用 HTTPS。SSL 提供认证和加密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。下节我们介绍 HTTPS 的相关内容。<br><strong><font color="#FF7256">关键词：</font></strong></p>
<blockquote>
<p><strong><font color="#FF7256">URL：uniform resource location 统一资源定位符</font></strong></p>
</blockquote>
<p>　　访问web的一个字符串地址</p>
<blockquote>
<p><strong><font color="#FF7256">URI：uniform resource identifier 统一资源标识符</font></strong></p>
</blockquote>
<p>　　这也就是说，URI是一种资源的标识；而URL也是一种URI，也是一种资源的标识，但它也指明了如何定位Locate到这个资源。</p>
<p>　　URI是一种抽象的资源标识，既可以是绝对的，也可以是相对的。但是URL是一种URI，它指明了定位的信息，必须是绝对的。而我们平时所说的相对地址，仅仅是相对于另一个绝对地址而言。</p>
<blockquote>
<p><strong><font color="#FF7256">RFC：reqeust for comments 征求修正意见书</font></strong></p>
</blockquote>
<p>　　RFC素有网络知识圣经之称，规定了网络中协议的基本内容。因此许多的不同系统的应用程序才可以互相访问。</p>
<p><img src="http://storage1.imgchr.com/images/IP-TCP-DNS-HTTP1.png" alt="enter image description here"></p>
<blockquote>
<p><a href="http://www.androidchina.net/4892.html" target="_blank" rel="external">Android HTTP网络请求的异步实现</a>（转载）</p>
</blockquote>
<p>HTTP报文如图所示：</p>
<p><img src="http://i4.buimg.com/567571/b4c94e43e3504e70.png" alt="enter image description here"></p>
<h4 id="协议版本："><a href="#协议版本：" class="headerlink" title="协议版本："></a><strong><font color="#FF7256">协议版本：</font></strong></h4><h5 id="HTTP-0-9："><a href="#HTTP-0-9：" class="headerlink" title="HTTP/0.9："></a><strong><font color="#FF7256">HTTP/0.9：</font></strong></h5><p>只有一个命令GET</p>
<blockquote>
<p><strong><font color="#FF7256">GET /index.html</font></strong></p>
</blockquote>
<p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。</p>
<p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;body&gt;Hello World&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>服务器发送完毕，就关闭TCP连接。</p>
<h5 id="HTTP-1-0："><a href="#HTTP-1-0：" class="headerlink" title="HTTP/1.0："></a><strong><font color="#FF7256">HTTP/1.0：</font></strong></h5><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p>
<p>其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。</p>
<p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p>
<p>其他的新增功能还包括<a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="external">状态码（status code）</a>、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>
<p>当前浏览器客户端与服务器端建立连接之后，只能发送一次请求，一次请求之后连接关闭。</p>
<p><img src="http://storage1.imgchr.com/images/318e4ee4d75de441.png" alt="enter image description here"></p>
<p>报文首部：客户端和服务器处理时七至关重要作用的信息几乎都在这里面；</p>
<p>报文主体：所需要的用户和资源的信息都在这里面。</p>
<p>其中空行用于区分报文首部和报文主体内容，是由一个回车符和一个换行符组成。</p>
<p>无论是请求报文还是响应报文都需要有报文首部，当然报文主体有的请求报文是没有的。<br>　　<br>　　1. 请求行包含用于请求的方法，请求 URI 和 HTTP 版本。</p>
<p>　　2. 状态行包含表明响应结果的状态码，原因短语和 HTTP 版本。<br>　　<br>状态行格式如下：</p>
<p>HTTP-Version Status-Code Reason-Phrase CRLF</p>
<p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。</p>
<p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p>
<p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p>
<p>常见状态代码、状态描述、说明：</p>
<p>200 OK      //客户端请求成功<br>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden  //服务器收到请求，但是拒绝提供服务<br>404 Not Found  //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error //服务器发生不可预期的错误<br>503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">eg</span>: HTTP/1.1 200 OK （CRLF）</div></pre></td></tr></table></figure></p>
<p>区别：</p>
<p>　　1. 请求行中指定的是HTTP版本和请求的方式（GET\POST等）。</p>
<p>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF  </p>
<p>其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</p>
<p>请求方法（所有方法全为大写）有多种，各个方法的解释如下：</p>
<p>GET     请求获取Request-URI所标识的资源</p>
<p>POST    在Request-URI所标识的资源后附加新的数据</p>
<p>HEAD    请求获取由Request-URI所标识的资源的响应消息报头</p>
<p>PUT     请求服务器存储一个资源，并用Request-URI作为其标识</p>
<p>DELETE  请求服务器删除Request-URI所标识的资源</p>
<p>TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断</p>
<p>CONNECT 保留将来使用</p>
<p>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</p>
<p>应用举例：</p>
<p>GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg： GET /form.html HTTP/1.1 (CRLF)</div></pre></td></tr></table></figure></p>
<p>POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg：POST /reg.jsp HTTP/ (CRLF)</div></pre></td></tr></table></figure></p>
<p>Accept:image/gif,image/x-xbit,… (CRLF)<br>…<br>HOST:www.guet.edu.cn (CRLF)<br>Content-Length:22 (CRLF)<br>Connection:Keep-Alive (CRLF)<br>Cache-Control:no-cache (CRLF)</p>
<p>CRLF：该CRLF表示消息报头已经结束，在此之前为消息报头</p>
<p>user=jeffrey&amp;pwd=1234  //此行以下为提交的数据</p>
<p>HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p>
<p>　　2. 状态行中指定了HTTP版本和返回的状态码以及短语。</p>
<p>　　3. 并且，请求首部与相应首部中拥有不同的属性。</p>
<p>　　4. 如何发送http有很多种方式，但是最常用的就是POST和GET。</p>
<p>　　其他的有些出于安全性的考虑一般都不建议使用。那么POST与GET有什么区别呢？</p>
<p>　　1. 使用目标不同：</p>
<p>　　POST与GET都用于获取信息，但是GET方式仅仅是查询，并不对服务器上的内容产生任何作用结果；每次GET的内容都是相同的。</p>
<p>　　POST则常用于发送一定的内容进行某些修改操作。</p>
<p>　　2. 大小不同：</p>
<p>　　由于不同的浏览器对URL的长度大小有一定的字符限制，因此由于GET方式放在URL的首部中，自然也跟着首先，但是具体的大小要依浏览器而定。</p>
<p>　　POST方式则是把内容放在报文内容中，因此只要报文的内容没有限制，它的大小就没有限制。</p>
<p>　　3. 安全性不同：</p>
<p>　　上面也说了GET是直接添加到URL后面的，直接就可以在URL中看到内容。</p>
<p>　　而POST是放在报文内部的，用户无法直接看到。</p>
<p>　　总的来说，GET用于获取某个内容，POST用于提交某种数据请求。</p>
<p>　　按照使用场景来说，一般用户注册的内容属于私密的，这应该使用POST方式；而针对某一内容的查询，为了快速的响应，可以使用GET方式。</p>
<p>在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。
　　</p>
<h6 id="请求报文格式："><a href="#请求报文格式：" class="headerlink" title="请求报文格式："></a><strong><font color="#FF7256">请求报文格式：</font></strong></h6><p><img src="http://storage1.imgchr.com/images/9e8d2d586b9f4129.png" alt="enter image description here"></p>
<p>　<br><strong><font color="#FF7256">请求行：</font></strong></p>
<p>请求行（Request Line）分为三个部分：请求方法、请求地址和协议及版本，以CRLF(\r\n)结束。</p>
<p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE,最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p>
<p>在了解请求地址之前，先了解一下URL的构成：</p>
<p><img src="http://storage1.imgchr.com/images/URL977f1.png" alt="enter image description here"></p>
<p>PATH是URL主机以后的部分，即包含了Query String，如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">URL</th>
<th style="text-align:center">PATH</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://http://www.jianshu.com/" target="_blank" rel="external">http://http://www.jianshu.com/</a></td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center"><a href="http://localhost:8080/index.php?id=1234" target="_blank" rel="external">http://localhost:8080/index.php?id=1234</a></td>
<td style="text-align:center">/index.php?id=1234</td>
</tr>
<tr>
<td style="text-align:center"><a href="http://weibo.com/920507888/home" target="_blank" rel="external">http://weibo.com/920507888/home</a></td>
<td style="text-align:center">/home</td>
</tr>
</tbody>
</table>
<p>最长使用的属性是：</p>
<p>　　1. URL, 即http访问的地址</p>
<p>　　2. request method, 报文的请求方式</p>
<p>　　3. status code, 状态码以及状态短语</p>
<p>　　4. Accept Encoding, 内容编码</p>
<p>　　5. Connection, 连接方式</p>
<p>　　6. Cookie, 添加的cookie内容</p>
<p>　　7. Host, 目标主机</p>
<p>　　8. User-Agent, 客户端浏览器的相关信息</p>
<p>　　9. Set-Cookie, 指定想要在Cookie中保存的内容</p>
<h6 id="响应报文格式："><a href="#响应报文格式：" class="headerlink" title="响应报文格式："></a><strong><font color="#FF7256">响应报文格式：</font></strong></h6><p><img src="http://storage1.imgchr.com/images/0a06851c68245583.png" alt="enter image description here"></p>
<p>在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。</p>
<h6 id="Header"><a href="#Header" class="headerlink" title="Header"></a><strong><font color="#FF7256">Header</font></strong></h6><p> <strong><font color="#FF7256">HTTP 首部字段结构：</font></strong></p>
<p>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“：” 分隔。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">首部字段名: 字段值</div></pre></td></tr></table></figure></p>
<p>例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Type</span>: text/html</div></pre></td></tr></table></figure></p>
<p>就以上述示例来看，首部字段名为 Content-Type，字符串 text/html 是字段值。</p>
<p>另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Keep-Alive</span>: timeout=15, max=100</div></pre></td></tr></table></figure></p>
<p>若HTTP首部字段重复了会如何？当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？</p>
<blockquote>
<p><strong><font color="#FF7256">这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。</font></strong></p>
</blockquote>
<p>Header可用于传递一些附加信息，格式： 键（Key）: 值（Value），注意冒号后面有一个空格！如：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Length</span>: 1024</div><div class="line"><span class="attribute">Content-Type</span>: text/plain</div></pre></td></tr></table></figure></p>
<p> <strong><font color="#FF7256">4种 HTTP 首部字段类型</font></strong></p>
<p>HTTP 首部字段根据实际用途被分为以下 4 种类型：</p>
<p><strong><font color="#FF7256">通用首部字段（General Header Fields）</font></strong></p>
<p>请求报文和响应报文两方都会使用的首部。</p>
<p><strong><font color="#FF7256">请求首部字段（Request Header Fields）</font></strong></p>
<p>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p>
<p><strong><font color="#FF7256">响应首部字段（Response Header Fields）</font></strong></p>
<p>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p>
<p><strong><font color="#FF7256">实体首部字段（Entity Header Fields）</font></strong></p>
<p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p>
<p> <strong><font color="#FF7256">通用Header字段</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">控制缓存的行为</td>
</tr>
<tr>
<td style="text-align:center">Connection</td>
<td style="text-align:center">逐跳首部、连接的管理</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">创建报文的日期时间</td>
</tr>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">报文指令</td>
</tr>
<tr>
<td style="text-align:center">Trailer</td>
<td style="text-align:center">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:center">Transfer-Encoding</td>
<td style="text-align:center">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td style="text-align:center">Upgrade</td>
<td style="text-align:center">升级为其他协议</td>
</tr>
<tr>
<td style="text-align:center">Via</td>
<td style="text-align:center">代理服务器的相关信息</td>
</tr>
<tr>
<td style="text-align:center">Warning</td>
<td style="text-align:center">错误通知</td>
</tr>
</tbody>
</table>
<p> <strong><font color="#FF7256">请求Header字段</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept</td>
<td style="text-align:center">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Accept-Charset</td>
<td style="text-align:center">优先的字符集</td>
</tr>
<tr>
<td style="text-align:center">Accept-Encoding</td>
<td style="text-align:center">优先的内容编码</td>
</tr>
<tr>
<td style="text-align:center">Accept-Language</td>
<td style="text-align:center">优先的语言（自然语言）</td>
</tr>
<tr>
<td style="text-align:center">Authorization    Web</td>
<td style="text-align:center">认证信息</td>
</tr>
<tr>
<td style="text-align:center">Expect</td>
<td style="text-align:center">期待服务器的特定行为</td>
</tr>
<tr>
<td style="text-align:center">From</td>
<td style="text-align:center">用户的电子邮箱地址</td>
</tr>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center">请求资源所在服务器</td>
</tr>
<tr>
<td style="text-align:center">If-Match</td>
<td style="text-align:center">比较实体标记（ETag）</td>
</tr>
<tr>
<td style="text-align:center">If-Modified-Since</td>
<td style="text-align:center">比较资源的更新时间</td>
</tr>
<tr>
<td style="text-align:center">If-None-Match</td>
<td style="text-align:center">比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td style="text-align:center">If-Range</td>
<td style="text-align:center">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td style="text-align:center">If-Unmodified-Since</td>
<td style="text-align:center">比较资源的更新时间（与If-Modified-Since相反）</td>
</tr>
<tr>
<td style="text-align:center">Max-Forwards</td>
<td style="text-align:center">最大传输逐跳数</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authorization</td>
<td style="text-align:center">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:center">Range</td>
<td style="text-align:center">实体的字节范围请求</td>
</tr>
<tr>
<td style="text-align:center">Referer</td>
<td style="text-align:center">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td style="text-align:center">TE</td>
<td style="text-align:center">传输编码的优先级</td>
</tr>
<tr>
<td style="text-align:center">User-Agent</td>
<td style="text-align:center">HTTP 客户端程序的信息</td>
</tr>
</tbody>
</table>
<p> <strong><font color="#FF7256">响应首部字段</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept-Ranges</td>
<td style="text-align:center">是否接受字节范围请求</td>
</tr>
<tr>
<td style="text-align:center">Age</td>
<td style="text-align:center">推算资源创建经过时间</td>
</tr>
<tr>
<td style="text-align:center">ETag</td>
<td style="text-align:center">资源的匹配信息</td>
</tr>
<tr>
<td style="text-align:center">Location</td>
<td style="text-align:center">令客户端重定向至指定URI</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authenticate</td>
<td style="text-align:center">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:center">Retry-After</td>
<td style="text-align:center">对再次发起请求的时机要求</td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center">HTTP服务器的安装信息</td>
</tr>
<tr>
<td style="text-align:center">Vary</td>
<td style="text-align:center">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td style="text-align:center">WWW-Authenticate</td>
<td style="text-align:center">服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<p><strong><font color="#FF7256">实体首部字段</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Allow</td>
<td style="text-align:center">资源可支持的HTTP方法</td>
</tr>
<tr>
<td style="text-align:center">Content-Encoding</td>
<td style="text-align:center">实体主体适用的编码方式</td>
</tr>
<tr>
<td style="text-align:center">Content-Language</td>
<td style="text-align:center">实体主体的自然语言</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td style="text-align:center">Content-Location</td>
<td style="text-align:center">替代对应资源的URI</td>
</tr>
<tr>
<td style="text-align:center">Content-MD5</td>
<td style="text-align:center">实体主体的报文摘要</td>
</tr>
<tr>
<td style="text-align:center">Content-Range</td>
<td style="text-align:center">实体主体的位置范围</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">实体主体的媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center">实体主体过期的日期时间</td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center">资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<p><strong><font color="#FF7256">非 HTTP/1.1 首部字段</font></strong></p>
<p>在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高。</p>
<p>这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。</p>
<p><strong><font color="#FF7256">End-to-end 首部和 Hop-by-hop 首部</font></strong></p>
<p>HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型。</p>
<p><strong><font color="#FF7256">端到端首部（End-to-end Header）</font></strong></p>
<p>分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p>
<p><strong><font color="#FF7256">逐跳首部（Hop-by-hop Header）</font></strong></p>
<p>分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。</p>
<p>下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外，其他所有字段都属于端到端首部。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection，Keep-Alive，Proxy-Authenticate，Proxy-Authorization，Trailer，TE，Transfer-Encoding，Upgrade</span></div></pre></td></tr></table></figure></p>
<h6 id="通用首部字段（HTTP-1-1）"><a href="#通用首部字段（HTTP-1-1）" class="headerlink" title=" 通用首部字段（HTTP/1.1）"></a><strong><font color="#FF7256"> 通用首部字段（HTTP/1.1）</font></strong></h6><p><strong><font color="#FF7256">A. Cache-Control</font></strong></p>
<p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p>
<p>指令的参数是可选的，多个指令之间通过“，”分隔。首部字段 Cache-Control 的指令可用于请求及响应时。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: private, max-age=0, no-cache</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">a. Cache-Control指令</font></strong></p>
<p><strong><font color="#FF7256">1. 缓存请求指令</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">no-cache</td>
<td style="text-align:center">无</td>
<td>强制向源服务器再次验证</td>
</tr>
<tr>
<td style="text-align:center">no-store</td>
<td style="text-align:center">无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td style="text-align:center">max-age = [ 秒]</td>
<td style="text-align:center">必需</td>
<td>响应的最大Age值</td>
</tr>
<tr>
<td style="text-align:center">max-stale( = [ 秒])</td>
<td style="text-align:center">可省略</td>
<td>接收已过期的响应</td>
</tr>
<tr>
<td style="text-align:center">min-fresh = [ 秒]</td>
<td style="text-align:center">必需</td>
<td>期望在指定时间内的响应仍有效</td>
</tr>
<tr>
<td style="text-align:center">no-transform</td>
<td style="text-align:center">无</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td style="text-align:center">only-if-cached</td>
<td style="text-align:center">无</td>
<td>从缓存获取资源</td>
</tr>
<tr>
<td style="text-align:center">cache-extension</td>
<td style="text-align:center">-</td>
<td>新指令标记（token）</td>
</tr>
</tbody>
</table>
<p><strong><font color="#FF7256">2. 缓存响应指令</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">无</td>
<td>可向任意方提供响应的缓存</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">可省略</td>
<td>仅向特定用户返回响应</td>
</tr>
<tr>
<td style="text-align:center">no-cache</td>
<td style="text-align:center">可省略</td>
<td>缓存前必须先确认其有效性</td>
</tr>
<tr>
<td style="text-align:center">no-store</td>
<td style="text-align:center">无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td style="text-align:center">no-transform</td>
<td style="text-align:center">无</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td style="text-align:center">must-revalidate</td>
<td style="text-align:center">无</td>
<td>可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td style="text-align:center">proxy-revalidate</td>
<td style="text-align:center">无</td>
<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td style="text-align:center">max-age = [ 秒]</td>
<td style="text-align:center">必需</td>
<td>响应的最大Age值</td>
</tr>
<tr>
<td style="text-align:center">s-maxage = [ 秒]</td>
<td style="text-align:center">必需</td>
<td>公共缓存服务器响应的最大Age值</td>
</tr>
<tr>
<td style="text-align:center">cache-extension</td>
<td style="text-align:center">-</td>
<td>新指令标记（token）</td>
</tr>
</tbody>
</table>
<p> <strong><font color="#FF7256">b. 表示是否能缓存的指令</font></strong></p>
<p> <strong><font color="#FF7256">1. public 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: public</div></pre></td></tr></table></figure></p>
<p>当指定使用 public 指令时，则明确表明其他用户也可利用缓存。</p>
<p> <strong><font color="#FF7256">2. private 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: private</div></pre></td></tr></table></figure></p>
<p>当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。</p>
<p>缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p>
<p><strong><font color="#FF7256">3. no-cache 指令</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: no-cache</div></pre></td></tr></table></figure>
<p>使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。</p>
<p>客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。</p>
<p>如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: no-cache=Location</div></pre></td></tr></table></figure>
<p>由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。</p>
<p>控制可执行缓存的对象的指令</p>
<p><strong><font color="#FF7256">4. no-store 指令</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: no-store</div></pre></td></tr></table></figure>
<p>当使用 no-store 指令 1 时，暗示请求（和对应的响应）或响应中包含机密信息。</p>
<p>1 从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-not-serve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存，请读者注意区别理解。——译者注</p>
<p>因此，该指令规定缓存不能在本地存储请求或响应的任一部分。</p>
<p>指定缓存期限和认证的指令</p>
<p><strong><font color="#FF7256">5. s-maxage 指令</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: s-maxage=604800（单位 ：s秒）</div></pre></td></tr></table></figure>
<p>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器 （这里一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。</p>
<p>另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。</p>
<p><strong><font color="#FF7256">6. max-age 指令</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: max-age=604800（单位：秒）</div></pre></td></tr></table></figure>
<p>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。</p>
<p>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。</p>
<p>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略掉。</p>
<p><strong><font color="#FF7256">7. min-fresh 指令</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: min-fresh=60（单位：秒）</div></pre></td></tr></table></figure>
<p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。</p>
<p>比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响应返回了。</p>
<p><strong><font color="#FF7256">8. max-stale 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: max-stale=3600（单位：秒）</div></pre></td></tr></table></figure></p>
<p>使用 max-stale 可指示缓存资源，即使过期也照常接收。</p>
<p>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。</p>
<p><strong><font color="#FF7256">9. only-if-cached 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: only-if-cached</div></pre></td></tr></table></figure></p>
<p>使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。</p>
<p><strong><font color="#FF7256">10. must-revalidate 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: must-revalidate</div></pre></td></tr></table></figure></p>
<p>使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。</p>
<p>若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条504（Gateway Timeout）状态码。</p>
<p>另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale，也不会再有效果）。</p>
<p><strong><font color="#FF7256">11. proxy-revalidate 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: proxy-revalidate</div></pre></td></tr></table></figure></p>
<p>proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p>
<p><strong><font color="#FF7256">12. no-transform 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: no-transform</div></pre></td></tr></table></figure></p>
<p>使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。</p>
<p>这样做可防止缓存或代理压缩图片等类似操作。</p>
<p><strong><font color="#FF7256">c. Cache-Control 扩展</font></strong></p>
<p><strong><font color="#FF7256">cache-extension token</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: private, community="UCI"</div></pre></td></tr></table></figure></p>
<p>通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。</p>
<p>如上例，Cache-Control 首部字段本身没有 community 这个指令。借助 extension tokens 实现了该指令的添加。如果缓存服务器不能理解 community 这个新指令，就会直接忽略。因此，extension tokens 仅对能理解它的缓存服务器来说是有意义的。</p>
<p><strong><font color="#FF7256">B. Connection</font></strong></p>
<p>Connection 首部字段具备如下两个作用：</p>
<ol>
<li>控制不再转发给代理的首部字段；</li>
<li>管理持久连接。</li>
</ol>
<p><strong><font color="#FF7256">a. 控制不再转发给代理的首部字段：</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection</span>: 不再转发的首部字段名</div></pre></td></tr></table></figure></p>
<p>在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。</p>
<p><strong><font color="#FF7256">b. 管理持久连接：</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection</span>: close</div></pre></td></tr></table></figure></p>
<p>HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection</span>: Keep-Alive</div></pre></td></tr></table></figure></p>
<p>HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。</p>
<p>如上图①所示，客户端发送请求给服务器时，服务器端会像上图②那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回响应。（后补图）</p>
<p><strong><font color="#FF7256">C. Date</font></strong></p>
<p>首部字段 Date 表明创建 HTTP 报文的日期和时间。</p>
<p>HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式，如下所示：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Date</span>: Tue, 03 Jul 2016 04:40:59 GMT</div></pre></td></tr></table></figure></p>
<p>之前的 HTTP 协议版本中使用在 RFC850 中定义的格式，如下所示：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Date</span>: Tue, 03-Jul-16 04:40:59 GMT</div></pre></td></tr></table></figure></p>
<p>除此之外，还有一种格式。它与 C 标准库内的 asctime() 函数的输出格式一致：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Date</span>: Tue Jul 03 04:40:59 2016</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">D. Pragma</font></strong></p>
<p>Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。</p>
<p>规范定义的形式唯一<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Pragma</span>: no-cache</div></pre></td></tr></table></figure></p>
<p>该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。</p>
<p>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: no-cache</div><div class="line"><span class="attribute">Pragma</span>: no-cache</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">E. Trailer</font></strong></p>
<p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Tue, 03 Jul 2016 04:40:56 GMT</div><div class="line">Content-Type: text/html</div><div class="line">...</div><div class="line">Transfer-Encoding: chunked</div><div class="line">Trailer: Expires</div><div class="line"></div><div class="line">...(报文主体)...</div><div class="line">0</div><div class="line">Expires: Tue, 8 Sep 2016 23:59:59 GMT</div></pre></td></tr></table></figure></p>
<p>以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后（分块长度 0 之后）出现了首部字段 Expires。</p>
<p><strong><font color="#FF7256">F. Transfer-Encoding</font></strong></p>
<p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。</p>
<p>HTTP/1.1 的传输编码方式仅对分块传输编码有效。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">200</span> OK</div><div class="line"><span class="attribute">Date</span>: Tue, 03 Jul 2016 04:40:56 GMT</div><div class="line"><span class="attribute">Cache-Control</span>: public, max-age=604800</div><div class="line"><span class="attribute">Content-Type</span>: text/javascript; charset=utf-8</div><div class="line"><span class="attribute">Expires</span>: Tue, 10 Jul 2012 04:40:56 GMT</div><div class="line"><span class="attribute">X-Frame-Options</span>: DENY</div><div class="line"><span class="attribute">X-XSS-Protection</span>: 1; mode=block</div><div class="line"><span class="attribute">Content-Encoding</span>: gzip</div><div class="line"><span class="attribute">Transfer-Encoding</span>: chunked</div><div class="line"><span class="attribute">Connection</span>: keep-alive</div><div class="line"></div><div class="line"><span class="undefined">cf0    ←16进制(10进制为3312)</span></div><div class="line"></div><div class="line">...3312字节分块数据...</div><div class="line"></div><div class="line">392    ←16进制(10进制为914)</div><div class="line"></div><div class="line">...914字节分块数据...</div><div class="line"></div><div class="line">0</div></pre></td></tr></table></figure></p>
<p>以上用例中，正如在首部字段 Transfer-Encoding 中指定的那样，有效使用分块传输编码，且分别被分成 3312 字节和 914 字节大小的分块数据。</p>
<p><strong><font color="#FF7256">G. Upgrade</font></strong></p>
<p>首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p>
<p><img src="http://storage1.imgchr.com/images/upgrade.png" alt="enter image description here"></p>
<p>上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务器之间。因此，使用首部字段 Upgrade 时，还需要额外指定 Connection:Upgrade。</p>
<p>对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。</p>
<p><strong><font color="#FF7256">H. Via</font></strong></p>
<p>使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。</p>
<p>报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。</p>
<p>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。</p>
<p><img src="http://storage1.imgchr.com/images/Via.png" alt="enter image description here"></p>
<p>上图用例中，在经过代理服务器 A 时，Via 首部附加了“1.0 gw.hackr.jp (Squid/3.1)”这样的字符串值。行头的 1.0 是指接收请求的服务器上应用的 HTTP 协议版本。接下来经过代理服务器 B 时亦是如此，在 Via 首部附加服务器信息，也可增加 1 个新的 Via 首部写入服务器信息。</p>
<p>Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使用。比如，代理服务器接收到由 TRACE 方法发送过来的请求（其中 Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况下，代理服务器会将自身的信息附加到 Via 首部后，返回该请求的响应。</p>
<p><strong><font color="#FF7256">I. Warning</font></strong></p>
<p>HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Warning</span>: 113 gw.hackr.jp:8080 "Heuristic expiration" Tue, 03 Jul 2012 05:09:44 GMT</div></pre></td></tr></table></figure></p>
<p>Warning 首部的格式如下。最后的日期时间部分可省略。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Warning</span>: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])</div></pre></td></tr></table></figure></p>
<p>HTTP/1.1 中定义了 7 种警告。警告码对应的警告内容仅推荐参考。另外，警告码具备扩展性，今后有可能追加新的警告码。</p>
<p>HTTP/1.1 警告码如下图：</p>
<table>
<thead>
<tr>
<th style="text-align:center">警告码</th>
<th style="text-align:center">警告内容</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">110</td>
<td style="text-align:center">Response is stale （响应已过期）</td>
<td style="text-align:center">代理返回已过期的资源</td>
</tr>
<tr>
<td style="text-align:center">111</td>
<td style="text-align:center">Revalidation failed（再验证失败）</td>
<td style="text-align:center">代理再验证资源有效性时失败 （服务器无法到达等原因）</td>
</tr>
<tr>
<td style="text-align:center">112</td>
<td style="text-align:center">Disconnection operation（断开连接操作）</td>
<td style="text-align:center">代理与互联网连接被故意切断</td>
</tr>
<tr>
<td style="text-align:center">113</td>
<td style="text-align:center">Heuristic expiration（试探性过期）</td>
<td style="text-align:center">响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）</td>
</tr>
<tr>
<td style="text-align:center">199</td>
<td style="text-align:center">Miscellaneous warning（杂项警告）</td>
<td style="text-align:center">任意的警告内容</td>
</tr>
<tr>
<td style="text-align:center">214</td>
<td style="text-align:center">Transformation applied（使用了转换）</td>
<td style="text-align:center">代理对内容编码或媒体类型等执行了某些处理时</td>
</tr>
<tr>
<td style="text-align:center">299</td>
<td style="text-align:center">Miscellaneous persistent warning（持久杂项警告）</td>
<td style="text-align:center">任意的警告内容</td>
</tr>
</tbody>
</table>
<h6 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a><strong><font color="#FF7256">请求首部字段</font></strong></h6><p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p>
<p><strong><font color="#FF7256">A. Accept</font></strong></p>
<p><img src="http://storage1.imgchr.com/images/Accept.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div></pre></td></tr></table></figure></p>
<p>上述表示览器支持的 MIME 类型分别是 text/html、application/xhtml+xml、application/xml 和 <em>/</em>，优先顺序是它们从左到右的排列顺序。</p>
<p><strong><font color="#FF7256">详解：</font></strong></p>
<p>　　Accept表示浏览器支持的 MIME 类型；<br>　　<br>　　MIME的英文全称是 Multipurpose Internet Mail Extensions（多功能 Internet 邮件扩充服务），它是一种多用途网际邮件扩充协议，在1992年最早应用于电子邮件系统，但后来也应用到浏览器。<br>　　<br>　　text/html,application/xhtml+xml,application/xml 都是 MIME 类型，也可以称为媒体类型和内容类型，斜杠前面的是 type（类型），斜杠后面的是 subtype（子类型）；type 指定大的范围，subtype 是 type 中范围更明确的类型，即大类中的小类。<br>　　<br>　　Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；<br>　　<br>　　text/html表示 html 文档；<br>　　<br>　　Application：用于传输应用程序数据或者二进制数据；<br>　　<br>　　application/xhtml+xml表示 xhtml 文档；<br>　　<br>　　application/xml表示 xml 文档。</p>
<p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。</p>
<p><strong><font color="#FF7256">文本文件</font></strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">text/plain，text/html，text/css ...</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">application/xhtml+xml, application/xml ...</div></pre></td></tr></table></figure>
<p><strong><font color="#FF7256">图片文件</font></strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">image/jpeg, image/gif, image/png ...</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">视频文件</font></strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">video/mpeg, video/quicktime，meaudio/mp4，video/mp4 ...</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">应用程序使用的二进制文件</font></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">application/octet-stream, application/zip ...</div></pre></td></tr></table></figure>
<p>比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定 image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。</p>
<p>若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示<strong><font color="#FF7256">权重值</font></strong> ，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。</p>
<p><strong><font color="#FF7256">权重值</font></strong>原文是“品質係数”。在 RFC2616 定义中，此处的 q 是指 qvalue，即 quality factor。直译的话就是质量数，但经过综合考虑理解记忆的便利性后，似乎采用权重值更为稳妥。</p>
<p>当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。</p>
<p><strong><font color="#FF7256">B. Accept-Charset</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Charset</span>: GB2312,utf-8;q=0.7,*;q=0.7</div></pre></td></tr></table></figure></p>
<p>上述表示浏览器支持的字符编码分别是 GB2312、utf-8 和任意字符，优先顺序是 GB2312、utf-8、*。</p>
<p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。</p>
<p>该首部字段应用于内容协商机制的服务器驱动协商。</p>
<p><strong><font color="#FF7256">详解：</font></strong></p>
<p>　　Accept-Charset告诉 Web 服务器，浏览器可以接受哪些字符编码；<br>　　<br>　　GB2312是中国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312 编码通行于中国大陆；新加坡等地也采用此编码。<br>　　<br>　　utf-8是 Unicode 的一种变长字符编码又称万国码，由 Ken Thompson 于1992年创建，现在已经标准化为 RFC 3629。<br>　　<br>　　<strong><font color="#FF7256">* </font></strong>表示任意字符编码，虽然 q 都是等于 0.7，但明确指定的 GB2312,utf-8 比 * 具有更高的优先级。</p>
<p><strong><font color="#FF7256">C. Accept-Encoding</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</div></pre></td></tr></table></figure></p>
<p>上述表示浏览器支持的压缩编码是 gzip 和 deflate。</p>
<p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。</p>
<p><strong><font color="#FF7256">详解：</font></strong></p>
<p>　　Accept-Encoding表示浏览器有能力解码的编码类型；<br>　　<br>　　gzip是 GNU zip 的缩写，它是一个 GNU 自由软件的文件压缩程序，也经常用来表示 gzip 这种文件格式。<br>　　　　<br>　　deflate是同时使用了 LZ77 算法与哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。<br>　　<br><strong><font color="#FF7256">gzip</font></strong></p>
<p>由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，通称 CRC）。</p>
<p><strong><font color="#FF7256">compress</font></strong></p>
<p>由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel-Ziv-Welch 算法（LZW）。</p>
<p><strong><font color="#FF7256">deflate</font></strong></p>
<p>组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式。</p>
<p><strong><font color="#FF7256">identity</font></strong></p>
<p>不执行压缩或不会变化的默认编码格式。</p>
<p><strong><font color="#FF7256">D. Accept-Language</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Language</span>: zh-cn,zh;q=0.7,en-us,en;q=0.3</div></pre></td></tr></table></figure></p>
<p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。</p>
<p>和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在上述图例中，客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Language</span>: zh-cn,zh;q=0.5</div></pre></td></tr></table></figure>
<p>上述表示浏览器支持的语言分别是中文和简体中文，优先支持简体中文。<br>　　<br>　　<strong><font color="#FF7256">详解：</font></strong><br>　　<br>　　Accept-Language表示浏览器所支持的语言类型；<br>　　<br>　　zh-cn表示简体中文；zh 表示中文；<br>　　<br>　　q是权重系数，范围 0 =&lt; q &lt;= 1，q 值越大，请求越倾向于获得其“;”之前的类型表示的内容，若没有指定 q 值，则默认为1，若被赋值为0，则用于提醒服务器哪些是浏览器不接受的内容类型。</p>
<p><strong><font color="#FF7256">E. Authorization</font></strong></p>
<p><img src="http://storage1.imgchr.com/images/Authorization.png" alt="enter image description here"></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Authorization</span>: Basic dWVub3NlbjpwYXNzd29yZA==</div></pre></td></tr></table></figure>
<p>首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。读者也可参阅 RFC2616。</p>
<p><strong><font color="#FF7256">F. Expect</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Expect</span>: 100-continue</div></pre></td></tr></table></figure></p>
<p>客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。</p>
<p>客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规范只定义了 100-continue（状态码 100 Continue 之意）。</p>
<p>等待状态码 100 响应的客户端在发生请求时，需要指定 Expect:100-continue。</p>
<p><strong><font color="#FF7256">G. From</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">From：info@hackr.jp</span></div></pre></td></tr></table></figure></p>
<p>首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。</p>
<p><strong><font color="#FF7256">H. Host</font></strong></p>
<p><img src="http://storage1.imgchr.com/images/HOST.png" alt="enter image description here"></p>
<p>虚拟主机运行在同一个 IP 上，因此使用首部字段 Host 加以区分<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Host</span>: www.hackr.jp</div></pre></td></tr></table></figure></p>
<p>首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。</p>
<p>首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段 Host 必须存在的意义。</p>
<p>请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段 Host 来明确指出请求的主机名。若服务器未设定主机名，那直接发送一个空值即可。如下所示。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Host:</span></div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">I. If-Match</font></strong></p>
<p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p>
<p><img src="http://storage2.imgchr.com/If-Match.png" alt="enter image description here"></p>
<p>只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">If-Match</span>: "Orz-God"</div></pre></td></tr></table></figure>
<p>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。（请参照本章有关首部字段 ETag 的说明）</p>
<p>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。</p>
<p>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。</p>
<p><strong><font color="#FF7256">J. If-Modified-Since</font></strong></p>
<p><img src="http://storage1.imgchr.com/images/If-Modified-Since.png" alt="enter image description here"></p>
<p>如果在 If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">If-Modified-Since</span>: Thu, 25 Apr 2016 00:00:00 GMT</div></pre></td></tr></table></figure>
<p>首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。</p>
<p>If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。</p>
<p><strong><font color="#FF7256">K. If-None-Match</font></strong></p>
<p><img src="http://storage1.imgchr.com/images/if-no-match.png" alt="enter image description here"></p>
<p>只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与 If-Match 首部字段的作用相反</p>
<p>首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。</p>
<p>在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此，这与使用首部字段 If-Modified-Since 时有些类似。</p>
<p><strong><font color="#FF7256">L. If-Range</font></strong></p>
<p><img src="http://storage2.imgchr.com/If-Range.png" alt="enter image description here"></p>
<p>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</p>
<p><img src="http://storage1.imgchr.com/images/If-Range1.png" alt="enter image description here"></p>
<p>下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。</p>
<p> <strong><font color="#FF7256">M. If-Unmodified-Since</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">If-Unmodified-Since</span>: Thu, 03 Jul 2016 00:00:00 GMT</div></pre></td></tr></table></figure></p>
<p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。</p>
<p> <strong><font color="#FF7256">N. Max-Forwards</font></strong></p>
<p><img src="http://storage2.imgchr.com/Max-Forwards1.png" alt="enter image description here"></p>
<p>每次转发数值减 1，当数值变 0 时返回响应。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Max-Forwards</span>: 2</div></pre></td></tr></table></figure></p>
<p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。</p>
<p>使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中，如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。</p>
<p>可以灵活使用首部字段 Max-Forwards，针对以上问题产生的原因展开调查。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。</p>
<p><img src="http://storage2.imgchr.com/Max-Forwards2.png" alt="enter image description here"></p>
<p>代理 B 到源服务器的请求失败了，但客户端不知道。</p>
<p> <strong><font color="#FF7256">O. Proxy-Authorization</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Proxy-Authorization</span>: Basic dGlwOjkpNLAGfFY5</div></pre></td></tr></table></figure></p>
<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。</p>
<p>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段Authorization 可起到相同作用。有关 HTTP 访问认证，后面的章节会作详尽阐述。</p>
<p> <strong><font color="#FF7256">P. Range</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Range</span>: bytes=5001-10000</div></pre></td></tr></table></figure></p>
<p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。</p>
<p>接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。</p>
<p><img src="http://storage1.imgchr.com/images/Max-Forwards3.png" alt="enter image description here"></p>
<p>由于未知原因，导致请求陷入代理之间的循环，但客户端不知道。</p>
<p> <strong><font color="#FF7256">Q. Referer</font></strong><br> <img src="http://storage2.imgchr.com/Referer.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Referer</span>: http://www.hackr.jp/index.htm</div></pre></td></tr></table></figure></p>
<p>首部字段 Referer 会告知服务器请求的原始资源的 URI。</p>
<p>客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。</p>
<p>因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。</p>
<p>另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直沿用这个错误的拼写。</p>
<p> <strong><font color="#FF7256">R. TE</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">TE</span>: gzip, deflate;q=0.5</div></pre></td></tr></table></figure></p>
<p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。</p>
<p>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">TE</span>: trailers</div></pre></td></tr></table></figure></p>
<p> <strong><font color="#FF7256">S. User-Agent</font></strong></p>
<p>User-Agent 用于传达浏览器的种类<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0)      Gecko/20100101 Firefox/13.0.1</div></pre></td></tr></table></figure></p>
<p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>
<p>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</p>
<h6 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a><strong><font color="#FF7256">响应首部字段</font></strong></h6><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p>
<p> <strong><font color="#FF7256">A. Accept-Ranges</font></strong></p>
<p>当不能处理范围请求时，Accept-Ranges: none<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Ranges</span>: bytes</div></pre></td></tr></table></figure></p>
<p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。</p>
<p>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。</p>
<p> <strong><font color="#FF7256">B. Age</font></strong><br> <img src="http://storage1.imgchr.com/images/AGE.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Age</span>: 600</div></pre></td></tr></table></figure></p>
<p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</p>
<p>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。</p>
<p> <strong><font color="#FF7256">C. ETag</font></strong><br> <img src="http://storage2.imgchr.com/ETag.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ETag</span>: "82e22293907ce725faf67773957acd12"</div></pre></td></tr></table></figure></p>
<p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</p>
<p>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。</p>
<p><img src="http://storage1.imgchr.com/images/ETag1.png" alt="enter image description here"></p>
<p>资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览器访问 <a href="http://www.google.com/" target="_blank" rel="external">http://www.google.com/</a> 时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的 URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。</p>
<p> <strong><font color="#FF7256">强 ETag 值和弱 Tag 值：</font></strong></p>
<p>ETag 中有强 ETag 值和弱 ETag 值之分。</p>
<p> <strong><font color="#FF7256">强 ETag 值</font></strong></p>
<p>强 ETag 值，不论实体发生多么细微的变化都会改变其值。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ETag</span>: "usagi-orz"</div></pre></td></tr></table></figure></p>
<p> <strong><font color="#FF7256">弱 ETag 值</font></strong></p>
<p>弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ETag</span>: W/"usagi-orz"</div></pre></td></tr></table></figure></p>
<p> <strong><font color="#FF7256">D. Location</font></strong><br><img src="http://storage2.imgchr.com/location1.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Location</span>: http://www.usagidesign.jp/sample.html</div></pre></td></tr></table></figure></p>
<p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</p>
<p>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。</p>
<p>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>
<p> <strong><font color="#FF7256">E. Proxy-Authenticate</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Proxy-Authenticate</span>: Basic realm="Usagidesign Auth"</div></pre></td></tr></table></figure></p>
<p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。</p>
<p>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时，首部字段 WWW-Authorization 有着相同的作用。有关 HTTP 访问认证，后面的章节会再进行详尽阐述。</p>
<p> <strong><font color="#FF7256">F. Retry-After</font></strong><br> <img src="http://storage1.imgchr.com/images/retry.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">etry-After</span>: 120</div></pre></td></tr></table></figure></p>
<p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。</p>
<p>字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数。</p>
<p> <strong><font color="#FF7256">G. Server</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Server</span>: Apache/2.2.17 (Unix)</div></pre></td></tr></table></figure></p>
<p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Server</span>: Apache/2.2.6 (Unix) PHP/5.2.5</div></pre></td></tr></table></figure></p>
<p> <strong><font color="#FF7256">H. Vary</font></strong></p>
<p>当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Vary</span>: Accept-Language</div></pre></td></tr></table></figure></p>
<p>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</p>
<p>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</p>
<p> <strong><font color="#FF7256">I. WWW-Authenticate</font></strong><br> <img src="http://storage1.imgchr.com/images/Vary.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">WWW-Authenticate</span>: Basic realm="Usagidesign Auth"</div></pre></td></tr></table></figure></p>
<p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。</p>
<p>上述示例中，realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。有关该首部，请参阅本章之后的内容。</p>
<h6 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a><strong><font color="#FF7256">实体首部字段</font></strong></h6><p><strong><font color="#FF7256">A. Allow</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Allow</span>: GET, HEAD</div></pre></td></tr></table></figure>
<p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。</p>
<p><strong><font color="#FF7256">B. Content-Encoding </font></strong></p>
<p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</p>
<p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。四中压缩方式：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Encoding</span>: gzip</div><div class="line"><span class="attribute">Content-Encoding</span>: compress</div><div class="line"><span class="attribute">Content-Encoding</span>: deflate</div><div class="line"><span class="attribute">Content-Encoding</span>: identity</div></pre></td></tr></table></figure></p>
<p>客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">C. Content-Language</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Language</span>: zh-CN</div></pre></td></tr></table></figure>
<p>首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p>
<p><strong><font color="#FF7256">D. Content-Length</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Length</span>: 2048</div></pre></td></tr></table></figure>
<p>首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。由于实体主体大小的计算方法略微复杂，所以在此不再展开。</p>
<p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。</p>
<p>上面代码告诉浏览器，本次回应的长度是2048个字节，后面的字节就属于下一个回应了。</p>
<p>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p>
<p><strong><font color="#FF7256">E. Content-Location</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Location</span></div></pre></td></tr></table></figure></p>
<p>Content-Location: <a href="http://www.hackr.jp/index-ja.html" target="_blank" rel="external">http://www.hackr.jp/index-ja.html</a><br>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p>
<p>比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段 Content-Location 内会写明 URI。（访问 <a href="http://www.hackr.jp/" target="_blank" rel="external">http://www.hackr.jp/</a> 返回的对象却是 <a href="http://www.hackr.jp/index-ja.html" target="_blank" rel="external">http://www.hackr.jp/index-ja.html</a> 等类似情况）</p>
<p><strong><font color="#FF7256">F. Content-MD5</font></strong><br><img src="http://storage2.imgchr.com/md5.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-MD5</span>: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</div></pre></td></tr></table></figure></p>
<p>客户端会对接收的报文主体执行相同的 MD5 算法，然后与首部字段 Content-MD5 的字段值比较</p>
<p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p>
<p>对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编码后将结果写入 Content-MD5 字段值。由于 HTTP 首部无法记录二进制值，所以要通过 Base64 编码处理。为确保报文的有效性，作为接收方的客户端会对报文主体再执行一次相同的 MD5 算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。</p>
<p>采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味着 Content-MD5 也可重新计算然后被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过的。</p>
<p><strong><font color="#FF7256">G. Content-Range</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Range</span>: bytes 5001-10000/10000</div></pre></td></tr></table></figure></p>
<p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p>
<p><strong><font color="#FF7256">H. Content-Type ：</font></strong></p>
<p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。</p>
<p> <strong><font color="#FF7256">常见的Content-Type字段的值：</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">text/plain，text/html，text/css</span></div></pre></td></tr></table></figure>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">image/jpeg，image/png，image/svg+xml</span></div></pre></td></tr></table></figure>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">audio/mp4，video/mp4</span></div></pre></td></tr></table></figure>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">application/javascript，application/pdf，application/zip，application/atom+xml</span></div></pre></td></tr></table></figure>
<p>这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。</p>
<p>除了预定义的类型，厂商也可以自定义类型。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">application/vnd.debian.binary-package</span></div></pre></td></tr></table></figure>
<p>上面的类型表明，发送的是Debian系统的二进制数据包。</p>
<p>MIME type还可以在尾部使用分号，添加参数。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</div></pre></td></tr></table></figure></p>
<p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p>
<p>客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept</span>: */*</div></pre></td></tr></table></figure>
<p>上面代码中，客户端声明自己可以接受任何格式的数据。</p>
<p>MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">I. Expires</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Expires</span>: Wed, 04 Jul 2016 08:00:00 GMT</div></pre></td></tr></table></figure></p>
<p>首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。</p>
<p>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。</p>
<p>但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。</p>
<p><strong><font color="#FF7256">J. Last-Modified</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Last-Modified</span>: Wed, 23 May 2016 10:05:24 GMT</div></pre></td></tr></table></figure>
<p>首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。</p>
<h6 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a><strong><font color="#FF7256">为 Cookie 服务的首部字段</font></strong></h6><p>管理服务器与客户端之间状态的 Cookie，虽然没有被编入标准化 HTTP/1.1 的 RFC2616 中，但在 Web 网站方面得到了广泛的应用。</p>
<p>Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。</p>
<p>调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他 Web 站点和攻击者的攻击而泄露。</p>
<p>Cookie 的规格标准文档有以下 4 种。</p>
<p><strong><font color="#FF7256">由网景公司颁布的规格标准</font></strong></p>
<p>网景通信公司设计并开发了 Cookie，并制定相关的规格标准。1994 年前后，Cookie 正式应用在网景浏览器中。目前最为普及的 Cookie 方式也是以此为基准的。</p>
<p><strong><font color="#FF7256">RFC2109</font></strong></p>
<p>某企业尝试以独立技术对 Cookie 规格进行标准化统筹。原本的意图是想和网景公司制定的标准交互应用，可惜发生了微妙的差异。现在该标准已淡出了人们的视线。</p>
<p><strong><font color="#FF7256">RFC2965</font></strong></p>
<p>为终结 Internet Explorer 浏览器与 Netscape Navigator 的标准差异而导致的浏览器战争，RFC2965 内定义了新的 HTTP 首部 Set-Cookie2 和 Cookie2。可事实上，它们几乎没怎么投入使用。</p>
<p><strong><font color="#FF7256">RFC6265</font></strong></p>
<p>将网景公司制定的标准作为业界事实标准（De facto standard），重新定义 Cookie 标准后的产物。</p>
<p>目前使用最广泛的 Cookie 标准却不是 RFC 中定义的任何一个。而是在网景公司制定的标准上进行扩展后的产物。</p>
<p>本节接下来就对目前使用最为广泛普及的标准进行说明。</p>
<p>下面的表格内列举了与 Cookie 有关的首部字段。</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Set-Cookie</td>
<td style="text-align:center">开始状态管理所使用的Cookie信息</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">Cookie</td>
<td style="text-align:center">服务器接收到的Cookie信息</td>
<td style="text-align:center">请求首部字段</td>
</tr>
</tbody>
</table>
<p><strong><font color="#FF7256">A. Set-Cookie</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Set-Cookie</span>: status=enable; expires=Tue, 05 Jul 2016 07:26:31 GMT; path=/; domain=.hackr.jp;</div></pre></td></tr></table></figure>
<p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</p>
<p>下面的表格列举了 Set-Cookie 的字段值。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NAME=VALUE</td>
<td style="text-align:center">赋予 Cookie 的名称和其值（必需项）</td>
</tr>
<tr>
<td style="text-align:center">expires=DATE</td>
<td style="text-align:center">Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td style="text-align:center">path=PATH</td>
<td style="text-align:center">将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td style="text-align:center">domain=域名</td>
<td style="text-align:center">作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名）</td>
</tr>
<tr>
<td style="text-align:center">Secure</td>
<td style="text-align:center">仅在 HTTPS 安全通信时才会发送 Cookie</td>
</tr>
<tr>
<td style="text-align:center">HttpOnly</td>
<td style="text-align:center">加以限制，使 Cookie 不能被 JavaScript 脚本访问</td>
</tr>
</tbody>
</table>
<p><strong><font color="#FF7256">expires 属性</font></strong></p>
<p>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。</p>
<p>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。</p>
<p>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</p>
<p><strong><font color="#FF7256">path 属性</font></strong></p>
<p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。</p>
<p><strong><font color="#FF7256">domain 属性</font></strong></p>
<p>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除 example.com 以外，www.example.com 或 www2.example.com 等都可以发送 Cookie。</p>
<p>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。</p>
<p><strong><font color="#FF7256">secure 属性</font></strong></p>
<p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。</p>
<p>发送 Cookie 时，指定 secure 属性的方法如下所示。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Set-Cookie</span>: name=value; secure</div></pre></td></tr></table></figure>
<p>以上例子仅当在 <a href="https://www.example.com/（HTTPS）安全连接的情况下才会进行" target="_blank" rel="external">https://www.example.com/（HTTPS）安全连接的情况下才会进行</a> Cookie 的回收。也就是说，即使域名相同，<a href="http://www.example.com/（HTTP）也不会发生" target="_blank" rel="external">http://www.example.com/（HTTP）也不会发生</a> Cookie 回收行为。</p>
<p>当省略 secure 属性时，不论 HTTP 还是 HTTPS，都会对 Cookie 进行回收。</p>
<p><strong><font color="#FF7256">HttpOnly 属性</font></strong></p>
<p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</p>
<p>发送指定 HttpOnly 属性的 Cookie 的方法如下所示。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Set-Cookie</span>: name=value; HttpOnly</div></pre></td></tr></table></figure>
<p>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。</p>
<p>虽然是独立的扩展功能，但 Internet Explorer 6 SP1 以上版本等当下的主流浏览器都已经支持该扩展了。另外顺带一提，该扩展并非是为了防止 XSS 而开发的。</p>
<p><strong><font color="#FF7256">B. Cookie</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cookie</span>: status=enable</div></pre></td></tr></table></figure></p>
<p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p>
<h6 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a><strong><font color="#FF7256">其他首部字段</font></strong></h6><p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。</p>
<p>接下来，我们就一些最为常用的首部字段进行说明。</p>
<p><strong><font color="#FF7256">X-Frame-Options</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">X-Frame-Options</span>: DENY</div></pre></td></tr></table></figure></p>
<p>首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</p>
<p>首部字段 X-Frame-Options 有以下两个可指定的字段值。</p>
<blockquote>
<p><strong><font color="#FF7256">DENY ：拒绝</font></strong><br><strong><font color="#FF7256">SAMEORIGIN ：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 <a href="http://hackr.jp/sample.html" target="_blank" rel="external">http://hackr.jp/sample.html</a> 页面为 SAMEORIGIN 时，那么 hackr.jp 上所有页面的 frame 都被允许可加载该页面，而 example.com 等其他域名的页面就不行了）</font></strong></p>
</blockquote>
<p>支持该首部字段的浏览器有：Internet Explorer 8、Firefox 3.6.9+、Chrome 4.1.249.1042+、Safari 4+ 和 Opera 10.50+ 等。现在主流的浏览器都已经支持。</p>
<p>能在所有的 Web 服务器端预先设定好 X-Frame-Options 字段值是最理想的状态。</p>
<p>对 apache2.conf 的配置实例<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">&lt;IfModule mod_headers.c&gt;</span></div><div class="line">   <span class="attribute"><span class="nomarkup">Header</span></span> append X-FRAME-OPTIONS <span class="string">"SAMEORIGIN"</span></div><div class="line"><span class="section">&lt;/IfModule&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">X-XSS-Protection</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">X-XSS-Protection</span>: 1</div></pre></td></tr></table></figure></p>
<p>首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。</p>
<p>首部字段 X-XSS-Protection 可指定的字段值如下。</p>
<p><strong><font color="#FF7256">0 ：将 XSS 过滤设置成无效状态</font></strong><br><strong><font color="#FF7256">1 ：将 XSS 过滤设置成有效状态</font></strong></p>
<p><strong><font color="#FF7256">DNT</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">DNT</span>: 1</div></pre></td></tr></table></figure></p>
<p>首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。</p>
<p>首部字段 DNT 可指定的字段值如下。</p>
<p><strong><font color="#FF7256">1 ：拒绝被追踪</font></strong><br><strong><font color="#FF7256">0 ：同意被追踪由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT 做对应的支持。</font></strong></p>
<p><strong><font color="#FF7256">P3P</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">P3P</span>: CP="CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND UNI COM NAV INT"</div></pre></td></tr></table></figure></p>
<p>首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</p>
<p>要进行 P3P 的设定，需按以下操作步骤进行:</p>
<ol>
<li><p>创建 P3P 隐私</p>
</li>
<li><p>创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml</p>
</li>
<li><p>从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</p>
</li>
</ol>
<p>有关 P3P 的详细规范标准请参看下方链接。</p>
<p><a href="http://www.w3.org/TR/P3P/" target="_blank" rel="external">The Platform for Privacy Preferences 1.0（P3P1.0）Specification</a></p>
<p>协议中对 X- 前缀的废除：</p>
<blockquote>
<p><strong><font color="#FF7256">在 HTTP 等多种协议中，通过给非标准参数加上前缀 X-，来区别于标准参数，并使那些非标准的参数作为扩展变成可能。但是这种简单粗暴的做法有百害而无一益，因此在“RFC 6648 - Deprecating the “X-“ Prefix and Similar Constructs in Application Protocols”中提议停止该做法。然而，对已经在使用中的 X- 前缀来说，不应该要求其变更。</font></strong></p>
</blockquote>
<p><strong><font color="#FF7256">Weakness：</font></strong></p>
<p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>
<p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p>
<p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection</span>: keep-alive</div></pre></td></tr></table></figure></p>
<p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。这样，一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
<h5 id="HTTP-1-1："><a href="#HTTP-1-1：" class="headerlink" title="HTTP/1.1："></a><strong><font color="#FF7256">HTTP/1.1：</font></strong></h5><p>它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。当前浏览器客户端与服务器端建立连接之后，可以在一次连接中发送多次请求（基本都使用1.1）。请求一次资源就会出现一次请求，比如三张图片，就有三次请求，如果图片是一样 的就只有一次请求。</p>
<h6 id="持久连接："><a href="#持久连接：" class="headerlink" title="持久连接："></a><strong><font color="#FF7256">持久连接：</font></strong></h6><p>HTTP/1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<font color="#FF7256">Connection: keep-alive</font>。</p>
<p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection</span>: close</div></pre></td></tr></table></figure></p>
<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>
<h6 id="管道机制："><a href="#管道机制：" class="headerlink" title="管道机制："></a><strong><font color="#FF7256">管道机制：</font></strong></h6><p>HTTP/1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h6 id="分块传输编码："><a href="#分块传输编码：" class="headerlink" title="分块传输编码："></a><strong><font color="#FF7256">分块传输编码：</font></strong></h6><p>使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>
<p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p>
<p>因此，1.1版规定可以不使用Content-Length字段，而使用“分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Transfer-Encoding</span>: chunked</div></pre></td></tr></table></figure></p>
<p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">200</span> OK</div><div class="line"><span class="attribute">Content-Type</span>: text/plain</div><div class="line"><span class="attribute">Transfer-Encoding</span>: chunked</div><div class="line"></div><div class="line"><span class="undefined">25</span></div><div class="line">This is the data in the first chunk</div><div class="line"></div><div class="line">1C</div><div class="line">and this is the second one</div><div class="line"></div><div class="line">3</div><div class="line">con</div><div class="line"></div><div class="line">8</div><div class="line">sequence</div><div class="line"></div><div class="line">0</div></pre></td></tr></table></figure></p>
<h6 id="其他功能："><a href="#其他功能：" class="headerlink" title="其他功能："></a><strong><font color="#FF7256">其他功能：</font></strong></h6><p>HTTP/1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p>
<p>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Host</span>: www.example.com</div></pre></td></tr></table></figure></p>
<p>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>
<h6 id="Weakness："><a href="#Weakness：" class="headerlink" title="Weakness："></a><strong><font color="#FF7256">Weakness：</font></strong></h6><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为“队头堵塞”（Head-of-line blocking）。</p>
<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>
<h5 id="SPDY协议："><a href="#SPDY协议：" class="headerlink" title="SPDY协议："></a><strong><font color="#FF7256">SPDY协议：</font></strong></h5><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p>
<p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。</p>
<p><strong><font color="#FF7256">SPDY 的设计与功能</font></strong> </p>
<p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。</p>
<p>SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、Cookie 以及 HTTP 报文等。</p>
<p><img src="http://storage2.imgchr.com/SPDY.png" alt="enter image description here"></p>
<p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p>
<p><strong><font color="#FF7256">1. 多路复用流</font></strong></p>
<p>通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。</p>
<p><strong><font color="#FF7256">2. 赋予请求优先级</font></strong></p>
<p>SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</p>
<p><strong><font color="#FF7256">3. 压缩 HTTP 首部</font></strong></p>
<p>压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。</p>
<p><strong><font color="#FF7256">4. 推送功能</font></strong></p>
<p>支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p>
<p><strong><font color="#FF7256">5. 服务器提示功能</font></strong></p>
<p>服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</p>
<p>希望使用 SPDY 时，Web 的内容端不必做什么特别改动，而 Web 浏览器及 Web 服务器都要为对应 SPDY 做出一定程度上的改动。有好几家 Web 浏览器已经针对 SPDY 做出了相应的调整。另外，Web 服务器也进行了实验性质的应用，但把该技术导入实际的 Web 网站却进展不佳。</p>
<p>因为 SPDY 基本上只是将单个域名（ IP 地址）的通信多路复用，所以当一个 Web 网站上使用多个域名下的资源，改善效果就会受到限制。</p>
<p>SPDY 的确是一种可有效消除 HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所导致。对 Web 本身的速度提升，还应该从其他可细致钻研的地方入手，比如改善 Web 内容的编写方式等。</p>
<h5 id="HTTP-2："><a href="#HTTP-2：" class="headerlink" title="HTTP/2："></a><strong><font color="#FF7256">HTTP/2：</font></strong></h5><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本，下一个新版本将是 HTTP/3。性能更快更强是肯定的，还针对移动端做了优化，WebSocket,全双工通信标准，客户端服务端互发。</p>
<p><strong><font color="#FF7256">HTTP/2.0 的特点</font></strong></p>
<p>HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验。由于基本上都会先通过 HTTP/1.1 与 TCP 连接，现在我们以下面的这些协议为基础，探讨一下它们的实现方法。</p>
<blockquote>
<p><strong><font color="#FF7256">SPDY、HTTP Speed ＋ Mobility、Network-Friendly HTTP Upgrade</font></strong></p>
</blockquote>
<p>HTTP Speed ＋ Mobility 由微软公司起草，是用于改善并提高移动端通信时的通信速度和性能的标准。它建立在 Google 公司提出的 SPDY 与 WebSocket 的基础之上。</p>
<p>Network-Friendly HTTP Upgrade 主要是在移动端通信时改善 HTTP 性能的标准。</p>
<p>HTTP/2.0 的 7 项技术及讨论</p>
<p>HTTP/2.0 围绕着主要的 7 项技术进行讨论，现阶段（2012 年 8 月 13 日），大都倾向于采用以下协议的技术。但是，讨论仍在持续，所以不能排除会发生重大改变的可能性。</p>
<table>
<thead>
<tr>
<th style="text-align:center">技术</th>
<th style="text-align:center">method</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">压缩</td>
<td style="text-align:center">SPDY、Friendly</td>
</tr>
<tr>
<td style="text-align:center">多路复用</td>
<td style="text-align:center">SPDY</td>
</tr>
<tr>
<td style="text-align:center">TLS 义务化</td>
<td style="text-align:center">Speed＋ Mobility</td>
</tr>
<tr>
<td style="text-align:center">协商</td>
<td style="text-align:center">Speed＋ Mobility，Friendly</td>
</tr>
<tr>
<td style="text-align:center">客户端拉曳（Client Pull）/服务器推送（Server Push）</td>
<td style="text-align:center">Speed＋ Mobility</td>
</tr>
<tr>
<td style="text-align:center">流量控制</td>
<td style="text-align:center">SPDY</td>
</tr>
<tr>
<td style="text-align:center">WebSocket</td>
<td style="text-align:center">Speed＋ Mobility</td>
</tr>
</tbody>
</table>
<p>注：HTTP Speed ＋ Mobility 简写为 Speed ＋ Mobility，Network-Friendly HTTP Upgrade 简写为 Friendly。</p>
<p><strong><font color="#FF7256">使用浏览器进行全双工通信的 WebSocket</font></strong></p>
<p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket 网络技术正是为解决这些问题而实现的一套新协议及 API。</p>
<p>当时筹划将 WebSocket 作为 HTML5 标准的一部分，而现在它却逐渐变成了独立的协议标准。WebSocket 通信协议在 2011 年 12 月 11 日，被 RFC 6455 - The WebSocket Protocol 定为标准。</p>
<p><strong><font color="#FF7256">WebSocket 的设计与功能</font></strong></p>
<p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。其中，WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。仍在开发中的 WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。</p>
<p><strong><font color="#FF7256">WebSocket 协议</font></strong></p>
<p>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。</p>
<p>由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p>
<p>下面我们列举一下 WebSocket 协议的主要特点。</p>
<p><strong><font color="#FF7256">推送功能</font></strong></p>
<p>支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p>
<p><strong><font color="#FF7256">减少通信量</font></strong></p>
<p>只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。</p>
<p>为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次“握手”（Handshaking）的步骤。</p>
<ol>
<li>握手·请求</li>
</ol>
<p>为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: server.example.com</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==</div><div class="line"><span class="attribute">Origin</span>: http://example.com</div><div class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat, superchat</div><div class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</div></pre></td></tr></table></figure></p>
<p>Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。Sec-WebSocket-Protocol 字段内记录使用的子协议。</p>
<p>子协议按 WebSocket 协议标准在连接分开使用时，定义那些连接的名称。</p>
<ol>
<li>握手·响应</li>
</ol>
<p>对于之前的请求，返回状态码 101 Switching Protocols 的响应。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Sec-WebSocket-Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</div><div class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat</div></pre></td></tr></table></figure></p>
<p>Sec-WebSocket-Accept 的字段值是由握手请求中的 Sec-WebSocket-Key 的字段值生成的。</p>
<p>成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p>
<p><img src="http://storage1.imgchr.com/images/WebSocket.png" alt="enter image description here"></p>
<p>WebSocket API</p>
<p>JavaScript 可调用“The WebSocket API”（<a href="http://www.w3.org/TR/websockets/，由" target="_blank" rel="external">http://www.w3.org/TR/websockets/，由</a> W3C 标准制定）内提供的 WebSocket 程序接口，以实现 WebSocket 协议下全双工通信。</p>
<p>以下为调用 WebSocket API，每 50ms 发送一次数据的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://game.example.com:12010/updates'</span>);</div><div class="line">socket.onopen = function () &#123;</div><div class="line">   setInterval(function() &#123;</div><div class="line">      <span class="keyword">if</span> (socket.bufferedAmount == <span class="number">0</span>)</div><div class="line">      socket.send(getUpdateData());</div><div class="line">   &#125;, <span class="number">50</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h6 id="二进制协议："><a href="#二进制协议：" class="headerlink" title="二进制协议："></a><strong><font color="#FF7256">二进制协议：</font></strong></h6><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p>
<p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<h6 id="多工："><a href="#多工：" class="headerlink" title="多工："></a><strong><font color="#FF7256">多工：</font></strong></h6><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>
<p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p>
<p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p>
<h6 id="数据流："><a href="#数据流：" class="headerlink" title="数据流："></a><strong><font color="#FF7256">数据流：</font></strong></h6><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p>
<p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p>
<p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
<h6 id="头信息压缩："><a href="#头信息压缩：" class="headerlink" title="头信息压缩："></a><strong><font color="#FF7256">头信息压缩：</font></strong></h6><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>
<p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
<h6 id="服务器推送："><a href="#服务器推送：" class="headerlink" title="服务器推送："></a><strong><font color="#FF7256">服务器推送：</font></strong></h6><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p>
<p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
<h3 id="二、HTTPS"><a href="#二、HTTPS" class="headerlink" title="二、HTTPS"></a><strong><font color="#FF7256">二、HTTPS</font></strong></h3><p><strong><font color="#FF7256">HTTPS和HTTP的区别：</font></strong></p>
<p>1.https协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
<ol>
<li><p>http是超文本传输协议，信息是明文传输；https 则是具有安全性的ssl加密传输协议。</p>
</li>
<li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
</li>
<li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
</li>
</ol>
<blockquote>
<p><strong><font color="#FF7256">HTTP + 加密 + 认证 + 完整性保护 =HTTPS</font></strong></p>
</blockquote>
<p><strong><font color="#FF7256">HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS</font></strong></p>
<p>如果在 HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。</p>
<p>另外，对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。</p>
<p>为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。</p>
<p>经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用 <a href="http://，而是改用" target="_blank" rel="external">http://，而是改用</a> <a href="https://。另外，当浏览器访问" target="_blank" rel="external">https://。另外，当浏览器访问</a> HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。</p>
<p><strong><font color="#FF7256">HTTPS 是身披 SSL 外壳的 HTTP</font></strong></p>
<p><img src="http://storage2.imgchr.com/HTTPS.png" alt="enter image description here"></p>
<p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p>
<p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p>
<p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。</p>
<p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p>
<p><strong><font color="#FF7256">相互交换密钥的公开密钥加密技术</font></strong></p>
<p>在对 SSL 进行讲解之前，我们先来了解一下加密方法。SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p>
<p>近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。</p>
<p>加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。</p>
<ol>
<li><strong><font color="#FF7256">共享密钥加密的困境</font></strong></li>
</ol>
<p>加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。</p>
<p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>
<ol>
<li><strong><font color="#FF7256">使用两把密钥的公开密钥加密</font></strong></li>
</ol>
<p>公开密钥加密方式很好地解决了共享密钥加密的困难。</p>
<p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p>
<p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p>
<p>另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。</p>
<ol>
<li><strong><font color="#FF7256">HTTPS 采用混合加密机制</font></strong></li>
</ol>
<p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p>
<p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p>
<ol>
<li><strong><font color="#FF7256">证明公开密钥正确性的证书</font></strong></li>
</ol>
<p>遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。</p>
<p>为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。</p>
<p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。威瑞信（VeriSign）就是其中一家非常有名的数字证书认证机构。我们来介绍一下数字证书认证机构的业务流程。首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。</p>
<p>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。</p>
<p>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。</p>
<p>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p>
<ol>
<li><strong><font color="#FF7256">可证明组织真实性的 EV SSL 证书</font></strong></li>
</ol>
<p>证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL 证书（Extended Validation SSL Certificate）。</p>
<p>EV SSL 证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的 Web 网站能够获得更高的认可度。</p>
<p>持有 EV SSL 证书的 Web 网站的浏览器地址栏处的背景色是绿色的，从视觉上就能一眼辨别出。而且在地址栏的左侧显示了 SSL 证书中记录的组织名称以及颁发证书的认证机构的名称。</p>
<p>上述机制的原意图是为了防止用户被钓鱼攻击（Phishing），但就效果上来讲，还得打一个问号。很多用户可能不了解 EV SSL 证书相关的知识，因此也不太会留意它。</p>
<ol>
<li><strong><font color="#FF7256">用以确认客户端的客户端证书</font></strong></li>
</ol>
<p>HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端，其作用跟服务器证书如出一辙。</p>
<p>但客户端证书仍存在几处问题点。其中的一个问题点是证书的获取及发布。</p>
<p>想获取证书时，用户得自行安装客户端证书。但由于客户端证书是要付费购买的，且每张证书对应到每位用户也就意味着需支付和用户数对等的费用。另外，要让知识层次不同的用户们自行安装证书，这件事本身也充满了各种挑战。</p>
<p>现状是，安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。</p>
<p>例如，银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入 ID 和密码，还会要求用户的客户端证书，以确认用户是否从特定的终端访问网银。</p>
<p>客户端证书存在的另一个问题点是，客户端证书毕竟只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性。也就是说，只要获得了安装有客户端证书的计算机的使用权限，也就意味着同时拥有了客户端证书的使用权限。</p>
<ol>
<li><strong><font color="#FF7256">认证机构信誉第一</font></strong></li>
</ol>
<p>SSL 机制中介入认证机构之所以可行，是因为建立在其信用绝对可靠这一大前提下的。然而，2011 年 7 月，荷兰的一家名叫 DigiNotar 的认证机构曾遭黑客不法入侵，颁布了 google.com 和 twitter.com 等网站的伪造证书事件。这一事件从根本上撼动了 SSL 的可信度。</p>
<p>因为伪造证书上有正规认证机构的数字签名，所以浏览器会判定该证书是正当的。当伪造的证书被用做服务器伪装之时，用户根本无法察觉到。</p>
<p>虽然存在可将证书无效化的证书吊销列表（Certificate Revocation List，CRL）机制，以及从客户端删除根证书颁发机构（Root Certificate Authority，RCA）的对策，但是距离生效还需要一段时间，而在这段时间内，到底会有多少用户的利益蒙受损失就不得而知了。</p>
<ol>
<li><strong><font color="#FF7256">由自认证机构颁发的证书称为自签名证书</font></strong></li>
</ol>
<p>如果使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用，似乎没什么帮助。</p>
<p>独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书。</p>
<p>浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。</p>
<h4 id="HTTPS-的安全通信机制"><a href="#HTTPS-的安全通信机制" class="headerlink" title="HTTPS 的安全通信机制"></a><strong><font color="#FF7256">HTTPS 的安全通信机制</font></strong></h4><p><img src="http://storage2.imgchr.com/HTTPSd4998.png" alt="enter image description here"></p>
<p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p>
<p>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p>
<p>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p>
<p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p>
<p>步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p>
<p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p>
<p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p>
<p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p>
<p>步骤 9： 服务器同样发送 Finished 报文。</p>
<p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p>
<p>步骤 11： 应用层协议通信，即发送 HTTP 响应。</p>
<p>步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p>
<p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p>
<blockquote>
<p><strong><font color="#FF7256">CBC 模式（Cipher Block Chaining）又名密码分组链接模式。在此模式下，将前一个明文块加密处理后和下一个明文块做 XOR 运算，使之重叠，然后再对运算结果做加密处理。对第一个明文块做加密时，要么使用前一段密文的最后一块，要么利用外部生成的初始向量（initial vector，IV）。</font></strong> </p>
</blockquote>
<h5 id="SL-和-TLS"><a href="#SL-和-TLS" class="headerlink" title="SL 和 TLS"></a><strong><font color="#FF7256">SL 和 TLS</font></strong></h5><p>HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security）这两个协议。</p>
<p>SSL 技术最初是由浏览器开发商网景通信公司率先倡导的，开发过 SSL3.0 之前的版本。目前主导权已转移到 IETF（Internet Engineering Task Force，Internet 工程任务组）的手中。</p>
<p>IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和 TLS1.2。TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。</p>
<p>由于 SSL1.0 协议在设计之初被发现出了问题，就没有实际投入使用。SSL2.0 也被发现存在问题，所以很多浏览器直接废除了该协议版本。</p>
<p><strong><font color="#FF7256">SSL (Secure Socket Layer，安全套接字层)：</font></strong> </p>
<p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本。</p>
<p>SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<p><strong><font color="#FF7256">TSL (Transport Layer Security，传输层安全协议)：</font></strong> </p>
<p>用于两个应用程序之间提供保密性和数据完整性。</p>
<p>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</p>
<p><strong><font color="#FF7256">SSL/TSL协议作用：</font></strong> </p>
<p>认证用户和服务器，确保数据发送到正确的客户机和服务器；<br>加密数据以防止数据中途被窃取；<br>维护数据的完整性，确保数据在传输过程中不被改变。</p>
<p><strong><font color="#FF7256">TSL比SSL的优势</font></strong> </p>
<p>对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。<br>增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。</p>
<p>改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。</p>
<p>一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。<br>特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。</p>
<p><strong><font color="#FF7256"> SSL、TSL的握手过程</font></strong></p>
<p>SSL与TSL握手整个过程如下图所示，下面会详细介绍每一步的具体内容：</p>
<p><img src="http://i2.buimg.com/567571/52da9cfd2c9ef658.png" alt="enter image description here"></p>
<p><strong><font color="#FF7256">客户端首次发出请求</font></strong> </p>
<p>由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的 Master Secret 。</p>
<p>客户端需要提供如下信息：</p>
<blockquote>
<p>支持的协议版本，比如TLS 1.0版<br>一个客户端生成的随机数，稍后用于生成”对话密钥”<br>支持的加密方法，比如RSA公钥加密<br>支持的压缩方法<br>服务端首次回应</p>
</blockquote>
<p>服务端在接收到客户端的Client Hello之后，服务端需要确定加密协议的版本，以及加密的算法，然后也生成一个随机数，以及将自己的证书发送给客户端一并发送给客户端，这里的随机数是整个过程的第二个随机数。</p>
<p>服务端需要提供的信息：</p>
<blockquote>
<p>协议的版本<br>加密的算法<br>随机数<br>服务器证书</p>
</blockquote>
<p><strong><font color="#FF7256">客户端再次回应</font></strong> </p>
<p>客户端首先会对服务器下发的证书进行验证，验证通过之后，则会继续下面的操作，客户端再次产生一个随机数（第三个随机数），然后使用服务器证书中的公钥进行加密，以及放一个ChangeCipherSpec消息即编码改变的消息，还有整个前面所有消息的hash值，进行服务器验证，然后用新秘钥加密一段数据一并发送到服务器，确保正式通信前无误。</p>
<p>客户端使用前面的两个随机数以及刚刚新生成的新随机数，使用与服务器确定的加密算法，生成一个Session Secret。</p>
<p><strong><font color="#FF7256">ChangeCipherSpec</font></strong> </p>
<blockquote>
<p>ChangeCipherSpec是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。</p>
</blockquote>
<p><strong><font color="#FF7256">服务器再次响应</font></strong> </p>
<p>服务端在接收到客户端传过来的第三个随机数的 加密数据之后，使用私钥对这段加密数据进行解密，并对数据进行验证，也会使用跟客户端同样的方式生成秘钥，一切准备好之后，也会给客户端发送一个 ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了。之后，服务端也会使用 Session Secret 加密一段 Finish 消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。</p>
<p><strong><font color="#FF7256">后续客户端与服务器间通信</font></strong> </p>
<p>确定秘钥之后，服务器与客户端之间就会通过商定的秘钥加密消息了，进行通讯了。整个握手过程也就基本完成了。</p>
<p>值得特别提出的是：</p>
<blockquote>
<p>SSL协议在握手阶段使用的是非对称加密，在传输阶段使用的是对称加密，也就是说在SSL上传送的数据是使用对称密钥加密的！因为非对称加密的速度缓慢，耗费资源。其实当客户端和主机使用非对称加密方式建立连接后，客户端和主机已经决定好了在传输过程使用的对称加密算法和关键的对称加密密钥，由于这个过程本身是安全可靠的，也即对称加密密钥是不可能被窃取盗用的，因此，保证了在传输过程中对数据进行对称加密也是安全可靠的，因为除了客户端和主机之外，不可能有第三方窃取并解密出对称加密密钥！如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。</p>
</blockquote>
<p><strong><font color="#FF7256">其他补充</font></strong> </p>
<p>对于非常重要的保密数据，服务端还需要对客户端进行验证，以保证数据传送给了安全的合法的客户端。服务端可以向客户端发出 Cerficate Request 消息，要求客户端发送证书对客户端的合法性进行验证。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<p>PreMaster secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在Client Hello阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。所以，服务端需要对密文中解密出来对的PreMaster版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被串改，则立即停止发送任何消息。</p>
<p><strong><font color="#FF7256">session的恢复</font></strong> </p>
<p>有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。</p>
<p><strong><font color="#FF7256">session ID</font></strong>  </p>
<p>session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。</p>
<blockquote>
<p>session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。</p>
</blockquote>
<p><strong><font color="#FF7256">session ticket</font></strong>  </p>
<p>客户端发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。</p>
<blockquote>
<p>目前只有Firefox和Chrome浏览器支持。</p>
</blockquote>
<p><strong><font color="#FF7256">总结</font></strong> </p>
<p>https实际就是在TCP层与http层之间加入了SSL/TSL来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。</p>
<h5 id="SSL-速度"><a href="#SSL-速度" class="headerlink" title="SSL 速度"></a><strong><font color="#FF7256">SSL 速度</font></strong></h5><p>HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。</p>
<p>SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。</p>
<p>和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。</p>
<p>另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。</p>
<p>针对速度变慢这一问题，并没有根本性的解决方案，我们会使用 SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。</p>
<p><strong><font color="#FF7256">为什么不一直使用 HTTPS？</font></strong> </p>
<p>既然 HTTPS 那么安全可靠，那为何所有的 Web 网站不一直使用 HTTPS ？</p>
<p>其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。</p>
<p>因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。</p>
<p>特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。</p>
<p>而且，https禁用了缓存。</p>
<p>除此之外，想要节约购买证书的开销也是原因之一。</p>
<p>要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。证书价格可能会根据不同的认证机构略有不同。</p>
<p>那些购买证书并不合算的服务以及一些个人网站，可能只会选择采用 HTTP 的通信方式。</p>
<h5 id="SSL-客户端认证"><a href="#SSL-客户端认证" class="headerlink" title="SSL 客户端认证"></a><strong><font color="#FF7256">SSL 客户端认证</font></strong></h5><p>从使用用户 ID 和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果用户 ID 和密码被盗，就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。</p>
<p>SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书（在 HTTPS 一章已讲解）认证，服务器可确认访问是否来自已登录的客户端。</p>
<p><strong><font color="#FF7256">SSL 客户端认证的认证步骤</font></strong> </p>
<p>为达到 SSL 客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。</p>
<p>步骤 1： 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。</p>
<p>步骤 2： 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</p>
<p>步骤 3： 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。</p>
<p><strong><font color="#FF7256">SSL 客户端认证采用双因素认证</font></strong> </p>
<p>在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证（稍后讲解）组合形成一种双因素认证（Two-factor authentication）来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。</p>
<p>换言之，第一个认证因素的 SSL 客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。</p>
<p>通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算机访问服务器。</p>
<p><strong><font color="#FF7256">SSL 客户端认证必要的费用</font></strong> </p>
<p>使用 SSL 客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用。</p>
<p>这里提到的费用是指，从认证机构购买客户端证书的费用，以及服务器运营者为保证自己搭建的认证机构安全运营所产生的费用。</p>
<p>每个认证机构颁发客户端证书的费用不尽相同，平摊到一张证书上，一年费用约几万至十几万日元。服务器运营者也可以自己搭建认证机构，但要维持安全运行就会产生相应的费用。</p>
<h3 id="三、SOCKET"><a href="#三、SOCKET" class="headerlink" title="三、SOCKET"></a><strong><font color="#FF7256">三、SOCKET</font></strong></h3><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</p>
<p>建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。</p>
<p>Socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket，一个Socket由一个IP地址和一个端口号唯一确定。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。Socket是TCP/IP协议的一个十分流行的编程界面，但是，Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。</p>
<p>Socket通讯过程：服务端监听某个端口是否有连接请求，客户端向服务端发送连接请求，服务端收到连接请求向客户端发出接收消息，这样一个连接就建立起来了。客户端和服务端都可以相互发送消息与对方进行通讯。</p>
<p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p>
<p><strong><font color="#FF7256">套接字（socket）概念：</font></strong></p>
<p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
<p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<p><strong><font color="#FF7256">建立socket连接：</font></strong></p>
<p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket。</p>
<p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<ol>
<li><p>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求；</p>
</li>
<li><p>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p>
</li>
<li><p>连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
</li>
</ol>
<p><strong><font color="#FF7256">SOCKET连接与TCP连接</font></strong></p>
<p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p>
<p>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端。</p>
<p>socket的基本操作：</p>
<p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p>
<p><strong><font color="#FF7256">socket()函数</font></strong></p>
<p>int socket(int domain, int type, int protocol);</p>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p>
<blockquote>
<p>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。<br>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。<br>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。</p>
</blockquote>
<p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p>
<p>当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<p><strong><font color="#FF7256">bind()函数</font></strong></p>
<p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<p>函数的三个参数分别为：</p>
<blockquote>
<p>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。<br>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同：</p>
</blockquote>
<p>如ipv4对应的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct sockaddr_in &#123;</div><div class="line">    sa_family_t    sin_family; /* address family: AF_INET */</div><div class="line">    in_port_t      sin_port;   /* port in network byte order */</div><div class="line">    struct in_addr sin_addr;   /* internet address */</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/* Internet address. */</div><div class="line">struct in_addr &#123;</div><div class="line">    uint32_t       s_addr;     /* address in network byte order */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>ipv6对应的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct sockaddr_in6 &#123; </div><div class="line">    sa_family_t     sin6_family;   /* AF_INET6 */ </div><div class="line">    in_port_t       sin6_port;     /* port number */ </div><div class="line">    uint32_t        sin6_flowinfo; /* IPv6 flow information */ </div><div class="line">    struct in6_addr sin6_addr;     /* IPv6 address */ </div><div class="line">    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ </div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct in6_addr &#123; </div><div class="line">    unsigned char   s6_addr[16];   /* IPv6 address */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Unix域对应的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> #define UNIX_PATH_MAX    108</div><div class="line"></div><div class="line">struct sockaddr_un &#123; </div><div class="line">    sa_family_t sun_family;               /* AF_UNIX */ </div><div class="line">    char        sun_path[UNIX_PATH_MAX];  /* pathname */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>addrlen：对应的是地址的长度。</p>
</blockquote>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
<p>网络字节序与主机字节序</p>
<p>主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：</p>
<p>　　a. Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p>
<p>　　b. Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p>
<p>网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p>
<p>所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。</p>
<p><strong><font color="#FF7256">listen()、connect()函数</font></strong></p>
<p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, socklen_t addrlen)</span></span>;</div></pre></td></tr></table></figure></p>
<p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<p><strong><font color="#FF7256">accept()函数</font></strong></p>
<p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, socklen_t *addrlen)</span></span>;</div></pre></td></tr></table></figure></p>
<p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
<p>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<p><strong><font color="#FF7256">read()、write()等函数</font></strong></p>
<p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">read()/write()</div><div class="line">recv()/send()</div><div class="line">readv()/writev()</div><div class="line">recvmsg()/sendmsg()</div><div class="line">recvfrom()/sendto()</div></pre></td></tr></table></figure></p>
<p>我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">ssize_t read(int fd, void *buf, size_t count);</div><div class="line">ssize_t write(int fd, const void *buf, size_t count);</div><div class="line"></div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line"></div><div class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</div><div class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</div><div class="line"></div><div class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</div><div class="line">               const struct sockaddr *dest_addr, socklen_t addrlen);</div><div class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</div><div class="line">                 struct sockaddr *src_addr, socklen_t *addrlen);</div><div class="line"></div><div class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</div><div class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</div></pre></td></tr></table></figure></p>
<p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p>
<p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p>
<p>其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。</p>
<p><strong><font color="#FF7256">close()函数</font></strong></p>
<p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">int close(int fd);</div></pre></td></tr></table></figure></p>
<p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p>
<p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
<h4 id="N层交换技术"><a href="#N层交换技术" class="headerlink" title="N层交换技术"></a><strong><font color="#FF7256">N层交换技术</font></strong></h4><p><strong><font color="#FF7256">二层交换技术</font></strong></p>
<p>交换原理：根据第二层数据链路层的MAC地址来实现端到端的数据交换</p>
<p>工作流程：</p>
<p>（1）交换机某端口收到数据包，读取源MAC地址，得到源MAC地址机器所连端口；</p>
<p>（2）读取目的MAC地址，在地址表中查找对应端口；</p>
<p>（3）如果地址表中有目的MAC地址对应端口，直接复制数据至此端口；</p>
<p>（4）如果地址表中没有目的MAC地址对应端口，广播所有端口，当目的机器回应时，更新地址表，下次就不需要广播了。</p>
<p>不断的循环上述过程，全网的MAC地址信息都可以学习到，二层交换机就这样学习和维护它的地址表。第二层交换机根据MAC选择端口转发数据，算法又很简单，其方便采用廉价芯片实现，且速度快。</p>
<p><strong><font color="#FF7256">三层交换技术</font></strong></p>
<p>交换原理：根据第三层网络层的IP地址来完成端到端的数据交换；</p>
<blockquote>
<p><strong><font color="#FF7256">场景：A(ip1) =&gt;  三层交换机 =&gt;  B(ip2)</font></strong></p>
</blockquote>
<p>工作流程：</p>
<p>（1）A发数据给B，根据B的ip地址+子网掩码，A能够判断出B和自己是否在同一个网段；</p>
<p>（2）B如果和A在同一个网段内，但A不知道B的MAC地址，A会发送一个ARP请求，以获取B的MAC地址，并根据MAC通过二层交换机将数据发送给B；</p>
<p>（3）B如果和A不在同一个网段内，且不知道B的MAC地址，A会将数据包发送给网关（A的本地一定有网关的MAC地址）。网关收到数据包后，将源MAC地址会修改为网关自己的MAC地址，目的IP对应的MAC地址为目的MAC地址，以完成数据交换。<br>看似第三层交换机是第二层交换机+路由功能的组合，实际并非这样：数据通过第三层转发设备后，会记录IP与MAC的映射关系，下次需要转发时，不会再经过第三层设备。</p>
<p><strong><font color="#FF7256">四层交换技术</font></strong></p>
<p>二层和三层交换设备都是基于端到端的交换，这种基于IP和MAC地址的交换技术，有着很高效传输率，但是缺乏根据目的主机应用需求动态交换数据的功能。</p>
<p>四层设备不但能够完成端到端的交换，还能够根据目的主机的应用特点，分配或限制其流量；</p>
<p>四层设备基于传输层数据包交换，是一类建立在TCP/IP应用层至上，实现用户应用需求的设备；它实现一类应用层的访问控制与质量保证服务，与其说它是硬件设备，不如说它是软件网络管理系统。</p>
<p><strong><font color="#FF7256">四层交换核心技术</font></strong></p>
<ol>
<li><p>包过滤<br>利用四层信息定义过滤规则，能够控制指定端口的TCP/UDP通信，它可以在高速芯片中实现，极大提高包过滤速率；</p>
</li>
<li><p>包优先级<br>三层以下设备只有MAC，PORT，IP等信息，因为缺乏四层信息，无法确认TCP/IP等四层优先级信息；四层设备允许基于目的地址/端口（即应用服务）的组合来区分优先级。</p>
</li>
<li><p>负载均衡<br>将附加有负载均衡服务的IP地址，通过不同的物理服务做成一个集群，提供相同的服务，并将其定义为一个单独的虚拟服务器；<br>这个虚拟服务器是一个有独立IP的逻辑服务器，用户数据流只需要流向虚拟服务器IP，而不与物理服务器进行通信；<br>只有通过交换机执行网络地址转换（NAT）后，才能得到真实访问；<br>虚拟服务器组里转换通信流量实现均衡，其中具体关系到OSPF、RIP、VRRP等协议；</p>
</li>
<li><p>主机备用连接<br>同（3）所含技术类似，可以实现主备同IP自动切换；</p>
</li>
</ol>
<p><strong><font color="#FF7256">七层交换技术</font></strong></p>
<p>交换原理：比四层更进一步，可以根据应用层的数据报文来完成更多的复杂交换功能（例如根据http报文路由）。由于七层交换还没有具体的标准，文章也不多展开啦。</p>
<p><strong><font color="#FF7256">JDK Socket</font></strong></p>
<p>在java.net包下有两个类：Socket和ServerSocket。ServerSocket用于服务器端，Socket是建立网络连接时使用的。在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。对于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在客户端而产生不同级别。不管是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的。</p>
<p><strong><font color="#FF7256">列出几个常用的构造方法：</font></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Socket(InetAddress address,<span class="keyword">int</span> port); <span class="comment">//创建一个流套接字并将其连接到指定 IP 地址的指定端口号；</span></div><div class="line">Socket(String host,<span class="keyword">int</span> port); <span class="comment">//创建一个流套接字并将其连接到指定主机上的指定端口号；</span></div><div class="line">Socket(InetAddress address,<span class="keyword">int</span> port, InetAddress localAddr,<span class="keyword">int</span> localPort); <span class="comment">//创建一个套接字并将其连接到指定远程地址上的指定远程端口；</span></div><div class="line">Socket(String host,<span class="keyword">int</span> port, InetAddress localAddr,<span class="keyword">int</span> localPort); <span class="comment">//创建一个套接字并将其连接到指定远程主机上的指定远程端口；</span></div><div class="line">Socket(SocketImpl impl); <span class="comment">//使用用户指定的 SocketImpl 创建一个未连接 Socket；</span></div><div class="line">ServerSocket(<span class="keyword">int</span> port); <span class="comment">//创建绑定到特定端口的服务器套接字；</span></div><div class="line">ServerSocket(<span class="keyword">int</span> port,<span class="keyword">int</span> backlog); <span class="comment">//利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号；</span></div><div class="line">ServerSocket(<span class="keyword">int</span> port,<span class="keyword">int</span> backlog, InetAddress bindAddr); <span class="comment">//使用指定的端口、侦听 backlog 和要绑定到的本地 IP地址创建服务器；</span></div></pre></td></tr></table></figure></p>
<p>构造方法的参数中，address、host和port分别是双向连接中另一方的IP地址、主机名和端 口号，stream指明socket是流socket还是数据报socket，localPort表示本地主机的端口号，localAddr和bindAddr是本地机器的地址（ServerSocket的主机地址），impl是socket的父类，既可以用来创建serverSocket又可以用来创建Socket。count则表示服务端所能支持的最大连接数。</p>
<p>注意：必须小心选择端口号。每一个端口提供一种特定的服务，只有给出正确的端口，才能获得相应的服务。0~1023的端口号为系统所保留，例如http服务的端口号为80,telnet服务的端口号为21,ftp服务的端口号为23, 所以我们在选择端口号时，最好选择一个大于1023的数以防止发生冲突。</p>
<p><strong><font color="#FF7256">几个重要的Socket方法：</font></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>; <span class="comment">//方法获得网络连接输入，同时返回一个IutputStream对象实例；</span></div><div class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>; <span class="comment">//方法连接的另一端将得到输入，同时返回一个OutputStream对象实例；</span></div><div class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span></span>; <span class="comment">//用于产生"阻塞"，直到接受到一个连接，并且返回一个客户端的Socket对象实例。</span></div></pre></td></tr></table></figure></p>
<p>“阻塞”是一个术语，它使程序运行暂时”停留”在这个地方，直到一个会话产生，然后程序继续；通常”阻塞”是由循环产生的。</p>
<p>注意：其中getInputStream和getOutputStream方法均会产生一个IOException，它必须被捕获，因为它们返回的流对象，通常都会被另一个流对象使用。</p>
<p><strong><font color="#FF7256">基本的Client/Server程序</font></strong></p>
<p>以下是一个基本的客户端/服务器端程序代码。主要实现了服务器端一直监听某个端口，等待客户端连接请求。客户端根据IP地址和端口号连接服务器端，从键盘上输入一行信息，发送到服务器端，然后接收服务器端返回的信息，最后结束会话。这个程序一次只能接受一个客户连接。</p>
<p>客户端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/** 创建Socket*/</span></div><div class="line">            <span class="comment">// 创建一个流套接字并将其连接到指定 IP 地址的指定端口号(本处是本机)</span></div><div class="line">            Socket socket =<span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">2013</span>);</div><div class="line">            <span class="comment">// 60s超时</span></div><div class="line">            socket.setSoTimeout(<span class="number">60000</span>);</div><div class="line"></div><div class="line">            <span class="comment">/** 发送客户端准备传输的信息 */</span></div><div class="line">            <span class="comment">// 由Socket对象得到输出流，并构造PrintWriter对象</span></div><div class="line">            PrintWriter printWriter =<span class="keyword">new</span> PrintWriter(socket.getOutputStream(),<span class="keyword">true</span>);</div><div class="line">            <span class="comment">// 将输入读入的字符串输出到Server</span></div><div class="line">            BufferedReader sysBuff =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">            printWriter.println(sysBuff.readLine());</div><div class="line">            <span class="comment">// 刷新输出流，使Server马上收到该字符串</span></div><div class="line">            printWriter.flush();</div><div class="line"></div><div class="line">            <span class="comment">/** 用于获取服务端传输来的信息 */</span></div><div class="line">            <span class="comment">// 由Socket对象得到输入流，并构造相应的BufferedReader对象</span></div><div class="line">            BufferedReader bufferedReader =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line">            <span class="comment">// 输入读入一字符串</span></div><div class="line">            String result = bufferedReader.readLine();</div><div class="line">            System.out.println(<span class="string">"Server say : "</span> + result);</div><div class="line"></div><div class="line">            <span class="comment">/** 关闭Socket*/</span></div><div class="line">            printWriter.close();</div><div class="line">            bufferedReader.close();</div><div class="line">            socket.close();</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"Exception:"</span> + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/** 创建ServerSocket*/</span></div><div class="line">            <span class="comment">// 创建一个ServerSocket在端口2013监听客户请求</span></div><div class="line">            ServerSocket serverSocket =<span class="keyword">new</span> ServerSocket(<span class="number">2013</span>);</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="comment">// 侦听并接受到此Socket的连接,请求到来则产生一个Socket对象，并继续执行</span></div><div class="line">                Socket socket = serverSocket.accept();</div><div class="line"></div><div class="line">                <span class="comment">/** 获取客户端传来的信息 */</span></div><div class="line">                <span class="comment">// 由Socket对象得到输入流，并构造相应的BufferedReader对象</span></div><div class="line">                BufferedReader bufferedReader =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line">                <span class="comment">// 获取从客户端读入的字符串</span></div><div class="line">                String result = bufferedReader.readLine();</div><div class="line">                System.out.println(<span class="string">"Client say : "</span> + result);</div><div class="line"></div><div class="line">                <span class="comment">/** 发送服务端准备传输的 */</span></div><div class="line">                <span class="comment">// 由Socket对象得到输出流，并构造PrintWriter对象</span></div><div class="line">                PrintWriter printWriter =<span class="keyword">new</span> PrintWriter(socket.getOutputStream());</div><div class="line">                printWriter.print(<span class="string">"hello Client, I am Server!"</span>);</div><div class="line">                printWriter.flush();</div><div class="line"></div><div class="line">                <span class="comment">/** 关闭Socket*/</span></div><div class="line">                printWriter.close();</div><div class="line">                bufferedReader.close();</div><div class="line">                socket.close();</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"Exception:"</span> + e);</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            <span class="comment">//serverSocket.close();</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">多客户端连接服务器</font></strong></p>
<p>上面的服务器端程序一次只能连接一个客户端，这在实际应用中显然是不可能的。通常的网络环境是多个客户端连接到某个主机进行通讯，所以我们要对上面的程序进行改造。</p>
<p>设计思路：服务器端主程序监听某一个端口，客户端发起连接请求，服务器端主程序接收请求，同时构造一个线程类，用于接管会话。当一个Socket会话产生后，这个会话就会交给线程进行处理，主程序继续进行监听。</p>
<p>下面的实现程序流程是：客户端和服务器建立连接，客户端发送消息，服务端根据消息进行处理并返回消息，若客户端申请关闭，则服务器关闭此连接，双方通讯结束。</p>
<p>客户端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Socket socket =<span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">2013</span>);</div><div class="line">            socket.setSoTimeout(<span class="number">60000</span>);</div><div class="line"></div><div class="line">            PrintWriter printWriter =<span class="keyword">new</span> PrintWriter(socket.getOutputStream(),<span class="keyword">true</span>);</div><div class="line">            BufferedReader bufferedReader =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line"></div><div class="line">            String result =<span class="string">""</span>;</div><div class="line">            <span class="keyword">while</span>(result.indexOf(<span class="string">"bye"</span>) == -<span class="number">1</span>)&#123;</div><div class="line">                BufferedReader sysBuff =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">                printWriter.println(sysBuff.readLine());</div><div class="line">                printWriter.flush();</div><div class="line"></div><div class="line">                result = bufferedReader.readLine();</div><div class="line">                System.out.println(<span class="string">"Server say : "</span> + result);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            printWriter.close();</div><div class="line">            bufferedReader.close();</div><div class="line">            socket.close();</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"Exception:"</span> + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">import</span> java.net.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">ServerSocket</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT =<span class="number">2013</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">super</span>(SERVER_PORT);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                Socket socket = accept();</div><div class="line">                <span class="keyword">new</span> CreateServerThread(socket);<span class="comment">//当有请求时，启一个线程处理</span></div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//线程类</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CreateServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> Socket client;</div><div class="line">        <span class="keyword">private</span> BufferedReader bufferedReader;</div><div class="line">        <span class="keyword">private</span> PrintWriter printWriter;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CreateServerThread</span><span class="params">(Socket s)</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            client = s;</div><div class="line"></div><div class="line">            bufferedReader =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</div><div class="line"></div><div class="line">            printWriter =<span class="keyword">new</span> PrintWriter(client.getOutputStream(),<span class="keyword">true</span>);</div><div class="line">            System.out.println(<span class="string">"Client("</span> + getName() +<span class="string">") come in..."</span>);</div><div class="line"></div><div class="line">            start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                String line = bufferedReader.readLine();</div><div class="line"></div><div class="line">                <span class="keyword">while</span> (!line.equals(<span class="string">"bye"</span>)) &#123;</div><div class="line">                    printWriter.println(<span class="string">"continue, Client("</span> + getName() +<span class="string">")!"</span>);</div><div class="line">                    line = bufferedReader.readLine();</div><div class="line">                    System.out.println(<span class="string">"Client("</span> + getName() +<span class="string">") say: "</span> + line);</div><div class="line">                &#125;</div><div class="line">                printWriter.println(<span class="string">"bye, Client("</span> + getName() +<span class="string">")!"</span>);</div><div class="line"></div><div class="line">                System.out.println(<span class="string">"Client("</span> + getName() +<span class="string">") exit!"</span>);</div><div class="line">                printWriter.close();</div><div class="line">                bufferedReader.close();</div><div class="line">                client.close();</div><div class="line">            &#125;<span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">new</span> Server();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">信息群发共享</font></strong></p>
<p>以上虽然实现了多个客户端和服务器连接，但是仍然是消息在一个客户端和服务器之间相互传播。现在我们要实现信息共享，即服务器可以向多个客户端发送广播消息，客户端也可以向其他客户端发送消息。类似于聊天室的那种功能，实现信息能在多个客户端之间共享。</p>
<p>设计思路：客户端循环可以不停输入向服务器发送消息，并且启一个线程，专门用来监听服务器端发来的消息并打印输出。服务器端启动时，启动一个监听何时需要向客户端发送消息的线程。每次接受客户端连接请求，都启一个线程进行处理，并且将客户端信息存放到公共集合中。当客户端发送消息时，服务器端将消息顺序存入队列中，当需要输出时，从队列中取出广播到各客户端处。客户端输入showuser命令可以查看在线用户列表，输入bye向服务器端申请退出连接。</p>
<p>客户端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> <span class="keyword">extends</span> <span class="title">Socket</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_IP =<span class="string">"127.0.0.1"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT =<span class="number">2013</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Socket client;</div><div class="line">    <span class="keyword">private</span> PrintWriter out;</div><div class="line">    <span class="keyword">private</span> BufferedReader in;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 与服务器连接，并输入发送消息</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">super</span>(SERVER_IP, SERVER_PORT);</div><div class="line">        client =<span class="keyword">this</span>;</div><div class="line">        out =<span class="keyword">new</span> PrintWriter(<span class="keyword">this</span>.getOutputStream(),<span class="keyword">true</span>);</div><div class="line">        in =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">this</span>.getInputStream()));</div><div class="line">        <span class="keyword">new</span> readLineThread();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            in =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">            String input = in.readLine();</div><div class="line">            out.println(input);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于监听服务器端向客户端发送消息线程类</div><div class="line">     */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">readLineThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> BufferedReader buff;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">readLineThread</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                buff =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</div><div class="line">                start();</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                    String result = buff.readLine();</div><div class="line">                    <span class="keyword">if</span>(<span class="string">"byeClient"</span>.equals(result))&#123;<span class="comment">//客户端申请退出，服务端返回确认退出</span></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//输出服务端发送消息</span></div><div class="line">                        System.out.println(result);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                in.close();</div><div class="line">                out.close();</div><div class="line">                client.close();</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">new</span> SocketClient();<span class="comment">//启动客户端</span></div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">ServerSocket</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT =<span class="number">2013</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPrint =<span class="keyword">false</span>;<span class="comment">//是否输出消息标志</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List user_list =<span class="keyword">new</span> ArrayList();<span class="comment">//登录用户集合</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ServerThread&gt; thread_list =<span class="keyword">new</span> ArrayList&lt;ServerThread&gt;();<span class="comment">//服务器已启用线程集合</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedList&lt;String&gt; message_list =<span class="keyword">new</span> LinkedList&lt;String&gt;();<span class="comment">//存放消息队列</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建服务端Socket,创建向客户端发送消息线程,监听客户端请求并处理</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">        <span class="keyword">super</span>(SERVER_PORT);<span class="comment">//创建ServerSocket</span></div><div class="line">        <span class="keyword">new</span> PrintOutThread();<span class="comment">//创建向客户端发送消息线程</span></div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;<span class="comment">//监听客户端请求，启个线程处理</span></div><div class="line">                Socket socket = accept();</div><div class="line">                <span class="keyword">new</span> ServerThread(socket);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 监听是否有输出消息请求线程类,向客户端发送消息</div><div class="line">     */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PrintOutThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintOutThread</span><span class="params">()</span></span>&#123;</div><div class="line">            start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(isPrint)&#123;<span class="comment">//将缓存在队列中的消息按顺序发送到各客户端，并从队列中清除。</span></div><div class="line">                    String message = message_list.getFirst();</div><div class="line">                    <span class="keyword">for</span> (ServerThread thread : thread_list) &#123;</div><div class="line">                        thread.sendMessage(message);</div><div class="line">                    &#125;</div><div class="line">                    message_list.removeFirst();</div><div class="line">                    isPrint = message_list.size() &gt;<span class="number">0</span> ?<span class="keyword">true</span> :<span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 服务器线程类</div><div class="line">     */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> Socket client;</div><div class="line">        <span class="keyword">private</span> PrintWriter out;</div><div class="line">        <span class="keyword">private</span> BufferedReader in;</div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket s)</span><span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">            client = s;</div><div class="line">            out =<span class="keyword">new</span> PrintWriter(client.getOutputStream(),<span class="keyword">true</span>);</div><div class="line">            in =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</div><div class="line">            in.readLine();</div><div class="line">            out.println(<span class="string">"成功连上聊天室,请输入你的名字："</span>);</div><div class="line">            start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">int</span> flag =<span class="number">0</span>;</div><div class="line">                String line = in.readLine();</div><div class="line">                <span class="keyword">while</span>(!<span class="string">"bye"</span>.equals(line))&#123;</div><div class="line">                    <span class="comment">//查看在线用户列表</span></div><div class="line">                    <span class="keyword">if</span> (<span class="string">"showuser"</span>.equals(line)) &#123;</div><div class="line">                        out.println(<span class="keyword">this</span>.listOnlineUsers());</div><div class="line">                        line = in.readLine();</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//第一次进入，保存名字</span></div><div class="line">                    <span class="keyword">if</span>(flag++ ==<span class="number">0</span>)&#123;</div><div class="line">                        name = line;</div><div class="line">                        user_list.add(name);</div><div class="line">                        thread_list.add(<span class="keyword">this</span>);</div><div class="line">                        out.println(name +<span class="string">"你好,可以开始聊天了..."</span>);</div><div class="line">                        <span class="keyword">this</span>.pushMessage(<span class="string">"Client&lt;"</span> + name +<span class="string">"&gt;进入聊天室..."</span>);</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        <span class="keyword">this</span>.pushMessage(<span class="string">"Client&lt;"</span> + name +<span class="string">"&gt; say : "</span> + line);</div><div class="line">                    &#125;</div><div class="line">                    line = in.readLine();</div><div class="line">                &#125;</div><div class="line">                out.println(<span class="string">"byeClient"</span>);</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;<span class="keyword">finally</span>&#123;<span class="comment">//用户退出聊天室</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    client.close();</div><div class="line">                &#125;<span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                thread_list.remove(<span class="keyword">this</span>);</div><div class="line">                user_list.remove(name);</div><div class="line">                pushMessage(<span class="string">"Client&lt;"</span> + name +<span class="string">"&gt;退出了聊天室"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//放入消息队列末尾，准备发送给客户端</span></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushMessage</span><span class="params">(String msg)</span></span>&#123;</div><div class="line">            message_list.addLast(msg);</div><div class="line">            isPrint =<span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//向客户端发送一条消息</span></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</div><div class="line">            out.println(msg);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//统计在线用户列表</span></div><div class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">listOnlineUsers</span><span class="params">()</span> </span>&#123;</div><div class="line">            String s =<span class="string">"--- 在线用户列表 ---\015\012"</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; user_list.size(); i++) &#123;</div><div class="line">                s +=<span class="string">"["</span> + user_list.get(i) +<span class="string">"]\015\012"</span>;</div><div class="line">            &#125;</div><div class="line">            s +=<span class="string">"--------------------"</span>;</div><div class="line">            <span class="keyword">return</span> s;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">new</span> Server();<span class="comment">//启动服务端</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">文件传输</font></strong></p>
<p>客户端向服务器端传送文件，服务端可获取文件名用于保存，获取文件大小计算传输进度，比较简单，直接贴代码。</p>
<p>客户端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.DataOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 客户端</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">Socket</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_IP =<span class="string">"127.0.0.1"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT =<span class="number">2013</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Socket client;</div><div class="line">    <span class="keyword">private</span> FileInputStream fis;</div><div class="line">    <span class="keyword">private</span> DataOutputStream dos;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                client =<span class="keyword">new</span> Socket(SERVER_IP, SERVER_PORT);</div><div class="line">                <span class="comment">//向服务端传送文件</span></div><div class="line">                File file =<span class="keyword">new</span> File(<span class="string">"c:/test.doc"</span>);</div><div class="line">                fis =<span class="keyword">new</span> FileInputStream(file);</div><div class="line">                dos =<span class="keyword">new</span> DataOutputStream(client.getOutputStream());</div><div class="line"></div><div class="line">                <span class="comment">//文件名和长度</span></div><div class="line">                dos.writeUTF(file.getName());</div><div class="line">                dos.flush();</div><div class="line">                dos.writeLong(file.length());</div><div class="line">                dos.flush();</div><div class="line"></div><div class="line">                <span class="comment">//传输文件</span></div><div class="line">                <span class="keyword">byte</span>[] sendBytes =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">                <span class="keyword">int</span> length =<span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span>((length = fis.read(sendBytes,<span class="number">0</span>, sendBytes.length)) &gt;<span class="number">0</span>)&#123;</div><div class="line">                    dos.write(sendBytes,<span class="number">0</span>, length);</div><div class="line">                    dos.flush();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;<span class="keyword">finally</span>&#123;</div><div class="line">                <span class="keyword">if</span>(fis !=<span class="keyword">null</span>)</div><div class="line">                    fis.close();</div><div class="line">                <span class="keyword">if</span>(dos !=<span class="keyword">null</span>)</div><div class="line">                    dos.close();</div><div class="line">                client.close();</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">new</span> Client();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"><span class="keyword">import</span> java.io.DataInputStream;</div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 服务器</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">ServerSocket</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT =<span class="number">2013</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ServerSocket server;</div><div class="line">    <span class="keyword">private</span> Socket client;</div><div class="line">    <span class="keyword">private</span> DataInputStream dis;</div><div class="line">    <span class="keyword">private</span> FileOutputStream fos;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                server =<span class="keyword">new</span> ServerSocket(PORT);</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                    client = server.accept();</div><div class="line">                    dis =<span class="keyword">new</span> DataInputStream(client.getInputStream());</div><div class="line">                    <span class="comment">//文件名和长度</span></div><div class="line">                    String fileName = dis.readUTF();</div><div class="line">                    <span class="keyword">long</span> fileLength = dis.readLong();</div><div class="line">                    fos =<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"d:/"</span> + fileName));</div><div class="line">                    <span class="keyword">byte</span>[] sendBytes =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">                    <span class="keyword">int</span> transLen =<span class="number">0</span>;</div><div class="line">                    System.out.println(<span class="string">"----开始接收文件&lt;"</span> + fileName +<span class="string">"&gt;,文件大小为&lt;"</span> + fileLength +<span class="string">"&gt;----"</span>);</div><div class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                        <span class="keyword">int</span> read =<span class="number">0</span>;</div><div class="line">                        read = dis.read(sendBytes);</div><div class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>)</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        transLen += read;</div><div class="line">                        System.out.println(<span class="string">"接收文件进度"</span> +<span class="number">100</span> * transLen/fileLength +<span class="string">"%..."</span>);</div><div class="line">                        fos.write(sendBytes,<span class="number">0</span>, read);</div><div class="line">                        fos.flush();</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(<span class="string">"----接收文件&lt;"</span> + fileName +<span class="string">"&gt;成功-------"</span>);</div><div class="line">                    client.close();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;<span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">if</span>(dis !=<span class="keyword">null</span>)</div><div class="line">                    dis.close();</div><div class="line">                <span class="keyword">if</span>(fos !=<span class="keyword">null</span>)</div><div class="line">                    fos.close();</div><div class="line">                server.close();</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">new</span> Server();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Socket通信简介"><a href="#Socket通信简介" class="headerlink" title="Socket通信简介"></a><strong><font color="#FF7256">Socket通信简介</font></strong></h4><p>Android与服务器的通信方式主要有两种，一是Http通信，一是Socket通信。两者的最大差异在于，http连接使用的是“请求—响应方式”，即在请求时建立连接通道，当客户端向服务器发送请求后，服务器端才能向客户端返回数据。而Socket通信则是在双方建立起连接后就可以直接进行数据的传输，在连接时可实现信息的主动推送，而不需要每次由客户端想服务器发送请求。 那么，什么是socket？Socket又称套接字，在程序内部提供了与外界通信的端口，即端口通信。通过建立socket连接，可为通信双方的数据传输传提供通道。socket的主要特点有数据丢失率低，使用简单且易于移植。</p>
<p><strong><font color="#FF7256">什么是Socket Socket</font></strong></p>
<p>是一种抽象层，应用程序通过它来发送和接收数据，使用Socket可以将应用程序添加到网络中，与处于同一网络中的其他应用程序进行通信。简单来说，Socket提供了程序内部与外界通信的端口并为通信双方的提供了数据传输通道。</p>
<p><strong><font color="#FF7256">Socket的分类</font></strong></p>
<p>根据不同的的底层协议，Socket的实现是多样化的。本指南中只介绍TCP/IP协议族的内容，在这个协议族当中主要的Socket类型为流套接字（streamsocket）和数据报套接字(datagramsocket)。流套接字将TCP作为其端对端协议，提供了一个可信赖的字节流服务。数据报套接字使用UDP协议，提供数据打包发送服务。 下面，我们来认识一下这两种Socket类型的基本实现模型。</p>
<p><strong><font color="#FF7256">Socket 基本通信模型</font></strong></p>
<p><strong><font color="#FF7256">Socket基本实现原理</font></strong></p>
<p><strong><font color="#FF7256">基于TCP协议的Socket</font></strong></p>
<p>服务器端首先声明一个ServerSocket对象并且指定端口号，然后调用Serversocket的accept()法接收客户端的数据。accept()方法在没有数据进行接收的处于堵塞状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Socket socket= serversocket.accept();</div></pre></td></tr></table></figure></p>
<p>一旦接收到数据，通过inputstream读取接收的数据。</p>
<p>客户端创建一个Socket对象，制定服务器端的IP地址和端口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"172.168.10.108"</span>,<span class="number">8080</span>);</div></pre></td></tr></table></figure></p>
<p>通过inputstream读取数据，获取服务器发出的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutputStream outputstream= socket.getOutputStream();</div></pre></td></tr></table></figure></p>
<p>最后将要发送的数据写入到outputstream即可进行TCP协议的socket数据传输。</p>
<p><strong><font color="#FF7256">基于UDP协议的数据传输</font></strong></p>
<p>服务器端首先创建一个DatagramSocket对象，并且指点监听的端口。接下来创建一个空的DatagramSocket对象用于接收数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">DatagramSocket packet= <span class="keyword">new</span> DatagramSocket(data，data.length);</div></pre></td></tr></table></figure></p>
<p>使用DatagramSocket的receive方法接收客户端发送的数据，receive（）与serversocket的accepet（）类似，在没有数据进行接收的处于堵塞状态。</p>
<p>客户端也创建个DatagramSocket对象，并且指点监听的端口。</p>
<p>接下来创建一个InetAddress对象，这个对象类似与一个网络的发送地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InetAddressserver address= InetAddress.getByName(<span class="string">"172.168.1.120"</span>)</div></pre></td></tr></table></figure></p>
<p>定义要发送的一个字符串，创建一个DatagramPacket对象，并制定要讲这个数据报包发送到网络的那个地址以及端口号。</p>
<p>最后使用DatagramSocket的对象的send（）发送数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str=<span class="string">"hello"</span>;</div><div class="line">bytedata[]=str.getByte();</div><div class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(data,data.length,serveraddress,<span class="number">4567</span>);</div><div class="line">socket.send(packet);</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">android 实现socket简单通信</font></strong></p>
<p>前言：添加权限<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 允许应用程序改变网络状态--&gt;</div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.CHANGE_NETWORK_STATE"</span>/&gt;</div><div class="line"></div><div class="line">&lt;!--允许应用程序改变WIFI连接状态 --&gt;</div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.CHANGE_WIFI_STATE"</span>&gt;</div><div class="line"></div><div class="line">&lt;!--允许应用程序访问有关的网络信息--&gt;</div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</div><div class="line"></div><div class="line">&lt;!--允许应用程序访问WIFI网卡的网络信息--&gt;</div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span>/&gt;</div><div class="line"></div><div class="line">&lt;!--允许应用程序完全使用网络--&gt;</div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">使用TCP协议通信</font></strong></p>
<p>android端实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connectServerWithTCPSocket</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	Socket socket;</div><div class="line"></div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">		</div><div class="line">		<span class="comment">// 创建一个Socket对象，并指定服务端的IP及端口号</span></div><div class="line"></div><div class="line">		socket =newSocket(<span class="string">"192.168.1.32"</span>,<span class="number">1989</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 创建一个InputStream用户读取要发送的文件。</span></div><div class="line"></div><div class="line">		InputStream inputStream =newFileInputStream(<span class="string">"e://a.txt"</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 获取Socket的OutputStream对象用于发送数据。</span></div><div class="line"></div><div class="line">		OutputStream outputStream = socket.getOutputStream();</div><div class="line"></div><div class="line">		<span class="comment">// 创建一个byte类型的buffer字节数组，用于存放读取的本地文件</span></div><div class="line"></div><div class="line">		bytebuffer[] =newbyte[<span class="number">4</span>*<span class="number">1024</span>];</div><div class="line"></div><div class="line">		inttemp =<span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="comment">// 循环读取文件</span></div><div class="line"></div><div class="line">		<span class="keyword">while</span>((temp = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">		<span class="comment">// 把数据写入到OuputStream对象中</span></div><div class="line"></div><div class="line">			outputStream.write(buffer,<span class="number">0</span>, temp);</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">// 发送读取的数据到服务端</span></div><div class="line"></div><div class="line">		outputStream.flush();</div><div class="line"></div><div class="line">	<span class="comment">/** 或创建一个报文，使用BufferedWriter写入,看你的需求 **/</span></div><div class="line"></div><div class="line">		<span class="comment">// String socketData = "[2143213;21343fjks;213]";</span></div><div class="line"></div><div class="line">		<span class="comment">// BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</span></div><div class="line"></div><div class="line">		<span class="comment">// writer.write(socketData.replace("\n", " ") + "\n");</span></div><div class="line"></div><div class="line">		<span class="comment">// writer.flush();</span></div><div class="line"></div><div class="line">		&#125;<span class="keyword">catch</span>(UnknownHostException e) &#123;</div><div class="line"></div><div class="line">			e.printStackTrace();</div><div class="line"></div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line"></div><div class="line">			e.printStackTrace();</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器端简单实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ServerReceviedByTcp</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// 声明一个ServerSocket对象</span></div><div class="line"></div><div class="line">	ServerSocket serverSocket =<span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// 创建一个ServerSocket对象，并让这个Socket在1989端口监听</span></div><div class="line"></div><div class="line">		serverSocket =newServerSocket(<span class="number">1989</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 调用ServerSocket的accept()方法，接受客户端所发送的请求，</span></div><div class="line"></div><div class="line">	<span class="comment">// 如果客户端没有发送数据，那么该线程就停滞不继续</span></div><div class="line"></div><div class="line">		Socket socket = serverSocket.accept();</div><div class="line"></div><div class="line">	<span class="comment">// 从Socket当中得到InputStream对象</span></div><div class="line"></div><div class="line">		InputStream inputStream = socket.getInputStream();</div><div class="line"></div><div class="line">		bytebuffer[] =newbyte[<span class="number">1024</span>*<span class="number">4</span>];</div><div class="line"></div><div class="line">		inttemp =<span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 从InputStream当中读取客户端所发送的数据</span></div><div class="line"></div><div class="line">		<span class="keyword">while</span>((temp = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">			System.out.println(newString(buffer,<span class="number">0</span>, temp));</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		serverSocket.close();</div><div class="line"></div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line"></div><div class="line">			e.printStackTrace();</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">使用UDP协议通信</font></strong></p>
<p>客户端发送数据实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connectServerWithUDPSocket</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	DatagramSocket socket;</div><div class="line"></div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//创建DatagramSocket对象并指定一个端口号，注意，如果客户端需要接收服务器的返回数据,</span></div><div class="line"></div><div class="line">	<span class="comment">//还需要使用这个端口号来receive，所以一定要记住</span></div><div class="line"></div><div class="line">	socket =newDatagramSocket(<span class="number">1985</span>);</div><div class="line"></div><div class="line">	<span class="comment">//使用InetAddress(Inet4Address).getByName把IP地址转换为网络地址</span></div><div class="line"></div><div class="line">	InetAddress serverAddress = InetAddress.getByName(<span class="string">"192.168.1.32"</span>);</div><div class="line"></div><div class="line">	<span class="comment">//Inet4Address serverAddress = (Inet4Address) Inet4Address.getByName("192.168.1.32");</span></div><div class="line"></div><div class="line">	String str =<span class="string">"[2143213;21343fjks;213]"</span>;<span class="comment">//设置要发送的报文</span></div><div class="line"></div><div class="line">	bytedata[] = str.getBytes();<span class="comment">//把字符串str字符串转换为字节数组</span></div><div class="line"></div><div class="line">	<span class="comment">//创建一个DatagramPacket对象，用于发送数据。</span></div><div class="line"></div><div class="line">	<span class="comment">//参数一：要发送的数据  参数二：数据的长度  参数三：服务端的网络地址  参数四：服务器端端口号</span></div><div class="line"></div><div class="line">	DatagramPacket packet =newDatagramPacket(data, data.length ,serverAddress ,<span class="number">10025</span>);</div><div class="line"></div><div class="line">	socket.send(packet);<span class="comment">//把数据发送到服务端。</span></div><div class="line"></div><div class="line">	&#125;<span class="keyword">catch</span>(SocketException e) &#123;</div><div class="line"></div><div class="line">	e.printStackTrace();</div><div class="line"></div><div class="line">	&#125;<span class="keyword">catch</span>(UnknownHostException e) &#123;</div><div class="line"></div><div class="line">		e.printStackTrace();</div><div class="line"></div><div class="line">	&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line"></div><div class="line">		e.printStackTrace();</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端接收服务器返回的数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReceiveServerSocketData</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">		DatagramSocket socket;</div><div class="line"></div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">//实例化的端口号要和发送时的socket一致，否则收不到data</span></div><div class="line"></div><div class="line">		socket =newDatagramSocket(<span class="number">1985</span>);</div><div class="line"></div><div class="line">		bytedata[] =newbyte[<span class="number">4</span>*<span class="number">1024</span>];</div><div class="line"></div><div class="line">		<span class="comment">//参数一:要接受的data 参数二：data的长度</span></div><div class="line"></div><div class="line">		DatagramPacket packet =newDatagramPacket(data, data.length);</div><div class="line"></div><div class="line">		socket.receive(packet);</div><div class="line"></div><div class="line">		<span class="comment">//把接收到的data转换为String字符串</span></div><div class="line"></div><div class="line">		String result =newString(packet.getData(), packet.getOffset(),</div><div class="line"></div><div class="line">		packet.getLength());</div><div class="line"></div><div class="line">		socket.close();<span class="comment">//不使用了记得要关闭</span></div><div class="line"></div><div class="line">		System.out.println(<span class="string">"the number of reveived Socket is  :"</span>+ flag</div><div class="line"></div><div class="line">+<span class="string">"udpData:"</span>+ result);</div><div class="line"></div><div class="line">		&#125;<span class="keyword">catch</span>(SocketException e) &#123;</div><div class="line"></div><div class="line">			e.printStackTrace();</div><div class="line"></div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line"></div><div class="line">			e.printStackTrace();</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>服务器接收客户端实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ServerReceviedByUdp</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="comment">//创建一个DatagramSocket对象，并指定监听端口。（UDP使用DatagramSocket）</span></div><div class="line">    DatagramSocket socket;</div><div class="line">       <span class="keyword">try</span>&#123;</div><div class="line">	socket =newDatagramSocket(<span class="number">10025</span>);</div><div class="line">	<span class="comment">//创建一个byte类型的数组，用于存放接收到得数据</span></div><div class="line">	bytedata[] =newbyte[<span class="number">4</span>*<span class="number">1024</span>];</div><div class="line">	<span class="comment">//创建一个DatagramPacket对象，并指定DatagramPacket对象的大小</span></div><div class="line">	DatagramPacket packet =newDatagramPacket(data,data.length);</div><div class="line">	<span class="comment">//读取接收到得数据</span></div><div class="line">	socket.receive(packet);</div><div class="line">	<span class="comment">//把客户端发送的数据转换为字符串。</span></div><div class="line">	<span class="comment">//使用三个参数的String方法。参数一：数据包 参数二：起始位置 参数三：数据包长</span></div><div class="line">	String result = <span class="keyword">new</span> String(packet.getData(),packet.getOffset() ,packet.getLength());</div><div class="line">	&#125;<span class="keyword">catch</span>(SocketException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">总结：</font></strong></p>
<p>使用UDP方式android端和服务器端接收可以看出，其实android端和服务器端的发送和接收大庭相径，只要端口号正确了，相互通信就没有问题，TCP使用的是流的方式发送，UDP是以包的形式发送。</p>
<p>最后附上七层模型图：</p>
<p><img src="http://storage1.imgchr.com/images/OSI.gif" alt="@OSI七层模型"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#FF7256&quot;&gt;写在本文之前先声明一点：本文是作者通过收集的文章以及自己的看法统一精心整理而成的，主要的参考链接已给出，若想更加全面的理解HTTP协议，建议阅读《图解HTTP》一书，本文花费作者大量时间和
    
    </summary>
    
      <category term="网络请求及框架" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%8F%8A%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="http/https" scheme="http://yoursite.com/tags/http-https/"/>
    
      <category term="retrofit2" scheme="http://yoursite.com/tags/retrofit2/"/>
    
      <category term="OkHttp3" scheme="http://yoursite.com/tags/OkHttp3/"/>
    
      <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
      <category term="GET/POST" scheme="http://yoursite.com/tags/GET-POST/"/>
    
  </entry>
  
  <entry>
    <title>网络请求</title>
    <link href="http://yoursite.com/2016/08/21/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2016/08/21/网络请求/</id>
    <published>2016-08-21T03:29:38.000Z</published>
    <updated>2016-09-04T12:55:20.647Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP-IP协议分层"><a href="#TCP-IP协议分层" class="headerlink" title="TCP/IP协议分层"></a><strong><font color="#FF7256">TCP/IP协议分层</font></strong></h3><blockquote>
<p>发送协议的主机从上自下将数据按照协议封装，而接收数据的主机则按照协议从得到的数据包解开，最后拿到需要的数据。这种结构和栈很相似，所以把TCP/IP协议族也称为TCP/IP协议栈。</p>
</blockquote>
<p><strong><font color="#FF7256">TCP/IP协议栈</font></strong>主要分为四层:<strong>应用层、传输层、网络层、数据链路层,</strong>每层都有相应的协议。<br><img src="http://i2.buimg.com/567571/0e6eb0b26951c515.png" alt=""></p>
<blockquote>
<p><strong><font color="#FF7256"> 协议就是双方进行数据传输的一种格式。</font></strong></p>
</blockquote>
<p><strong><font color="#FF7256">应用层：</font></strong>HTTP，FTP等常见协议；</p>
<p><strong><font color="#FF7256">传输层：</font></strong>TCP、UDP；</p>
<p><strong><font color="#FF7256">网络层：</font></strong>IP协议驻扎层，它负责对数据加上IP地址和其他的数据以确定传输的目标；</p>
<p><strong><font color="#FF7256">链路层：</font></strong>这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。</p>
<p>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。</p>
<p>其实在链路层之下还有物理层，指的是电信号的传递方式，比如现在以太网通用的网线（双绞线）、早期以太网采用的的同轴电缆（现在主要用于有线电视）、光纤等都属于物理层的概念</p>
<blockquote>
<p><strong>注：如果继续往下便是硬件层次，负责网络的传输，这个层次的定义包括网线的制式，网卡的定义等等，有些书并不把这个层次放在tcp/ip协议族里面，因为它几乎和tcp/ip协议的编写者没有任何的关系。</strong></p>
</blockquote>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a><strong><font color="#FF7256">IP地址</font></strong></h4><p>网络上每一个节点都必须有一个独立的Internet地址（IP地址）。现在通常使用的IP地址是一个32bit的数字（常说的IPv4标准），这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址，具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。</p>
<h4 id="RFC"><a href="#RFC" class="headerlink" title=" RFC"></a><strong><font color="#FF7256"> RFC</font></strong></h4><p><a href="http://www.ietf.org/rfc.html" target="_blank" rel="external"><strong>RFC</strong></a>是tcp/ip协议的标准文档，现在它一共有4000多个协议的定义，我们只需掌握十几个协议。 </p>
<h4 id="端口号-port"><a href="#端口号-port" class="headerlink" title=" 端口号(port)"></a><strong><font color="#FF7256"> 端口号(port)</font></strong></h4><p>这里的端口号是用在TCP、UDP上的一个逻辑号码，并不是一个硬件端口，我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。通过不同的逻辑端口来区分不同的服务。比如用于浏览网页服务（HTTP）的80端口，用于FTP服务的21端口，TeInet 远程登陆 23 端口 ， SMTP 邮件传输协议 25 端口 ，POP3 邮局协议的 110 端口  ，DNS 域名解析的 53号以及 SNMP 的网络管理等等端口 。一个IP地址的端口通过16bit进行编号，最多可以有65536个端口。端口是通过端口号来标记的，端口号只有整数，范围是从0 到65535。</p>
<h5 id="推荐协议"><a href="#推荐协议" class="headerlink" title=" 推荐协议"></a><strong><font color="#FF7256"> 推荐协议</font></strong></h5><p>每一个应用层(TCP/IP参考模型 的最高层) 一般都会使用到两个传输层协议之一: 面向连接的TCP传输控制协议和无连接的包传输的UDP用户数据报文协议 。 其它的一些推荐协议有:</p>
<p>• TELNET (Teletype over the Network, 网络电传) ，通过一个终端(terminal)登陆到网络(运行在TCP协议上)。<br>• FTP (File Transfer Protocol, 文件传输协议) ，由名知义(运行在TCP协议上) 。<br>• SMTP (Simple Mail Transfer Protocol，简单邮件传输协议) ，用来发送电子邮件(运行在TCP协议上) 。<br>• DNS (Domain Name Service，域名服务) ，用于完成地址查找，邮件转发等工作(运行在TCP和UDP协议上) 。<br>• ECHO (Echo Protocol, 回绕协议) ，用于查错及测量应答时间(运行在TCP和UDP协议上) 。<br>• NTP (Network Time Protocol，网络时间协议) ，用于网络同步(运行在UDP协议上) 。<br>• SNMP (Simple Network Management Protocol, 简单网络管理协议) ，用于网络信息的收集和网络管理。<br>• BOOTP (Boot Protocol，启动协议) ，应用于无盘设备(运行在UDP协议上)。</p>
<h5 id="可选协议"><a href="#可选协议" class="headerlink" title=" 可选协议"></a><strong><font color="#FF7256"> 可选协议</font></strong></h5><p>最常用的一些有：</p>
<p>• 支撑万维网WWW的超文本传输协议HTTP；</p>
<p>• 动态配置IP地址的DHCP(Dynamic Host Configuration Protocol,动态主机配置协议)；</p>
<p>• 收邮件用的POP3 (Post Office Protocol, version 3, 邮局协议) ；</p>
<p>• 用于加密安全登陆用的SSH (Secure Shell，用于替代安全性差的TELNET) ；</p>
<p>• 用于动态解析以太网硬件地址的ARP (Address Resolution Protocol，地址解析协议) ；<br> 范例: 不同计算机运行的不同协议</p>
<p>• 一个简单的路由器上可能会实现ARP, IP, ICMP, UDP, SNMP, RIP；</p>
<p>• WWW用户端使用ARP, IP, ICMP, UDP, TCP, DNS, HTTP, FTP；</p>
<p>• 一台用户电脑上还会运行如TELNET, SMTP, POP3, SNMP, ECHO, DHCP, SSH, NTP；</p>
<p>• 无盘设备可能会在固件比如ROM中实现了ARP, IP, ICMP, UDP, BOOT, TFTP (均为面向数据报的协议，实现起来相对简单)。</p>
<h5 id="端口号分类"><a href="#端口号分类" class="headerlink" title=" 端口号分类"></a><strong><font color="#FF7256"> 端口号分类</font></strong></h5><h6 id="逻辑端口"><a href="#逻辑端口" class="headerlink" title=" 逻辑端口"></a><strong><font color="#FF7256"> 逻辑端口</font></strong></h6><p>逻辑意义上的端口有多种分类标准，下面将介绍常见的按端口号分布的分类：</p>
<p>（1）公认端口（Well-Known Ports）</p>
<p>知名端口即众所周知的端口号，范围从0到1023，这些端口号一般固定分配给一些服务。比如21端口分配给FTP(文件传输协议)服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务，135端口分配给RPC（远程过程调用）服务等等。</p>
<p>网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏上指定端口号，方法是在地址后面加上冒号”:”半角），再加上端口 号。比如使用“8080”作为WWW服务的端口，则需要在地址栏里输入“：8080”。</p>
<p>但是，有些系统协议使用固定的端口号，它是不能被改变的，比如139 端口专门用于NetBIOS与TCP/IP之间的通信，不能手动改变。</p>
<p>（2） 注册端口（Registered Ports）</p>
<p>端口号从1025到49151。它们松散地绑定于一些服务。也是说有许多服务绑定于这些端口，这些端口同样用于许多其他目的。这些端口多数没有明确的定义服务对象，不同程序可根据实际需要自己定义，如后面要介绍的远程控制软件和木马程序中都会有这些端口的定义的。记住这些常见的程序端口在木马程序的防护和查杀上是非常有必要的。常见木马所使用的端口在后面将有详细的列表。</p>
<h6 id="动态端口"><a href="#动态端口" class="headerlink" title=" 动态端口"></a><strong><font color="#FF7256"> 动态端口</font></strong></h6><p> 动态和/或私有端口（Dynamic and/or Private Ports）</p>
<p>动态端口的范围从1024到65535，这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。比如1024端口就是分配给第一个向系统发出申请的程序。在关闭程序进程后，就会释放所占用的端口号。</p>
<p>不过，动态端口也常常被病毒木马程序所利用，如冰河默认连接端口是7626、WAY 2.4是8011、Netspy 3.0是7306、YAI病毒是1024等 。</p>
<h6 id="保留端口"><a href="#保留端口" class="headerlink" title=" 保留端口"></a><strong><font color="#FF7256"> 保留端口</font></strong></h6><p>Unix系统有保留端口号的概念。只有具有超级用户特权的进程才允许给它自己分配一个保留端口号。</p>
<p>这些端口号介于1～1023之间，一些应用程序（如有名的Rlogin）将它作为客户与服务器之间身份认证的一部分。</p>
<h5 id="查看端口方式"><a href="#查看端口方式" class="headerlink" title=" 查看端口方式"></a><strong><font color="#FF7256"> 查看端口方式</font></strong></h5><p>（1）利用系统内置的命令，可以在命令提示符下使用“netstat ”查 看系统端口状态，可以列出系统正在开放的端口号及其状态；</p>
<p>（2）利用第三方端口扫描软件；</p>
<p>（3）利用“netstat -n”命令，以数字格式显示地址和端口信息。</p>
<h5 id="65535个端口号使用规则"><a href="#65535个端口号使用规则" class="headerlink" title=" 65535个端口号使用规则"></a><strong><font color="#FF7256"> 65535个端口号使用规则</font></strong></h5><p>（1）端口号小于256的定义为常用端口，服务器一般都是通过常用端口号来识别的。任何TCP/IP实现所提供的服务都用1—1023之间的端口号，是由ICANN来管理的；</p>
<p>（2）客户端只需保证该端口号在本机上是惟一的就可以了。客户端口号因存在时间很短暂又称临时端口号；</p>
<p>（3）大多数TCP/IP实现给临时端口号分配1024—5000之间的端口号。大于5000的端口号是为其他服务器预留的。</p>
<h4 id="应用编程接口"><a href="#应用编程接口" class="headerlink" title=" 应用编程接口"></a><strong><font color="#FF7256"> 应用编程接口</font></strong></h4><p>现在常用的编程接口有socket、FTP、HTTP、telnet以及TLI,而Socket有时候也叫做“Berkeley socket”。</p>
<p>常用的socket类型有两种：</p>
<p>a. 流式socket(SOCK_STREAM) ：是一种面向连接的socket，针对于面向连接的TCP服务应用。<br>b. 数据报式socket(SOCK_DGRAM) ：是一种无连接的socket，对应于无连接的UDP服务应用。 </p>
<p>从用户接口意义上讲，还有传输层的TLI接口，是由AT&amp;T开发的，有时也称作XTI。它是传输层为用户提供的应用程序接口，可以用来在传输层进行应用开发。</p>
<h5 id="四类接口"><a href="#四类接口" class="headerlink" title="四类接口"></a>四类接口</h5><h6 id="1-文件类接口"><a href="#1-文件类接口" class="headerlink" title="1.文件类接口"></a>1.文件类接口</h6><p>FTP协议就是文件类接口，基于FTP，用户可以实现文件在网络间的共享和传输；</p>
<h6 id="2-远程过程调用（RPC-Remote-Procedure-Call-Protocol）"><a href="#2-远程过程调用（RPC-Remote-Procedure-Call-Protocol）" class="headerlink" title="2.远程过程调用（RPC: Remote Procedure Call Protocol）"></a>2.远程过程调用（RPC: Remote Procedure Call Protocol）</h6><p>是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易；</p>
<h6 id="3-数据查询接口"><a href="#3-数据查询接口" class="headerlink" title="3.数据查询接口"></a>3.数据查询接口</h6><p>(后补)</p>
<h6 id="4-数据通信类接口"><a href="#4-数据通信类接口" class="headerlink" title="4.数据通信类接口"></a>4.数据通信类接口</h6><p>socket和HTTP可归结为数据通信接口，基于这两种接口用户可以开发网络通信应用程序，以及web页面交互程序。当然如果从编程开发角度看，无论是FTP、HTTP还是telnet，都是基于socket接口开发出来的应用层协议，是对socket接口的进一步封装和抽象，从而为用户提供更高一层的服务和接口。</p>
<p><strong><font color="#FF7256">域名系统:</font></strong></p>
<p>域名系统是一个分布的数据库，它提供将主机名（就是网址）转换成IP地址的服务。DNS （Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。用户通常通过主机名或域名来访问对方的计算机，计算机则通过IP地址查询服务器。所以DNS就提供了域名查找IP 地址和从IP地址反查域名的服务。</p>
<hr>
<h3 id="一、TCP"><a href="#一、TCP" class="headerlink" title="一、TCP"></a><strong><font color="#FF7256">一、TCP</font></strong></h3><blockquote>
<p><strong><font color="#FF7256">TCP（Transmission Control Protocol）: 传输控制协议</font></strong></p>
</blockquote>
<p> <strong><font color="#FF7256">TCP</font></strong>是面向连接的, 可靠的流协议,保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达)的传输层协议。</p>
<p> TCP位于传输层，提供可靠的字节流服务。字节流服务是指将大块数据分割成报文段（segment）为单位的数据包进行管理，为了保证准确性，TCP 协议采用了三次握手（three-way handshaking）策略。握手过程中使用了 TCP 的标志（flag）—— SYN（synchronize）、ACK（acknowledgement）和 FIN（finish）。</p>
<h4 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a><strong><font color="#FF7256">TCP报文头</font></strong></h4><p><img src="http://i4.buimg.com/567571/0d4c229145c13360.png" alt="|center|"></p>
<h5 id="1-端口号"><a href="#1-端口号" class="headerlink" title="1.端口号"></a><strong><font color="#FF7256">1.端口号</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">源端口 (Source Port) :  长度为16位，2个字节。</font></strong><br><strong><font color="#FF7256">目的端口 (Destination Port) :  长度为16位，2个字节。</font></strong></p>
</blockquote>
<p>网络实现的是不同主机的进程间通信，在一个操作系统中，有很多进程，当数据到来时要提交给哪个进程进行处理，就需要用到端口号。</p>
<p>在TCP头中，包括源端口号(Source Port)和目标端口号(Destination Port)。源端口号标识了发送主机的进程,目标端口号标识接受方主机的进程。</p>
<p>而且，IP实现了点到点的数据通信，而TCP实现的是端到端的通信。通信端用一个IP与端口号来唯一标识。IP协议负责将数据传输到目标主机，而TCP可以根据数据报中的端口号，将数据交给相应的程序进行处理。</p>
<h5 id="2-序列号"><a href="#2-序列号" class="headerlink" title="2.序列号"></a><strong><font color="#FF7256">2.序列号</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">发送序列号 (Sequence Number) :  长度为32位，4个字节。</font></strong></p>
</blockquote>
<p>TCP会话的每一端都包含一个32位（bit）的序列号，该序列号被用来跟踪该端发送的数据量。每一个包中都包含序列号，在接收端则通过确认号用来通知发送端数据成功接收。</p>
<p><strong><font color="#FF7256">发送序号：</font></strong></p>
<p>用来标识从 TCP源端向 TCP目的端发送的数据字节流，它表示在一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从A到B），后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025～2048字节，那么该报文段的序号值就是ISN+1025。另外一个传输方向（从B到A）的TCP报文段的序号值也具有相同的含义。</p>
<blockquote>
<p><strong><font color="#FF7256">确认端口号 (Acknowledgment Number) :  长度为32位，4个字节。</font></strong></p>
</blockquote>
<p><strong><font color="#FF7256">确认序号：</font></strong></p>
<p>包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1。只有 ACK标志为 1时确认序号字段才有效。</p>
<p>假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。 </p>
<p>TCP为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。</p>
<h5 id="3-偏移-首部长度-Offset"><a href="#3-偏移-首部长度-Offset" class="headerlink" title="3.偏移 (首部长度 Offset)"></a><strong><font color="#FF7256">3.偏移 (首部长度 Offset)</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">该字段占用4位，用来表示报文首部的长度，单位是4Byte。如：headLen = ((packet[12]&gt;&gt;4)&amp;0x0F)*4;</font></strong></p>
</blockquote>
<p>这里的偏移实际指的是TCP首部的长度，它用来表明TCP首部中32 bit字的数目，通过它可以知道一个TCP包它的用户数据是从哪里开始的。这个字段占4bit,如4bit的值是0101,则说明TCP首部长度是5 <em> 4 = 20字节。 所以TCP的首部长度最大为15 </em> 4 = 60字节。然而没有可选字段，正常长度为20字节。</p>
<h5 id="4-预留6位-Reserved"><a href="#4-预留6位-Reserved" class="headerlink" title="4.预留6位 (Reserved)"></a><strong><font color="#FF7256">4.预留6位 (Reserved)</font></strong></h5><p>长度为6位，作为保留字段，暂时没有什么用处。</p>
<h5 id="5-TCP-Flags"><a href="#5-TCP-Flags" class="headerlink" title="5.TCP Flags"></a><strong><font color="#FF7256">5.TCP Flags</font></strong></h5><blockquote>
<p><strong>标志(6bit):在TCP首部中有6个标志比特，他们中的多个可同时被置为1 。</strong></p>
</blockquote>
<p><strong><font color="#FF7256">URG标志：</font></strong></p>
<p>紧急指针(Urgent Pointer)有效，我们称携带ACK标志的TCP报文段为确认报文段；</p>
<p><strong><font color="#FF7256">ACK标志：</font></strong></p>
<p>确认序号有效；</p>
<p><strong><font color="#FF7256">PSH标志：</font></strong></p>
<p>指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中）；</p>
<p><strong><font color="#FF7256">RST标志：</font></strong></p>
<p>表示要求对方重新建立连接，我们称携带RST标志的TCP报文段为复位报文段；</p>
<p><strong><font color="#FF7256">SYN标志：</font></strong></p>
<p>同步序号用来发起建立一个连接，我们称携带SYN标志的TCP报文段为同步报文段；</p>
<p><strong><font color="#FF7256">FIN标志：</font></strong></p>
<p>发送端完成发送任务(即断开连接)，我们称携带FIN标志的TCP报文段为结束报文段。</p>
<h5 id="6-窗口大小-window"><a href="#6-窗口大小-window" class="headerlink" title="6.窗口大小 (window)"></a><strong><font color="#FF7256">6.窗口大小 (window)</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">长度为16位，2个字节，表示源方法最多能接受的字节数。</font></strong></p>
</blockquote>
<p>是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</p>
<h5 id="7-校验和-CheckSum"><a href="#7-校验和-CheckSum" class="headerlink" title="7.校验和 (CheckSum)"></a><strong><font color="#FF7256">7.校验和 (CheckSum)</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">长度为16位，2个字节。</font></strong></p>
</blockquote>
<p>由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。<strong><font color="#FF7256">这也是TCP可靠传输的一个重要保障。</font></strong></p>
<p>校验和覆盖了整个的TCP报文段:TCP头部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</p>
<h5 id="8-紧急指针-：-UrgentPointer"><a href="#8-紧急指针-：-UrgentPointer" class="headerlink" title="8.紧急指针 ：(UrgentPointer)"></a><strong><font color="#FF7256">8.紧急指针 ：(UrgentPointer)</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">长度为16位，2个字节。</font></strong></p>
</blockquote>
<p>只有当URG标志置为1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。</p>
<blockquote>
<p><strong>以上8个字段是TCP包头必须要有的字段，也称固有字段，长度为20个字节。</strong></p>
</blockquote>
<h5 id="9-TCP选项-Options"><a href="#9-TCP选项-Options" class="headerlink" title="9.TCP选项 (Options)"></a><strong><font color="#FF7256">9.TCP选项 (Options)</font></strong></h5><p>此项是可选项(可有可无)，抓包时具体分析。</p>
<h4 id="三次握手建立连接-three-way-handshake"><a href="#三次握手建立连接-three-way-handshake" class="headerlink" title="三次握手建立连接 (three-way handshake)"></a><strong><font color="#FF7256">三次握手建立连接 (three-way handshake)</font></strong></h4><p><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-8-23/86650194.jpg" alt=""></p>
<p>第一次握手：客户端发送syn包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认;</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN(ack=x+1)，同时自己也发送一个SYN包(seq=y)，即SYN+ACK包，此时服务器进入SYN_RECV状态;</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p>三次握手确定了双方间包的序号、最大接受数据的大小(window)以及MSS(Maximum Segment Size)。MSS = MTU - IP头 - TCP头(TCP携带可选项,大小为12),MTU表示最大传输单元，我们在IP头分析的时候会讲到,它一般为1500个字节。IP头和TCP 头部带可选选项的时候都是20个字节。这样的话MSS=1500 - 20 -20 = 1460，最大传输数据为：1500 - 20 - ( 20 + 12 ) = 1448。MSS限制了TCP包携带数据的大小,它的意思就是当应用层向传输层提交数据通过TCP协议进行传输时，如果应用层的数据&gt;MSS就必须分段，分成多个段，逐个的发过去。<strong><font color="#FF7256">(可以通过wirshar抓包进行分析)</font></strong></p>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a><strong><font color="#FF7256">数据传输</font></strong></h4><p><img src="http://i1.buimg.com/567571/315e7f846f5afbac.png" alt=""></p>
<p> <strong><font color="#FF7256">TCP采用一种名为“带重传功能的肯定确认（positive acknowledge with retransmission）”的技术作为提供可靠数据传输服务的基础。</font></strong>这项技术要求接收方收到数据之后向源站回送确认信息ACK。发送方对发出的每个分组都保存一份记录，在发送下一个分组之前等待确认信息。发送方还在送出分组的同时启动一个定时器，并在定时器的定时期满而确认信息还没有到达的情况下，重发刚才发出的分组。为了避免由于网络延迟引起迟到的确认和重复的确认，协议规定在确认信息中稍带一个分组的序号，使接收方能正确将分组与确认关联起来。</p>
<p>虽然网络具有同时进行双向通信的能力，但由于在接到前一个分组的确认信息之前必须推迟下一个分组的发送，简单的肯定确认协议浪费了大量宝贵的网络带宽。为此， TCP使用滑动窗口的机制来提高网络吞吐量，同时解决端到端的流量控制。</p>
<h5 id="a-超时重传"><a href="#a-超时重传" class="headerlink" title="a.超时重传"></a>a.超时重传</h5><p><strong><font color="#FF7256">超时重传机制用来保证TCP传输的可靠性。</font></strong>其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。每次发送数据包时，发送的数据报都有seq号，接收端收到数据后，会回复ack进行确认，表示某一seq号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。</p>
<p>对于实现而言，关键之处就在于超时和重传的策略，即怎样决定超时间隔和如何确定重传频率。</p>
<p>TCP管理4种不同的定时器：</p>
<h6 id="重传定时器-Retransmission-Timer-："><a href="#重传定时器-Retransmission-Timer-：" class="headerlink" title="重传定时器(Retransmission Timer)："></a><font color="#FF7256">重传定时器(Retransmission Timer)：</font></h6><p>当希望收到另一端的确认时使用。</p>
<h6 id="坚持定时器-Persistent-Timer-："><a href="#坚持定时器-Persistent-Timer-：" class="headerlink" title="坚持定时器(Persistent Timer)："></a><font color="#FF7256">坚持定时器(Persistent Timer)：</font></h6><p>使窗口信息保持不断流动，即使另一端关闭了其接收窗口。</p>
<p>TCP通过让接收方指明希望从发送方接收的数据字节数（即窗口大小）来进行流量控制。如果窗口大小为0会发生什么情况呢？这将有效阻止发送方传送数据，直到窗口变为非0为止。<br>ACK的传输并不可靠，也就是说，TCP不对ACK报文段进行确认，TCP只确认那些包含有数据的ACK报文段。</p>
<ol>
<li><p>坚持定时器<br>假设一个场景：如果一个确认丢失了，则双方就有可能因为等待对方而使连接终止，接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。为防止这种死锁情况的发生，发送方使用一个坚持定时器（persist timer）来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查（window probe）。<br>计算坚持定时器时使用了普通的TCP指针退避，窗口探查报文包含一个字节的数据。<br>坚持状态与21章介绍的重传超时之间一个不同的特点就是TCP从不放弃发送窗口探查。这些探查每隔60秒发送一次，这个过程将持续到窗口打开或者应用进程使用的连接被终止。</p>
</li>
<li><p>糊涂窗口综合症<br>糊涂窗口综合症：接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方可以通过这个小窗口发送少量的数据（而不是等待其它的数据以便发送一个大的报文段），即，少量的数据通过连接交换，而不是满长度的报文段，TCP的传输效率可想而知。<br>如何避免“糊涂窗口综合症”：<br>接收方：接收方不通告小窗口，除非增加一个报文段(MMS)或者接收方缓存空间的一半，否则通告为0。</p>
</li>
</ol>
<p>发送方：<br>(1)可以发送一个满长度的报文段(MMS)<br>(2)可以发送至少接收方通告窗口一半的报文段<br>(3)能够发送手头的所有数据并且不希望接收ACK，或者该连接禁止了Nagle算法时，可以发送任意数据。</p>
<p>坚持定时器工作流程:</p>
<p>(1)发送端收到0窗口通告后，就启动坚持定时器，并在定时器溢出的时候向客户端查询窗口是否已经增大。<br>(2)在定时器未到，就收到非零通告，则关闭该定时器，并发送数据。<br>(3)若定时器已到，还没有收到非零通告，就发探查报文。<br>(4)如果探查报文ACK的通告窗口为0，就将坚持定时器的值加倍，TCP的坚持定时器使用1，2，4，8，16……64秒这样的普通指数退避序列来作为每一次的溢出时间，重复1、2、3步，如果通告窗口非零，发送数据，关闭定时器。</p>
<h6 id="保活定时器-Keeplive-Timer-："><a href="#保活定时器-Keeplive-Timer-：" class="headerlink" title="保活定时器(Keeplive Timer)："></a><font color="#FF7256">保活定时器(Keeplive Timer)：</font></h6><p>检测一个空闲连接的另一端何时崩溃或重启。</p>
<p>现实中可能存在这么一种空闲TCP连接：没有任何数据流通过。也就是说，如果TCP连接的双方都没有向对方发送数据，则在两个TCP模块之间不交换任何信息，这意味着我们可以启动一个客户与服务器建立连接，然后长时间不使用，而连接依然保持。中间的路由器可以崩溃和重启，电话线可以被挂断再连接，但只要两端的主机没有被重启，则连接依然保持建立。</p>
<p>然而，许多时候一个服务器希望知道客户主机是否崩溃并关机或者崩溃又重新启动，许多实现提供的保活定时器可以提供这种能力。保活并不是TCP规范中的一部分。</p>
<p>保活定时器工作原理：<br>如果一个给定的连接在2小时内没有任何动作，那么服务器就向客户发送一个探查报文段。客户主机必须处于以下4个状态之一：</p>
<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方的正常工作的，服务器在2小时内将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应，服务器将不能收到对探查的响应，并在75秒后超时，总共发送10个探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。这是服务器将收到一个对其保活探查的响应，但这个响应是一个RST复位，使得服务器终止这个连接。</li>
<li>客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与2之间的区别，它所能发现的就是没有收到探查的响应。</li>
</ol>
<p>服务器不用关注客户主机被关闭和重新启动的情况，当系统被操作员关闭时，所有的应用进程也被终止，这会使客户的TCP在连接上发出一个FIN。接收到FIN将使服务器的TCP向服务器进程报告文件结束，使服务器可以检测到这个情况。</p>
<h6 id="2MSL定时器（Time-Wait-Timer-："><a href="#2MSL定时器（Time-Wait-Timer-：" class="headerlink" title="2MSL定时器（Time_Wait Timer)："></a><font color="#FF7256">2MSL定时器（Time_Wait Timer)：</font></h6><p>测量一个连接处于TIME_WATI状态的时间。</p>
<p>在连接终止期使用，当TCP关闭连接时，并不认为这个连接就真正关闭了，在时间等待期间，连接还处于一种中间过度状态。这样就可以时重复的fin报文段在到达终点后被丢弃，这个计时器的值通常设置为一格报文段寿命期望值的两倍。</p>
<p>补充：</p>
<p>2MSL定时器：MSL是报文段最大生存时间(Maximum Segment Lifetime)，设置这个定时器有两个目的：</p>
<p>其一，是为了测量连接处于TIME_WAIT状态的时间，这样可以让TCP再次发送最后的ACK以防止这个ACK丢失(如果丢失，另一端会重传FIN)。</p>
<p>其二，为允许老的重复分节在网络中消逝。具体可以解释为，如果一个TCP连接在断开之前有迷途分节尚未消逝，在断开该TCP连接之后立刻重启一个同样的连接(双方的IP地址和端口port相同)，这时之前的迷途的老分节可能对新的新的TCP连接接收，从而造成未定义的错误。为了避免这种情况，TCP规定在TIME_WAIT状态，不能启动一个连接的化身。既然TIME_WAIT状态维持2MSL，这就保证了一个连接上的分组及其应该在 2MSL内都会消失。</p>
<h6 id="指数退避："><a href="#指数退避：" class="headerlink" title="指数退避："></a><font color="#FF7256">指数退避：</font></h6><p>书中检查连续重传之间不同的时间差，它们取整后分别是1、3、6、12、24、48和多个64秒，其中第一次发送后设置的超时时间设置为1.5秒。（2的N次方*1.5秒）</p>
<h6 id="1-往返时间测量"><a href="#1-往返时间测量" class="headerlink" title="1.往返时间测量"></a>1.往返时间测量</h6><p>RTT(往返时间)：指发送端发送TCP报文段开始到接收到对方的确定所使用的时间。</p>
<blockquote>
<p>TCP超时与重传中最重要的部分就是对一个给定连接的往返时间的测试。由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。</p>
</blockquote>
<p>RTO(超时重传时间)：发送端发送TCP报文段后，在RTO时间内没有收到对方确定，即重传该报文段。</p>
<p>最早的TCP曾经用了一个非常简单的公式来估计当前网络的状况，如下：</p>
<p>R&lt;-aR+(1-a)M<br>RTP=Rb</p>
<p>其中a是一个经验系数为0.9，称为平滑因子，b通常为2。这个数值是可以被修改的。这个公式是说用旧的RTT(R)和新的RTT(M)综合到一起来考虑新的RTT(R)的大小。每次进行新测量时，这个被平滑的RTT将得到更新。每个新估计的90%来自前一个估计，而10%则取自新的测试。</p>
<p>但是，在RTT变化范围很大时，使用这个方法无法跟上这种变化，从而引起不必要的重传。当网络已经处于饱和状态时，不必要的和重传会增加网络的负载，对网络而言就像在火上浇油。于是就有下面的修正公式：</p>
<p>Err=M-A<br>A&lt;-A+gErr<br>D&lt;-D+h(|Err|-D)<br>RTO=A+4D</p>
<p>A 平滑的RTT(均值估计器)<br>D 平滑的方差<br>g 增量<br>h 方差的增益</p>
<p>RTO值基于RTT的均值和方差，这更好的响应了RTT的变化。</p>
<p>karn算法（重传多义性）</p>
<p>假如发送一个分组，当发生超时，RTO指数退避，重传该分组，然后收到ACK。此时但并不能确定这个ACK是针对第一个分组还是重传分组，这就是重传多义性问题。</p>
<p>karn算法针对这个问题</p>
<p>(1)对于超时重传的数据报的确认，不更新RTT。<br>(2)要注意的是：重传的情况下，RTO不用上面的公式计算，而采用一种叫做“指数退避”的方式。RTO指数退避，下一次传送就使用这个RTO值。<br>(3)重传数据确认之后，再次发送的数据如果正常被确定，恢复Jacobson 1988公式，更新RTO和RTT。</p>
<h6 id="2-拥塞避免算法"><a href="#2-拥塞避免算法" class="headerlink" title="2.拥塞避免算法"></a>2.拥塞避免算法</h6><p>该算法假定由于分组受到损坏引起的丢失是非常少的，因此分组丢失就意味着源主机和目的主机之间的某处网络上发生了拥塞。有两种分组丢失的指示：</p>
<p>a.发生超时</p>
<p>b.接收到重复的确认</p>
<p>数据在传输的时候不能只使用一个窗口协议，我们还需要有一个拥塞窗口来控制数据的流量，使得数据不会一下子都跑到网路中引起“拥塞”。也曾经提到过，拥塞窗口最初使用指数增长的速度来增加自身的窗口，直到发生超时重传，再进行一次微调。但是没有提到，如何进行微调，拥塞避免算法和慢启动门限就是为此而生。</p>
<p>所谓的慢启动门限就是说，当拥塞窗口超过这个门限的时候，就使用拥塞避免算法，而在门限以内就采用慢启动算法。所以这个标准才叫做门限，通常，拥塞窗口记做cwnd，慢启动门限记做ssthresh。下面我们来看看拥塞避免和慢启动是怎么一起工作的。</p>
<p>拥塞避免算法和慢启动算法是两个目的不同、独立的算法。我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点，拥塞避免算法和慢启动算法通常一起使用：</p>
<p>每个连接维持两个变量: 拥塞窗口( cwnd )  、慢启动门限( ssthresh )</p>
<p>算法概要：</p>
<p>a.对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节。</p>
<p>b.TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。</p>
<p>c.当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半[下图中的12]（cwnd 和接收方通告窗口大小的最小值，但最少为2个报文段）。此外，如果是超时引起了拥塞，则 cwnd被设置为1个报文段（这就是慢启动）。</p>
<p>d.当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果cwnd小于或等于ssthresh，则正在进行慢启动，否则正在进行拥塞避免。 慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止（因为我们记录了在步骤2 中给我们制造麻烦的窗口大小的一半），然后转为执行拥塞避免。</p>
<p>cwnd增加方式：</p>
<p>慢启动初始cwnd为1，每收到一个确定就加1，成指数增长。<br>拥塞避免算法在每个RTT内增加 1/cwnd 个报文，成线性增长。<br>慢启动根据收到的ACK次数增加cwnd，而拥塞避免算法在一个RTT不管收有多少ACK也只增加一次。</p>
<h6 id="3-快速重传和快速恢复算法"><a href="#3-快速重传和快速恢复算法" class="headerlink" title="3.快速重传和快速恢复算法"></a>3.快速重传和快速恢复算法</h6><p>如果收到3个重复ACK，可认为该报文段已经丢失，此时无需等待超时定时器溢出，直接重传丢失的包，这就叫快速重传算法。而接下来执行的不是慢启动而是拥塞避免算法，这就叫快速恢复算法。</p>
<p>(1)当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半，重传丢失的报文段，设置cwnd为ssthresh加上3倍的报文段大小。</p>
<p>(2)每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组(如果新的cwnd允许发送)。</p>
<p>(3)当下一个确认新数据的ACK到达时，设置cwnd为ssthresh(在第1步中设置的值)。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。</p>
<h6 id="4-ICMP（Internet-Control-Message-Protocol）Internet控制报文协议）差错"><a href="#4-ICMP（Internet-Control-Message-Protocol）Internet控制报文协议）差错" class="headerlink" title="4.ICMP（Internet Control Message Protocol）Internet控制报文协议）差错"></a>4.ICMP（Internet Control Message Protocol）Internet控制报文协议）差错</h6><p>TCP能够遇到的最常见的ICMP差错就是源站抑制、主机不可达和网络不可达。</p>
<p>(1)源站抑制的ICMP将拥塞窗口cwnd置为1个报文段，并发起慢启动，慢启动门限ssthresh不变，窗口将打开直至开放了所有的通路(受窗口大小和往返时间的限制)或者发生了拥塞。<br>(2)主机不可达或网络不可达的ICMP将被忽略，因为这两上差错都被认为是短暂现象。</p>
<h6 id="5-重新分组"><a href="#5-重新分组" class="headerlink" title="5.重新分组"></a>5.重新分组</h6><p>当TCP超时并重传时，它不一定需要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能（当然，这个较大的报文段不能够超过接收方声明的MSS）</p>
<h5 id="b-快速重传"><a href="#b-快速重传" class="headerlink" title="b.快速重传"></a>b.快速重传</h5><p>接受数据一方发现有数据包丢掉了。就会发送ack报文告诉发送端重传丢失的报文。如果发送端连续收到标号相同的ack包，则会触发客户端的快速重传。比较超时重传和快速重传，可以发现超时重传是发送端在傻等超时，然后触发重传;而快速重传则是接收端主动告诉发送端数据没收到，然后触发发送端重传。</p>
<h5 id="c-流量控制-滑动窗口技术"><a href="#c-流量控制-滑动窗口技术" class="headerlink" title="c.流量控制(滑动窗口技术)"></a>c.流量控制(滑动窗口技术)</h5><p>这里主要说TCP滑动窗流量控制。TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 <strong><font color="#FF7256">滑动窗可以是提高TCP传输效率的一种机制。</font></strong></p>
<p>滑动窗口技术是简单的带重传的肯定确认机制的一个更复杂的变形，它允许发送方在等待一个确认信息之前可以发送多个分组。如下图所示，发送方要发送一个分组序列，滑动窗口协议在分组序列中放置一个固定长度的窗口，然后将窗口内的所有分组都发送出去；当发送方收到对窗口内第一个分组的确认信息时，它可以向后滑动并发送下一个分组；随着确认的不断到达，窗口也在不断的向后滑动。</p>
<p><img src="http://i4.buimg.com/567571/12099c8f90d23fcb.png" alt="|center|"></p>
<h5 id="d-拥塞控制"><a href="#d-拥塞控制" class="headerlink" title="d.拥塞控制"></a>d.拥塞控制</h5><p>滑动窗用来做流量控制。流量控制只关注发送端和接受端自身的状况，而没有考虑整个网络的通信情况。拥塞控制，则是基于整个网络来考虑的。考虑一下这样的场景：某一时刻网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。为此，TCP引入了拥塞控制策略。拥塞策略算法主要包括：慢启动，拥塞避免，拥塞发生，快速恢复。</p>
<h4 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a><strong><font color="#FF7256">四次挥手断开连接</font></strong></h4><p><img src="http://i4.buimg.com/567571/f1b563d05cba2cf0.png" alt=""></p>
<p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但此时主动关闭方还可以接受数据；</p>
<p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)；</p>
<p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了；</p>
<p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
<hr>
<p>CLOSED： 表示初始状态；</p>
<p>LISTEN：表示服务器端的某个SOCKET处于监听状态，可以接受连接了；</p>
<p>SYN_RCVD： 表示接收到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态；</p>
<p>SYN_SENT：与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文；</p>
<p>ESTABLISHED：表示连接已经建立了；</p>
<p>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到；</p>
<p>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接；</p>
<p>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态；</p>
<p>CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接；</p>
<p>CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接；</p>
<p>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</p>
<ol>
<li>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</li>
</ol>
<p>因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<ol>
<li>为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</li>
</ol>
<p>因为，虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p>
<hr>
<p>最后附上TCP的状态图</p>
<p><img src="http://imgchr.com/images/TCP.png" alt=""></p>
<h3 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a><strong><font color="#FF7256">二、UDP</font></strong></h3><p>UDP协议也是传输层协议，它是无连接，不保证可靠的传输层协议。</p>
<p><img src="http://i2.buimg.com/4851/6bd29b6a3005cf3a.png" alt=""></p>
<p> UDP是传输层协议，和TCP协议处于一个分层中，但是与TCP协议不同，UDP协议并不提供超时重传，出错重传等功能，也就是说其是不可靠的协议。</p>
<p> UDP协议是英文UserDatagramProtocol的缩写，即用户数据报协议，主要用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的C/S模式的网络应用都需要使用UDP协议。UDP协议直接位于IP（网际协议）协议的顶层。</p>
<p><strong><font color="#FF7256">特点：</font></strong> </p>
<ol>
<li>无连接，发送数据之前不需要建立连接。开销和发送之前的时间延迟较短。 </li>
<li>尽最大努力交付。（可以采取一定策略实现可靠传输）</li>
<li>面向报文，UDP对应用程序交付的报文，添加UDP首部后直接交给IP层。不合并，不拆分。</li>
<li>没有拥塞控制，网络拥塞不会使源主机发送率降低。</li>
<li>UDP支持一对一，一对多，多对一的交互通信</li>
<li>UDP首部开销较小，8字节（TCP为20字节、IP为20字节）</li>
</ol>
<p>UDP首部格式</p>
<blockquote>
<p>源端口：2字节 =   16bit =0 ~ 65535 ( 注：端口与TCP端口意义一样 )<br>   目的端口：2字节</p>
</blockquote>
<p>由于很多软件需要用到UDP协议，所以UDP协议必须通过某个标志用以区分不同的程序所需要的数据包。端口号的功能就在于此，例如某一个UDP程序A在系统中注册了3000端口，那么，以后从外面传进来的目的端口号为3000的UDP包都会交给该程序。端口号理论上可以有2^16这么多。因为它的长度是16个bit。</p>
<blockquote>
<p>长度(Length)：2字节  标识UDP头的长度(用户数据包的长度)（最短为8字节，仅有头部）</p>
</blockquote>
<p>UDP可以很长很长，可以有65535字节那么长。但是一般网络在传送的时候，一次一般传送不了那么长的协议（涉及到MTU的问题），就只好对数据分片，当然，这些是对UDP等上级协议透明的，UDP不需要关心IP协议层对数据如何分片。</p>
<blockquote>
<p>检验和(Checksum)：2字节</p>
</blockquote>
<p>这是一个可选的选项，并不是所有的系统都对UDP数据包加以检验和数据(相对TCP协议的必须来说)，但是RFC中标准要求，发送端应该计算检验和。</p>
<p>UDP检验和覆盖UDP协议头和数据，这和IP的检验和是不同的，IP协议的检验和只是覆盖IP数据头，并不覆盖所有的数据。UDP和TCP都包含一个伪首部，这是为了计算检验和而摄制的。伪首部甚至还包含IP地址这样的IP协议里面都有的信息，目的是让UDP两次检查数据是否已经正确到达目的地。如果发送端没有打开检验和选项，而接收端计算检验和有差错，那么UDP数据将会被悄悄的丢掉（不保证送达），而不产生任何差错报文。</p>
<p><strong><font color="#FF7256">UDP和ARP之间的交互式用</font></strong></p>
<p>这是不常被人注意到的一个细节，这是针对一些系统地实现来说的。当ARP缓存还是空的时候。UDP在被发送之前一定要发送一个ARP请求来获得目的主机的MAC地址，如果这个UDP的数据包足够大，大到IP层一定要对其进行分片的时候，想象中，该UDP数据包的第一个分片会发出一个ARP查询请求，所有的分片都辉等到这个查询完成以后再发送。事实上是这样吗？</p>
<p>结果是，某些系统会让每一个分片都发送一个ARP查询，所有的分片都在等待，但是接受到第一个回应的时候，主机却只发送了最后一个数据片而抛弃了其他，这实在是让人匪夷所思。这样，因为分片的数据不能被及时组装，接受主机将会在一段时间内将永远无法组装的IP数据包抛弃，并且发送组装超时的ICMP报文（其实很多系统不产生这个差错），以保证接受主机自己的接收端缓存不被那些永远得不到组装的分片充满。</p>
<p><strong><font color="#FF7256">应用方向：</font></strong></p>
<p>包总量较少的通信(DNS, SNMP等)；<br>视频,音频等多媒体通信(即时通信)；<br>限定于LAN等特定网络中的应用通信；<br>广播通信(广播, 多播)</p>
<h3 id="三、IP协议"><a href="#三、IP协议" class="headerlink" title="三、IP协议"></a><strong><font color="#FF7256">三、IP协议</font></strong></h3><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，ICMP，IGCP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议TCP或UDP要做的事情。所以这也就出现了TCP是一个可靠的协议，而UDP就没有那么可靠的区别。</p>
<p>IP（Internet Protocol）网际协议位于网络层。其作用是把各种数据包传送给对方，需要满足各类条件，最重要的两个条件便是 IP 地址 和 MAC 地址。IP 地址可以和 MAC 地址进行配对，IP 地址可变换，但 MAC 地址基本不会更改。</p>
<p>在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP （Address Resolution Protocol）协议。 ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p>
<p><strong><font color="#FF7256">特点：</font></strong> </p>
<ol>
<li><p>不可靠性（unreliable）是它不能保证 I P数据报能成功地到达目的地。 I P仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区， I P有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP） 。</p>
</li>
<li><p>无连接性（connectless）的意思是I P并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明， I P数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是B） ，每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。</p>
</li>
</ol>
<p>它提供不可靠、无连接的服务，也即依赖其他层的协议进行差错控制。在局域网环境，IP协议往往被封装在以太网帧中传送。而所有的TCP、UDP、ICMP、IGMP数据都被封装在IP数据报中传送。如图下图所示：</p>
<p><img src="http://imgchr.com/images/TCP-IP73318.png" alt="TCP/IP报文封装"></p>
<h5 id="IP报文头格式"><a href="#IP报文头格式" class="headerlink" title="IP报文头格式"></a><strong><font color="#FF7256">IP报文头格式</font></strong></h5><p><img src="http://imgchr.com/images/IP.png" alt="IP协议头"></p>
<p>　　●版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。</p>
<p>　　●报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。<br>　<br>　　●服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。实际上，大部分主机会忽略这个字段，但一些动态路由协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。</p>
<p>　　●总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。</p>
<p>　　●标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。</p>
<p>　　●标志位字段(Flag)：占3比特。标志一份数据报是否要求分段。</p>
<p>　　●段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。</p>
<p>　　●生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。</p>
<p>　　●协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。</p>
<p>　　●头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。</p>
<p>　　●源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。</p>
<p>　　●可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。</p>
<h5 id="IP路由选择"><a href="#IP路由选择" class="headerlink" title="IP路由选择"></a><strong><font color="#FF7256">IP路由选择</font></strong></h5><p>如果目的主机与源主机直接相连或都在一个共享网络上,那就直接把包发送到目的主机,<br>如果不是,那把IP数据报送到默认路由器,由它转发。路由器使用路由表保存自己知道的网络的信息,它包括:</p>
<p>目的IP地址：它可以是一个完整的主机地址或是一个网络地址,主机地址主机号非0,网络地址主机号为0。</p>
<p>下一个路由器地址：这个路由器是与当前路由器直接相连的路由器,或是直接相连的网络ip地址(考虑到一台电脑有两个网口,其中一个连接目的地址)标志，其中一个表明目的IP地址是网络地址还是主机地址。另一个指明下一站是真正的路由器还是网络接口为数据报的传输指定一个网络接口。</p>
<p>每个路由器都不需要知道所有网络的信息,当它发现要转发的包不在与自己直接连接的网络时,就会把这个包发给下一个路由器,一直到终点。</p>
<p>IP路由选择主要完成以下功能：</p>
<p>1 搜索路由表,寻找能与目的地址完全匹配的条目,如果找到直接发给它；<br>2 搜索路由表,寻找能与目的网络号完全匹配的条目,如果找到将包发给这一条目指定的下一个路由器或是网络接口；<br>3 搜索路由表,寻找默认条目,如果找到把这个报文发给它。如果都不成功,将不再发送这个包,向源地址发送一个ICMP不可达报文，使用网络号而不是具体主机可以减少路由表的大小。</p>
<h5 id="子网编码"><a href="#子网编码" class="headerlink" title=" 子网编码"></a><strong><font color="#FF7256"> 子网编码</font></strong></h5><ol>
<li>子网寻址：</li>
</ol>
<p>IP地址分成A类,B类,C类这三种,但是A和B又太大了 而现在IP地址不够用,所以需要使用子网寻址的办法将IP地址进行进一步划分,将主机号再分成子网号与主机号，如A类的网络地址为255.0.0.0，某个A类地址为11.22.33.44，这时第一个数(11)就是网络号，后面三个数(22.33.44)就是主机号。使用子网寻址技术就是把后面三个(22.33.44)再划分成子网与主机号,如把第二与第三个数字看成是子网号(22.33),最后一位是主机号(44)，这样增加了可用的IP地址数目，另外这一过程对路由器不透明,所以路由器知道怎样把一个包正确的发到对应的子网中去。</p>
<ol>
<li>子网掩码：</li>
</ol>
<p>由于使用了子网寻址,所以不可以直接使用A类的网络地址与主机地址来判断一台主机是不是在同一网络上,这时需要使用子网掩码来进行区分子网号与主机号,有了它,主机可以确定IP数据报的目的是：</p>
<ol>
<li>本子网中主机,，</li>
<li>本网络中其它子网主机，</li>
<li>其它网络主机</li>
</ol>
<p>如下：</p>
<p>IP地址:11.33.44.55，子网掩码为255.255.255.0(在校园网的设定中)，子网掩码是由32bit的二进制数字序列,形式为是一连串的1和一连串的0，IP地址的定义是网络号+主机号。但是现在所有的主机都要求子网编址，也就是说，把主机号在细分成子网号+主机号。最终一个IP地址就成为 网络号码+子网号+主机号。例如一个B类地址：210.30.109.134。例如：255.255.255.0(二进制就是11111111.11111111.11111111.00000000)对于刚才的那个B类地址，因为210.30是网络号，那么后面的109.134就是子网号和主机号的组合，又因为子网掩码只有后八bit为0，所以主机号就是IP地址的后八个bit，就是134，而剩下的就是子网号码-109。，因为它是11，所以是一个A类网络，从掩码中可以知道它所在子网为33.44，主机号为55，如果它要发一个ip包给11.33.44.66,那从子网掩码中可以知道目标主机与源主机在同一子网上，可以直接发送。如果要发给11.22.33.44 那从子网掩码知道目标是在同一网络中不在同一子网中，到12.33.44.55那从A类地址的掩码就可以直接判断不是同一网络内了。</p>
<h5 id="特殊的IP"><a href="#特殊的IP" class="headerlink" title=" 特殊的IP"></a><strong><font color="#FF7256"> 特殊的IP</font></strong></h5><p>在电脑设置中,常用到127.0.0.1,这是一个回环地址,发给它的包会返回给自己,那还有没有其它的特殊IP呢</p>
<ol>
<li>网络号与主机号都是0；</li>
<li>网络号是0,主机号不是0；</li>
</ol>
<p>上面两个出现在自己的IP地址还不知道的条件下,如使用BOOTP协议进行启动,只能用于初始化过程。</p>
<ol>
<li>127.x.x.x,回环地址,注意后面三个数都是任意的,我们常用127.0.0.1并不表示127.88.99.110不是回环地址；</li>
<li>网络号与主机号都是255,也就是255.255.255.255,这个是受限广播,表示向当前子网广播,只可作为目的而不可作为源地址；</li>
<li>主机号为255,这表示向某个子网广播；</li>
<li>子网和主机号都为255,表示向所有子网,及每个子网下所有主机都进行广播。</li>
</ol>
<p>注：0可以看成是本,如主机号为0表示本主机,网络号为0表示本网络</p>
<p>总结:</p>
<ol>
<li>IP协议的特点是:不可靠,无连接</li>
<li>IP包格式,注意在包格式中有标志位,说明包内数据的类型</li>
<li>路由方式,就是如果是直连就直接发送,如果不直连,查找到目的网络的通路并转发,如果没有找到到对方网络的通路,则转给默认路由器,如果没有指定默认路由,那返回一个ICMP错误</li>
<li>子网编码,它的出现是为了提高ip地址利用率,是把ABC类IP地址的主机部分分成子网与主机部分<br>另外对应子网编码的是子网掩码,帮助主机判断目标地址的位置信息</li>
<li>特殊的IP,主要有广播IP,全0IP与回环地址</li>
</ol>
<h5 id="分片解释"><a href="#分片解释" class="headerlink" title="分片解释"></a><strong><font color="#FF7256">分片解释</font></strong></h5><p>以太网的MTU是1500，你可以用 netstat -i 命令查看这个值。如果IP层有数据包要传，而且数据包的长度超过了MTU，那么IP层就要对数据包进行分片（fragmentation）操作，使每一片的长度都小于或等于MTU。我们假设要传输一个UDP数据包，以太网的MTU为1500字节，一般IP首部为20字节，UDP首部为8字节，数据的净荷（payload）部分预留是1500-20-8=1472字节。如果数据部分大于1472字节，就会出现分片现象。</p>
<h4 id="四、以太网帧格式"><a href="#四、以太网帧格式" class="headerlink" title="四、以太网帧格式"></a><strong><font color="#FF7256">四、以太网帧格式</font></strong></h4><p><img src="http://imgchr.com/images/181f0b.png" alt=""></p>
<ol>
<li><p>其中的源地址和目的地址是指网卡的硬件地址（也叫MAC 地址），长度是48 位，是在网卡出厂时固化的。</p>
</li>
<li><p>注意网卡芯片（例如<a href="http://www.cnblogs.com/feitian629/archive/2012/11/16/2774065.html" target="_blank" rel="external"><strong><font color="#FF7256">DM9000A</font></strong> </a>）收到的数据就是如上所示的一长串数据；其中包括以太网帧头、IP报报头、传输层协议段头、应用层所需数据。</p>
</li>
<li><p>以太网帧中的数据长度规定最小46 字节，最大1500 字节，ARP 和RARP 数据包的长度不够46 字节，要在后面补填充位。最大值1500 称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包度大于拨号链路的MTU了，则需要对数据包进行分片fragmentation）。ifconfig 命令的输出中也有“MTU：1500”。注意，MTU 个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。</p>
</li>
</ol>
<p>ARP协议是通过IP地址获得对应的MAC地址，称为地址解析协议；<br>RARP协议是通过MAC地址来获得对应的IP地址，称为逆向地址解析协议。</p>
<h5 id="1-MTU最大传输单元"><a href="#1-MTU最大传输单元" class="headerlink" title="1.MTU最大传输单元"></a><strong><font color="#FF7256">1.MTU最大传输单元</font></strong></h5><p>这个最大传输单元实际上和链路层协议有着密切的关系，Ethernet帧的结构DMAC+SMAC+Type+Data+CRC，由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64bytes最大不能超过1518bytes，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。（注：小于64Bytes的数据帧一般是由于以太网冲突产生的“碎片”或者线路干扰或者坏的以太网接口产生的，对于大于1518Bytes的数据帧我们一般把它叫做Giant帧，这种一般是由于线路干扰或者坏的以太网口产生）</p>
<p>由于以太网EthernetII最大的数据帧是1518Bytes这样，刨去以太网帧的帧头（DMAC目的MAC地址48bit=6Bytes+SMAC源MAC地址48bit=6Bytes+Type域2bytes）14Bytes和帧尾CRC校验部分4Bytes（这个部门有时候大家也把它叫做FCS），那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。这个就是网络层协议非常关心的地方，因为网络层协议比如IP协议会根据这个值来决定是否把上层传下来的数据进行分片。</p>
<p>当两台远程PC互联的时候，它们的数据需要穿过很多的路由器和各种各样的网络媒介才能到达对端，网络中不同媒介的MTU各不相同，就好比一长段的水管，由不同粗细的水管组成（MTU不同 ）通过这段水管最大水量就要由中间最细的水管决定。</p>
<p>对于网络层的上层协议而言（我们以TCP/IP协议族为例）它们对水管粗细不在意它们认为这个是网络层的事情。网络层IP协议会检查每个从上层协议下来的数据包的大小，并根据本机MTU的大小决定是否作“分片”处理。分片最大的坏处就是降低了传输性能，本来一次可以搞定的事情，分成多次搞定，所以在网络层更高一层（就是传输层）的实现中往往会对此加以注意！有些高层因为某些原因就会要求我这个面包不能切片，我要完整地面包，所以会在IP数据包包头里面加上一个标签：DF（Donot Fragment）。这样当这个IP数据包在一大段网络（水管里面）传输的时候，如果遇到MTU小于IP数据包的情况，转发设备就会根据要求丢弃这个数据包。然后返回一个错误信息给发送者。这样往往会造成某些通讯上的问题，不过幸运的是大部分网络链路都是MTU1500或者大于1500。</p>
<p>对于UDP协议而言，这个协议本身是无连接的协议，对数据包的到达顺序以及是否正确到达不甚关心，所以一般UDP应用对分片没有特殊要求。</p>
<p>对于TCP协议而言就不一样了，这个协议是面向连接的协议，对于TCP协议而言它非常在意数据包的到达顺序以及是否传输中有错误发生。所以有些TCP应用对分片有要求—不能分片（DF）。</p>
<h5 id="2-PPPoE"><a href="#2-PPPoE" class="headerlink" title="2.PPPoE"></a><strong><font color="#FF7256">2.PPPoE</font></strong></h5><p>所谓PPPoE就是在以太网上面跑PPP协议，有人奇怪了，PPP协议和Ethernet不都是链路层协议吗？怎么一个链路层跑到另外一个链路层上面去了，难道升级成网络层协议了不成。其实这是个误区：就是某层协议只能承载更上一层协议。</p>
<p>为什么会产生这种奇怪的需求呢？这是因为随着宽带接入（这种宽带接入一般为Cable Modem或者xDSL或者以太网的接入）由于以太网缺乏认证计费机制而传统运营商是通过PPP协议来对拨号等接入服务进行认证计费的，所以就出了这么一个怪胎：PPPoE。（有关PPPoE的详细介绍参见V大以及本站其他成员的一些介绍文章，我就不啰里啰唆的了）</p>
<p>PPPoE带来了好处，也带来了一些坏处，比如：二次封装耗费资源，降低了传输效能等等，这些坏处俺也不多说了，最大的坏处就是PPPoE导致MTU变小了以太网的MTU是1500，再减去PPP的包头包尾的开销（8Bytes），就变成1492。</p>
<p>如果两台主机之间的某段网络使用了PPPoE那么就会导致某些不能分片的应用无法通讯。</p>
<p>这个时候就需要我们调整一下主机的MTU，通过降低主机的MTU，这样我们就能够顺利地进行通讯了。</p>
<h5 id="3-MSS最大传输大小"><a href="#3-MSS最大传输大小" class="headerlink" title="3.MSS最大传输大小"></a><strong><font color="#FF7256">3.MSS最大传输大小</font></strong></h5><p>TCP协议里面的一个概念。MSS就是TCP数据包每次能够传输的最大数据分段。为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以往往MSS为1460。通讯双方会根据双方提供的MSS值得最小值确定为这次连接的最大MSS值。</p>
<h4 id="五、ARP"><a href="#五、ARP" class="headerlink" title="五、ARP"></a><strong><font color="#FF7256">五、ARP</font></strong></h4><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。</p>
<p>OSI模型把网络工作分为七层，IP地址在OSI模型的第三层，MAC地址在第二层，彼此不直接打交道。在通过以太网发送IP数据包时，需要先封装第三层（32位IP地址）、第二层（48位MAC地址）的报头，但由于发送时只知道目标IP地址，不知道其MAC地址，又不能跨第二、三层，所以需要使用地址解析协议。使用地址解析协议，可根据网络层IP数据包包头中的IP地址信息解析出目标硬件地址（MAC地址）信息，以保证通信的顺利进行。</p>
<h5 id="ARP的工作原理"><a href="#ARP的工作原理" class="headerlink" title="ARP的工作原理"></a><strong><font color="#FF7256">ARP的工作原理</font></strong></h5><ol>
<li><p>首先，每台主机都会在自己的ARP缓冲区 (ARP Cache)中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。</p>
</li>
<li><p>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有﹐就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。</p>
</li>
<li><p>网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址； </p>
</li>
<li>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li>
</ol>
<h5 id="工作要素：ARP缓存"><a href="#工作要素：ARP缓存" class="headerlink" title="工作要素：ARP缓存"></a><strong><font color="#FF7256">工作要素：ARP缓存</font></strong></h5><p>ARP缓存是个用来储存IP地址和MAC地址的缓冲区，其本质就是一个IP地址–&gt;MAC地址的对应表，表中每一个条目分别记录了网络上其他主机的IP地址和对应的MAC地址。每一个以太网或令牌环网络适配器都有自己单独的表。当地址解析协议被询问一个已知IP地址节点的MAC地址时，先在ARP缓存中查看，若存在，就直接返回与之对应的MAC地址，若不存在，才发送ARP请求向局域网查询。</p>
<p>为使广播量最小，ARP维护IP地址到MAC地址映射的缓存以便将来使用。ARP缓存可以包含动态和静态项目。动态项目随时间推移自动添加和删除。每个动态ARP缓存项的潜在生命周期是10分钟。新加到缓存中的项目带有时间戳，如果某个项目添加后2分钟内没有再使用，则此项目过期并从ARP缓存中删除；如果某个项目已在使用，则又收到2分钟的生命周期；如果某个项目始终在使用，则会另外收到2分钟的生命周期，一直到10分钟的最长生命周期。静态项目一直保留在缓存中，直到重新启动计算机为止。</p>
<h5 id="工作媒介：报文"><a href="#工作媒介：报文" class="headerlink" title="工作媒介：报文"></a><strong><font color="#FF7256">工作媒介：报文</font></strong></h5><p><img src="http://imgchr.com/images/arp.png" alt="@ARP协议头"></p>
<p>硬件类型：指明了发送方想知道的硬件接口类型，以太网的值为1；<br>协议类型：指明了发送方提供的高层协议类型，IP为0800（16进制）；<br>硬件地址长度和协议长度：指明了硬件地址和高层协议地址的长度，这样ARP报文就可以在任意硬件和任意协议的网络中使用；<br>操作类型：用来表示这个报文的类型，ARP请求为1，ARP响应为2，RARP请求为3，RARP响应为4；<br>发送方硬件地址（0-3字节）：源主机硬件地址的前3个字节；<br>发送方硬件地址（4-5字节）：源主机硬件地址的后3个字节；<br>发送方IP地址（0-1字节）：源主机硬件地址的前2个字节；<br>发送方IP地址（2-3字节）：源主机硬件地址的后2个字节；<br>目标硬件地址（0-1字节）：目的主机硬件地址的前2个字节；<br>目标硬件地址（2-5字节）：目的主机硬件地址的后4个字节；<br>目标IP地址（0-3字节）：目的主机的IP地址。</p>
<h5 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a><strong><font color="#FF7256">ARP欺骗</font></strong></h5><p>地址解析协议是建立在网络中各个主机互相信任的基础上的，它的诞生使得网络能够更加高效的运行，但其本身也存在缺陷：</p>
<p>ARP地址转换表是依赖于计算机中高速缓冲存储器动态更新的，而高速缓冲存储器的更新是受到更新周期的限制的，只保存最近使用的地址的映射关系表项，这使得攻击者有了可乘之机，可以在高速缓冲存储器更新表项之前修改地址转换表，实现攻击。ARP请求为广播形式发送的，网络上的主机可以自主发送ARP应答消息，并且当其他主机收到应答报文时不会检测该报文的真实性就将其记录在本地的MAC地址转换表，这样攻击者就可以向目标主机发送伪ARP应答报文，从而篡改本地的MAC地址表。ARP欺骗可以导致目标计算机与网关通信失败，更会导致通信重定向，所有的数据都会通过攻击者的机器，因此存在极大的安全隐患。</p>
<p><strong><font color="#FF7256">防御措施</font></strong></p>
<ol>
<li>不要把网络安全信任关系建立在IP基础上或MAC基础上（RARP同样存在欺骗的问题），理想的关系应该建立在IP+MAC基础上。</li>
<li>设置静态的MAC–&gt;IP对应表，不要让主机刷新设定好的转换表。</li>
<li>除非很有必要，否则停止使用ARP，将ARP做为永久条目保存在对应表中。</li>
<li>使用ARP服务器。通过该服务器查找自己的ARP转换表来响应其他机器的ARP广播。</li>
<li>确保这台ARP服务器不被黑。</li>
<li>使用“proxy”代理IP的传输。</li>
<li>使用硬件屏蔽主机。设置好路由，确保IP地址能到达合法的路径（静态配置路由ARP条目），注意，使用交换集线器和网桥无法阻止ARP欺骗。</li>
<li>管理员定期用响应的IP包中获得一个RARP请求，然后检查ARP响应的真实性。</li>
<li>管理员定期轮询，检查主机上的ARP缓存。</li>
<li>使用防火墙连续监控网络。注意有使用SNMP的情况下，ARP的欺骗有可能导致陷阱包丢失。</li>
<li>若感染ARP病毒，可以通过清空ARP缓存、指定ARP对应关系、添加路由信息、使用防病毒软件等方式解决。</li>
</ol>
<h5 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a><strong><font color="#FF7256">RARP</font></strong></h5><p>地址解析协议是根据IP地址获取物理地址的协议，而反向地址转换协议（RARP）是局域网的物理机器从网关服务器的ARP表或者缓存上根据MAC地址请求IP地址的协议，其功能与地址解析协议相反。与ARP相比，RARP的工作流程也相反。首先是查询主机向网路送出一个RARP Request广播封包，向别的主机查询自己的IP地址。这时候网络上的RARP服务器就会将发送端的IP地址用RARP Reply封包回应给查询者，这样查询主机就获得自己的IP地址了。</p>
<h6 id="RARP的工作原理"><a href="#RARP的工作原理" class="headerlink" title="RARP的工作原理"></a><strong><font color="#FF7256">RARP的工作原理</font></strong></h6><ol>
<li><p>发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</p>
</li>
<li><p>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</p>
</li>
<li><p>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</p>
</li>
<li><p>如果不存在，RARP服务器对此不做任何的响应；</p>
</li>
<li><p>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p>
</li>
</ol>
<h5 id="代理ARP"><a href="#代理ARP" class="headerlink" title="代理ARP"></a><strong><font color="#FF7256">代理ARP</font></strong></h5><p>地址解析协议工作在一个网段中，而代理ARP（Proxy ARP，也被称作混杂ARP（Promiscuous ARP） ）工作在不同的网段间，其一般被像路由器这样的设备使用，用来代替处于另一个网段的主机回答本网段主机的ARP请求。例如，主机PC1（192.168.20.66/24）需要向主机PC2（192.168.20.20/24）发送报文，因为主机PC1不知道子网的存在且和目标主机PC2在同一主网络网段，所以主机PC1将发送ARP协议请求广播报文请求192.168.20.20的MAC地址。这时，路由器将识别出报文的目标地址属于另一个子网（注意，路由器的接口IP地址配置的是28位的掩码），因此向请求主机回复自己的硬件地址（0004.dd9e.cca0）。之后，PC1将发往PC2的数据包都发往MAC地址0004.dd9e.cca0（路由器的接口E0/0），由路由器将数据包转发到目标主机PC2。（接下来路由器将为PC2做同样的代理发送数据包的工作）。代理ARP协议使得子网化网络拓扑对于主机来说时透明的（或者可以说是路由器以一个不真实的PC2的MAC地址欺骗了源主机PC1）。</p>
<h5 id="NDP"><a href="#NDP" class="headerlink" title="NDP"></a><strong><font color="#FF7256">NDP</font></strong></h5><p>地址解析协议是IPv4中必不可少的协议，但在IPv6中将不再存在地址解析协议。在IPv6中，地址解析协议的功能将由NDP（邻居发现协议，Neighbor Discovery Protocol）实现，它使用一系列IPv6控制信息报文（ICMPv6）来实现相邻节点（同一链路上的节点）的交互管理，并在一个子网中保持网络层地址和数据链路层地址之间的映射。邻居发现协议中定义了5种类型的信息：路由器宣告、路由器请求、路由重定向、邻居请求和邻居宣告。与ARP相比，NDP可以实现路由器发现、前缀发现、参数发现、地址自动配置、地址解析（代替ARP和RARP）、下一跳确定、邻居不可达检测、重复地址检测、重定向等更多功能。</p>
<blockquote>
<p><strong><font color="#AA7256">NDP与ARP的区别</font></strong></p>
</blockquote>
<ol>
<li>IPv4中地址解析协议是独立的协议，负责IP地址到MAC地址的转换，对不同的数据链路层协议要定义不同的地址解析协议。IPv6中NDP包含了ARP的功能，且运行于因特网控制信息协议ICMPv6上，更具有一般性，包括更多的内容，而且适用于各种数据链路层协议；</li>
<li>地址解析协议以及ICMPv4路由器发现和ICMPv4重定向报文基于广播，而NDP的邻居发现报文基于高效的组播和单播。</li>
</ol>
<h4 id="六、ICMP"><a href="#六、ICMP" class="headerlink" title="六、ICMP"></a><strong><font color="#FF7256">六、ICMP</font></strong></h4><p>ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。它是一个非常重要的协议，它对于网络安全具有极其重要的意义。</p>
<p>它是TCP/IP协议族的一个子协议，属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。ICMP报文在IP帧结构的首部协议类型字段(Protocol 8bit)的值=1。</p>
<p>ICMP包有一个8字节长的包头，其中前4个字节是固定的格式，包含8位类型字段，8位代码字段和16位的校验和，后4个字节根据ICMP包的类型而取不同的值。</p>
<p>ICMP提供一致易懂的出错报告信息。发送的出错报文返回到发送原数据的设备，因为只有发送设备才是出错报文的逻辑接受者。发送设备随后可根据ICMP报文确定发生错误的类型，并确定如何才能更好地重发失败的数据包。但是ICMP唯一的功能是报告问题而不是纠正错误，纠正错误的任务由发送方完成。</p>
<p>我们在网络中经常会使用到ICMP协议，比如我们经常使用的用于检查网络通不通的Ping命令（Linux和Windows中均有），这个“Ping”的过程实际上就是ICMP协议工作的过程。还有其他的网络命令如跟踪路由的Tracert命令也是基于ICMP协议的。</p>
<h5 id="ICMP报文头"><a href="#ICMP报文头" class="headerlink" title="ICMP报文头"></a><strong><font color="#FF7256">ICMP报文头</font></strong></h5><p><img src="http://imgchr.com/images/ICMP.png" alt="ICMP报文"></p>
<p>ICMP全名为(internet control message protocol)网络控制消息协议，ICMP的协议号为1，在IP报文内部，规范定义在RFC792，从技术角度来说，ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其功能主要有：</p>
<p>a . 侦测远端主机是否存在。<br>b . 建立及维护路由资料。<br>c . 重导资料传送路径（ICMP重定向）。<br>d . 资料流量控制。ICMP在沟通之中，主要是透过不同的类别(Type)与代码(Code) 让机器  来识别不同的连线状况。常用的类别如下表所列﹕<br>ICMP 是个非常有用的协议﹐尤其是当我们要对网路连接状况进行判断的时候。</p>
<p>CMP协议对于网络安全具有极其重要的意义。ICMP协议本身的特点决定了它非常容易被用于攻击网络上的路由器和主机。比如，可以利用操作系统规定的ICMP数据包最大尺寸不超过64KB这一规定，向主机发起“Ping of Death”（死亡之Ping）攻击。“Ping of Death” 攻击的原理是：如果ICMP数据包的尺寸超过64KB上限时，主机就会出现内存分配错误，导致TCP/IP堆栈崩溃，致使主机死机。（操作系统已经取消了发送ICMP数据包的大小的限制，解决了这个漏洞）此外，向目标主机长时间、连续、大量地发送ICMP数据包，也会最终使系统瘫痪。大量的ICMP数据包会形成“ICMP风暴”，使得目标主机耗费大量的CPU资源处理，疲于奔命。</p>
<p>防御方法：</p>
<ol>
<li>选择合适的防火墙</li>
</ol>
<p>有效防止ICMP攻击，防火墙应该具有状态检测、细致的数据包完整性检查和很好的过滤规则控制功能。</p>
<p>状态检测防火墙通过跟踪它的连接状态，动态允许外出数据包的响应信息进入防火墙所保护的网络。例如，状态检测防火墙可以记录一个出去的 PING（ICMP Echo Request），在接下来的一个确定的时间段内，允许目标主机响应的ICMP Echo Reply直接发送给前面发出了PING命令的IP，除此之外的其他ICMP Echo Reply消息都会被防火墙阻止。与此形成对比的是，包过滤类型的防火墙允许所有的ICMP Echo Reply消息进入防火墙所保护的网络了。许多路由器和基于Linux内核2.2或以前版本的防火墙系统，都属于包过滤型，用户应该避免选择这些系统。</p>
<p>新的攻击不断出现，防火墙仅仅能够防止已知攻击是远远不够的。通过对所有数据包进行细致分析，删除非法的数据包，防火墙可以防止已知和未知的 DoS攻击。这就要求防火墙能够进行数据包一致性检查。安全策略需要针对ICMP进行细致的控制。因此防火墙应该允许对ICMP类型、代码和包大小进行过滤，并且能够控制连接时间和ICMP包的生成速率。</p>
<ol>
<li>配置防火墙以预防攻击</li>
</ol>
<p>一旦选择了合适的防火墙，用户应该配置一个合理的安全策略。以下是被普遍认可的防火墙安全配置惯例，可供管理员在系统安全性和易用性之间作出权衡。<br>防火墙应该强制执行一个缺省的拒绝策略。除了出站的ICMP Echo Request、出站的ICMP Source Quench、进站的TTL Exceeded和进站的ICMP Destination Unreachable之外，所有的ICMP消息类型都应该被阻止。</p>
<h5 id="ICMP类型"><a href="#ICMP类型" class="headerlink" title="ICMP类型"></a><strong><font color="#FF7256">ICMP类型</font></strong></h5><p>ICMP报文主要有两大功能：查询报文和差错报文。具体类型如下：</p>
<p><img src="http://imgchr.com/images/6a6d58646f6af49d.png" alt=""></p>
<h6 id="ICMP-差错报文"><a href="#ICMP-差错报文" class="headerlink" title="ICMP 差错报文"></a><strong><font color="#FF7256">ICMP 差错报文</font></strong></h6><p>　　当发送一份差错报文时，报文始终包含 IP 的首部和产生 ICMP 差错报文的 IP 数据报的前 8 位字节。这样，接收 ICMP 差错报文的模块就会把它与某个特定的协议(根据 IP 数据报首部中的协议字段来判断)和用户进程(根据包含在 IP 数据报前 8 个字节中的 TCP 或 UDP 报文首部中的 TCP 或 UDP 端口号来判断)联系起来。</p>
<p>　　下面各种情况不会导致产生 ICMP 差错报文：</p>
<p>　　1. ICMP 报文差错(ICMP查询报文可能会产生ICMP差错报文);</p>
<p>　　2. 目的地址是广播地址或多播地址的 IP 数据报;</p>
<p>　　3. 作为链路层广播的数据报;</p>
<p>　　4. 不是 IP 分片的第一片;</p>
<p>　　5. 源地址不是单个主机的数据报，也就是说，源地址不可能是零地址、环回地址、广播地址或多播地址。</p>
<p>　　以下针对 ICMP 差错报文的类型进行分析：</p>
<p>　　1、ICMP 目标不可达消息：IP 路由器无法将 IP 数据报发送给目的地址时，会给发送端主机返回一个目标不可达 ICMP 消息，并在这个消息中显示不可达的具体原因。</p>
<p>　　2、ICMP 重定向消息：如果路由器发现发送端主机使用次优的路径发送数据时，那么它会返回一个 ICMP 重定向消息给这个主机，这个消息包含了最合适的路由信息和源数据。主要发生在路由器持有更好的路由信息的情况下，路由器会通过这个 ICMP 重定向消息给发送端主机一个更合适的发送路由。</p>
<p>　　3、ICMP 超时消息：IP 数据包中有一个字段 TTL(Time to live，生存周期)，它的值随着每经过一个路由器就会减 1，直到减到 0 时该 IP 数据包被丢弃。此时，IP 路由器将发送一个 ICMP 超时消息给发送端主机，并通知该包已被丢弃。</p>
<p>　　4、源抑制消息：当 TCP/IP 主机发送数据到另一主机时，如果速度达到路由器或者链路的饱和状态，路由器发出一个 ICMP 源抑制消息。</p>
<h6 id="ICMP-查询报文"><a href="#ICMP-查询报文" class="headerlink" title="ICMP 查询报文　"></a><strong><font color="#FF7256">ICMP 查询报文</font></strong>　</h6><p>　　ICMP 回送消息：用于进行通信的主机或路由之间，判断发送数据包是否成功到达对端的消息。可以向对端主机发送回送请求消息，也可以接收对端主机回来的回送应答消息。</p>
<p>　　ICMP 地址掩码消息：主要用于主机或路由想要了解子网掩码的情况。可以向那些主机或路由器发送 ICMP 地址掩码请求消息，然后通过接收 ICMP 地址掩码应答消息获取子网掩码信息。</p>
<p>　　ICMP 时间戳消息：可以向那些主机或路由器发送 ICMP 时间戳请求消息，然后通过接收 ICMP 时间戳应答消息获取时间信息。</p>
<h6 id="Ping-程序"><a href="#Ping-程序" class="headerlink" title="Ping 程序　　"></a><strong><font color="#FF7256">Ping 程序</font></strong>　　</h6><p>　　Ping 程序利用 ICMP 回显请求报文和回显应答报文(而不用经过传输层)来测试目标主机是否可达。它是一个检查系统连接性的基本诊断工具。</p>
<p>　　ICMP 回显请求和 ICMP 回显应答报文是配合工作的。当源主机向目标主机发送了 ICMP 回显请求数据包后，它期待着目标主机的回答。目标主机在收到一个 ICMP 回显请求数据包后，它会交换源、目的主机的地址，然后将收到的 ICMP 回显请求数据包中的数据部分原封不动地封装在自己的 ICMP 回显应答数据包中，然后发回给发送 ICMP 回显请求的一方。如果校验正确，发送者便认为目标主机的回显服务正常，也即物理连接畅通。</p>
<h6 id="Traceroute-程序"><a href="#Traceroute-程序" class="headerlink" title="Traceroute 程序　"></a><strong><font color="#FF7256">Traceroute 程序</font></strong>　</h6><p>　　Traceroute 程序主要用来侦测源主机到目的主机之间所经过的路由的情况。</p>
<p>　　Traceroute 使用 ICMP 报文和 IP 首部中的 TTL 字段，它充分利用了 ICMP 超时消息。其原理很简单，开始时发送一个 TTL 字段为 1 的 UDP 数据报，而后每次收到 ICMP 超时萧后，按顺序再发送一个 TTL 字段加 1 的 UDP 数据报，以确定路径中的每个路由器，而每个路由器在丢弃 UDP 数据报时都会返回一个 ICMP 超时报文，而最终到达目的主机后，由于 ICM P选择了一个不可能的值作为 UDP 端口(大于30000)。这样目的主机就会发送一个端口不可达的 ICMP 差错报文。</p>
<h4 id="七、IGMP协议"><a href="#七、IGMP协议" class="headerlink" title="七、IGMP协议　"></a><strong><font color="#FF7256">七、IGMP协议</font></strong>　</h4><p>IGMP(Internet Group Manage Protocol)：Internet组管理协议,提供internet网际多点<br>传送的功能,即将一个ip包拷贝给多个host，windows系列采用了这个协议，因为此项技术尚不成熟，因此被一些人用来攻击windows系统，尤其是对win98，因为对win95有oob攻击。受到IGMP攻击的症状是首先出现蓝屏,然后网速变得极慢,有的甚至鼠标,键盘均不管用，非得重启不可。</p>
<p>正如ICMP一样， IGMP 也被当作IP 层的一部分。IGMP报文通过IP数据报进行传输。不像我们已经见到的其他协议， IGMP有固定的报文长度，没有可选数据。图13-1显示了IGMP报文如何封装在IP数据报中。</p>
<p><img src="http://imgchr.com/images/IGMP2.png" alt="enter image description here"></p>
<p>IGMP报文通过IP首部中协议字段值为2来指明。</p>
<h5 id="IGMP报文"><a href="#IGMP报文" class="headerlink" title=" IGMP报文　"></a><strong><font color="#FF7256"> IGMP报文</font></strong>　</h5><p><img src="http://imgchr.com/images/igmp.png" alt="enter image description here"></p>
<p>　　这是版本为1的IGMP.IGMP类型为1说明是由多播路由器发出的查询报文，为2说明是主机发出的报告报文。检验和的计算和ICMP协议相同。</p>
<p>　　组地址为D类IP地址。在查询报文中组地址设置为0，在报告报文中组地址为要参加的组地址。</p>
<h5 id="单播-unicast"><a href="#单播-unicast" class="headerlink" title="单播(unicast)　"></a><strong><font color="#FF7256">单播(unicast)</font></strong>　</h5><p>单播是说，对特定的主机进行数据传送。例如给某一个主机发送IP数据包。这时候，数据链路层给出的数据头里面是非常具体的目的地址，对于以太网来 说，就是网卡的MAC地址（不是FF-FF-FF-FF-FF-FF这样的地址）。现在的具有路由功能的主机应该可以将单播数据定向转发，而目的主机的网 络接口则可以过滤掉和自己MAC地址不一致的数据。</p>
<h5 id="广播-unicast"><a href="#广播-unicast" class="headerlink" title="广播(unicast)　"></a><strong><font color="#FF7256">广播(unicast)</font></strong>　</h5><p>广播是主机针对某一个网络上的所有主机发送数据包。这个网络可能是网络，可能是子网，还可能是所有的子网。如果是网络，例如A类网址的广播就是 netid.255.255.255，如果是子网，则是netid.netid.subnetid.255；如果是所有的子网（B类IP）则是则是 netid.netid.255.255。广播所用的MAC地址FF-FF-FF-FF-FF-FF。网络内所有的主机都会收到这个广播数据，网卡只要把 MAC地址为FF-FF-FF-FF-FF-FF的数据交给内核就可以了。一般说来ARP，或者路由协议RIP应该是以广播的形式播发的。</p>
<h5 id="多播-multicast"><a href="#多播-multicast" class="headerlink" title="多播(multicast)　"></a><strong><font color="#FF7256">多播(multicast)</font></strong>　</h5><p>　　多播路由器使用IGMP报文来记录与该路由器相连网络中组成员的变化情况。使用规则如下：</p>
<p>　　1） 当第一个进程加入一个组时，主机就发送一个IGMP报告。如果一个主机的多个进程加入同一组，只发送一个IGMP报告。这个报告被发送到进程加入组所在的同一接口上。</p>
<p>　　2） 进程离开一个组时，主机不发送IGMP报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的IGMP查询中就不再发送报告报文。</p>
<p>　　3） 多播路由器定时发送IGMP查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个IGMP查询。因为路由器希望主机对它加入的每个多播组均发回一个报告，因此IGMP查询报文中的组地址被设置为0.</p>
<p>　　4） 主机通过发送IGMP报告来响应一个IGMP查询，对每个至少还包含一个进程的组均要发回IGMP报告。</p>
<p>　　使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使用相应的多播链路层地址）还拥有属于那个组主机的接口上。</p>
<p>可以说广播是多播的特例，多播就是给一组特定的主机（多播组）发送数据，这样，数据的播发范围会小一些(实际上播发的范围一点也没有变小)，多播的MAC地址是最高字节的低位为一，例 如01-00-00-00-00-00。多播组的地址是D类IP，规定是224.0.0.0-239.255.255.255。 </p>
<p>虽然多播比较特殊，但是究其原理，多播的数据还是要通过数据链路层进行MAC地址绑定然后进行发送。所以一个以太网卡在绑定了一个多播IP地址之后，必 定还要绑定一个多播的MAC地址，才能使得其可以像单播那样工作。这个多播的IP和多播MAC地址有一个对应的算法，在书的p133到p134之间。可以看到 这个对应不是一一对应的，主机还是要对多播数据进行过滤。</p>
<p>广播和多播的性质是一样的，路由器会把数据放到局域网里面，然后网卡对这些数据进行过滤，只拿到自己打算要的数据，比如自己感兴趣的多播数据，自己感兴趣的组播数据。当一个主机运行了一个处理某一个多播IP的进程的时候，这个进程会给网卡绑定一个虚拟的多播mac地址，并做出来一个多播 ip。这样，网卡就会让带有这个多播mac地址的数据进来，从而实现通信，而那些没有监听这些数据的主机就会把这些数据过滤掉，换句话说，多播是让主机 的内核轻松了，而网卡负担加重。</p>
<h5 id="IGMP的工作过程"><a href="#IGMP的工作过程" class="headerlink" title="IGMP的工作过程　"></a><strong><font color="#FF7256">IGMP的工作过程</font></strong>　</h5><ol>
<li><p>当主机加入一个新的工作组时,它发送一个igmp host membership report的报文给全部主机组,宣布此成员关系.本地多点广播路由器接受到这个报文后,向Internet上的其他多路广播路由器传播这个关系信息,建立必要的路由.与此同时,在主机的网络接口上将ip主机组地址映射为mac地址,并重新设置地址过滤器.</p>
</li>
<li><p>为了处理动态的成员关系,本地多路广播路由器周期性的轮询本地网络上的主机,以便确定在各个主机组有哪些主机,这个轮询过程是通过发送igmp host membership query报文来实现的,这个报文发送给全部主机组,且报文的ttl域设为1,以确保报文不会传送到lan以外.受到报文的主机组成员会发送响应报文.如果所有的主机组成员同时响应的话,就可能造成网络阻塞.IGMP协议采用了随机延时的方法来避免这个情况.这样就保证了在同一时刻每个主机组中只有一个成员在发送响应报文。</p>
</li>
</ol>
<p>IGMP的作用在于，让其他所有需要知道自己处于哪个多播组的主机和路由器知道自己的状态。一般多播路由器根本不需要知道某一个多播组里面有多少个主机，而只要知道自己的子网内还有没有处于某个多播组的主机就可以了。只要某一个多播组还有一台主机，多播路由器就会把数据传输出去，这样，接受方就会通过网卡过滤功能来得到自己想要的数据。为了知道多播组的信息，多播路由器需要定时的发送IGMP查询，IGMP的格式可以看书，各个多播组里面的主机要根据查询来回复自己的状态。路由器来决定有几个多播组，自己要对某一个多播组发送什么样的数据。</p>
<p>这种查询回应数据报的TTL一般是1，而且就算是出错也不产生ICMP差错（没必要）。</p>
<p>附上部分参考链接：</p>
<p><a href="http://network.51cto.com/art/201307/405259.htm" target="_blank" rel="external">http://network.51cto.com/art/201307/405259.htm</a><br><a href="http://network.chinabyte.com/23/13155523.shtml" target="_blank" rel="external">http://network.chinabyte.com/23/13155523.shtml</a><br><a href="http://blog.csdn.net/xifeijian/article/details/44261821" target="_blank" rel="external">http://blog.csdn.net/xifeijian/article/details/44261821</a><br><a href="http://blog.chinaunix.net/uid-26833883-id-3627644.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26833883-id-3627644.html</a><br><a href="http://blog.csdn.net/a19881029/article/details/38091243/" target="_blank" rel="external">http://blog.csdn.net/a19881029/article/details/38091243/</a><br><a href="http://www.cnblogs.com/fengzanfeng/articles/1339347.html" target="_blank" rel="external">http://www.cnblogs.com/fengzanfeng/articles/1339347.html</a><br><a href="http://blog.csdn.net/chengqianyun2002/article/details/1699235" target="_blank" rel="external">http://blog.csdn.net/chengqianyun2002/article/details/1699235</a><br><a href="http://www.cnblogs.com/feitian629/archive/2012/11/16/2774065.html" target="_blank" rel="external">http://www.cnblogs.com/feitian629/archive/2012/11/16/2774065.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TCP-IP协议分层&quot;&gt;&lt;a href=&quot;#TCP-IP协议分层&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议分层&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;font color=&quot;#FF7256&quot;&gt;TCP/IP协议分层&lt;/font&gt;&lt;/strong&gt;
    
    </summary>
    
      <category term="网络请求及框架" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%8F%8A%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="http/https" scheme="http://yoursite.com/tags/http-https/"/>
    
      <category term="retrofit2" scheme="http://yoursite.com/tags/retrofit2/"/>
    
      <category term="OkHttp3" scheme="http://yoursite.com/tags/OkHttp3/"/>
    
      <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="UDP" scheme="http://yoursite.com/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>Android多线程</title>
    <link href="http://yoursite.com/2016/08/13/%E5%AF%BC%E8%AF%AD/"/>
    <id>http://yoursite.com/2016/08/13/导语/</id>
    <published>2016-08-13T03:21:19.000Z</published>
    <updated>2016-09-07T13:58:04.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a><strong>导语</strong></h2><blockquote>
<p>本文意在练习hexo，并非恶意盗用原作者文章来满足自己的虚荣心，本文出自：<a href="http://www.androidchina.net/5238.html" target="_blank" rel="external">Android 线程的正确使用姿势</a></p>
</blockquote>
<h2 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h2><blockquote>
<font color="#FF0000"><strong>关键字：多线程数据安全、死锁、内存消耗、UI卡顿、对象的生命周期管理</strong></font>

</blockquote>
<h3 id="一、-Process-Priority（进程优先级）："><a href="#一、-Process-Priority（进程优先级）：" class="headerlink" title="一、 Process Priority（进程优先级）："></a>一、 Process Priority（进程优先级）：</h3><h4 id="1-Foreground-Process："><a href="#1-Foreground-Process：" class="headerlink" title="1. Foreground Process："></a>1. Foreground Process：</h4><font size="4"> Foreground一般意味着用户双眼可见，可见却不一定是active。在Android的世界里，一个Activity处于前台之时，如果能采集用户的input事件，就可以判定为active，如果中途弹出一个Dialog，Dialog变成新的active实体，直接面对用户的操作。被部分遮挡的activity尽管依然可见，但状态却变为inactive。不能正确的区分visible和active是很多初级程序员会犯的错误。</font>

<h4 id="2-Background-Process："><a href="#2-Background-Process：" class="headerlink" title="2. Background Process："></a>2. Background Process：</h4><p>后台进程同样有更细的划分。所谓的Background可以理解为不可见（invisible）。对于不可见的任务，Android也有重要性的区分。重要的后台任务定义为Service，如果一个进程包含Service（称为Service Process），那么在“重要性”上就会被系统区别对待，其优先级自然会高于不包含Service的进程（称为Background Process），最后还剩一类空进程（Empty Process）。Empty Process初看有些费解，一个Process如果什么都不做，还有什么存在的必要。其实Empty Process并不Empty，还存在不少的内存占用。<br><img src="http://i2.piimg.com/567571/e238715c28695f96.png" alt="enter image description here"></p>
<h3 id="二、-Thread-Scheduling（线程调度）："><a href="#二、-Thread-Scheduling（线程调度）：" class="headerlink" title="二、 Thread Scheduling（线程调度）："></a>二、 Thread Scheduling（线程调度）：</h3><p>Linux系统的调度器在分配time slice的时候，采用的CFS（completely fair scheduler）策略。这种策略不但会参考单个线程的优先级，还会追踪每个线程已经获取到的time slice数量，如果高优先级的线程已经执行了很长时间，但低优先级的线程一直在等待，后续系统会保证低优先级的线程也能获取更多的CPU时间。显然使用这种调度策略的话，优先级高的线程并不一定能在争取time slice上有绝对的优势，所以Android系统在线程调度上使用了cgroups的概念，cgroups能更好的凸显某些线程的重要性，使得优先级更高的线程明确的获取到更多的time slice。</p>
<p>Android将线程分为多个group，其中两类group尤其重要。一类是default group，UI线程属于这一类。另一类是background group，工作线程应该归属到这一类。background group当中所有的线程加起来总共也只能分配到5～10%的time slice，剩下的全部分配给default group，这样设计显然能保证UI线程绘制UI的流畅性。</p>
<p>有不少人吐槽Android系统之所以不如iOS流畅，是因为UI线程的优先级和普通工作线程一致导致的。这其实是个误会，Android的设计者实际上提供了background group的概念来降低工作线程的CPU资源消耗，只不过与iOS不同的是，Android开发者需要显式的将工作线程归于background group。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line"> &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure></p>
<p>所以在我们决定新启一个线程执行任务的时候，首先要问自己这个任务在完成时间上是否重要到要和UI线程争夺CPU资源。如果不是，降低线程优先级将其归于background group，如果是，则需要进一步的profile看这个线程是否造成UI线程的卡顿。</p>
<p>虽说Android系统在任务调度上是以线程为基础单位，设置单个thread的优先级也可以改变其所属的control groups，从而影响CPU time slice的分配。但进程的属性变化也会影响到线程的调度，当一个App进入后台的时候，该App所属的整个进程都将进入background group，以确保处于foreground，用户可见的新进程能获取到尽可能多的CPU资源。用adb可以查看不同进程的当前调度策略。</p>
<blockquote>
<p>$ adb shell ps -P</p>
</blockquote>
<h3 id="三、-是否真的需要新线程？"><a href="#三、-是否真的需要新线程？" class="headerlink" title="三、 是否真的需要新线程？"></a>三、 是否真的需要新线程？</h3><p>开线程并不是提升App性能，解决UI卡顿的万金油。每一个新启的线程会消耗至少64KB的内存，系统在不同的线程之间switch context也会带来额外的开销。如果随意开启新线程，随着业务的膨胀，很容易在App运行的某个时间点发现几十个线程同时在运行。后果是原本想解决UI流畅性，却反而导致了偶现的不可控的卡顿。</p>
<p>移动端App新启线程一般都是为了保证UI的流畅性，增加App用户操作的响应度。但是否需要将任务放入工作线程需要先了解任务的瓶颈在哪，是i/o，gpu还是cpu？UI出现卡顿并不一定是UI线程出现了费时的计算，有可能是其它原因，比如layout层级太深。</p>
<p>尽量重用已有的工作线程（使用线程池）可以避免出现大量同时活跃的线程，比如对HTTP请求设置最大并发数。或者将任务放入某个串行的队列（HandlerThread）按顺序执行，工作线程任务队列适合处理大量耗时较短的任务，避免出现单个任务阻塞整个队列的情况。</p>
<h3 id="四、-用什么姿势开线程？"><a href="#四、-用什么姿势开线程？" class="headerlink" title="四、 用什么姿势开线程？"></a>四、 用什么姿势开线程？</h3><h4 id="new-Thread"><a href="#new-Thread" class="headerlink" title="new Thread()"></a><strong>new Thread()</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>这种方式仅仅是起动了一个新的线程，没有任务的概念，不能做状态的管理。start之后，run当中的代码就一定会执行到底，无法中途取消。</p>
<p>Runnable作为匿名内部类还持有了外部类的引用，在线程退出之前，该引用会一直存在，阻碍外部类对象被GC回收，在一段时间内造成内存泄漏。</p>
<p>没有线程切换的接口，要传递处理结果到UI线程的话，需要写额外的线程切换代码。</p>
<p>如果从UI线程启动，则该线程优先级默认为Default，归于default cgroup，会平等的和UI线程争夺CPU资源。这一点尤其需要注意，在对UI性能要求高的场景下要记得</p>
<pre><code>Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
</code></pre><p>虽说处于background group的线程总共只能争取到5～10%的CPU资源，但这对绝大部分的后台任务处理都绰绰有余了，1ms和10ms对用户来说，都是快到无法感知，所以我们一般都偏向于在background group当中执行工作线程任务。</p>
<h4 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a><strong>AsyncTask</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">protected</span> Object <span class="title">doInBackground</span><span class="params">(Object[] params)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"> &#125;</div><div class="line">  <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onPreExecute();</div><div class="line"> &#125;</div><div class="line">  <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onPostExecute(o);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和使用Thread()不同的是，多了几处API回调来严格规范工作线程与UI线程之间的交互。我们大部分的业务场景几乎都符合这种规范，比如去磁盘读取图片，缩放处理需要在工作线程执行，最后绘制到ImageView控件需要切换到UI线程。</p>
<p>AsyncTask的几处回调都给了我们机会去中断任务，在任务状态的管理上较之Thread()方式更为灵活。值得注意的是AsyncTask的cancel()方法并不会终止任务的执行，开发者需要自己去检查cancel的状态值来决定是否中止任务。</p>
<p>AsyncTask也有隐式的持有外部类对象引用的问题，需要特别注意防止出现意外的内存泄漏。</p>
<p>AsyncTask由于在不同的系统版本上串行与并行的执行行为不一致，被不少开发者所诟病，这确实是硬伤，绝大部分的多线程场景都需要明确任务是串行还是并行。</p>
<p>线程优先级为background，对UI线程的执行影响极小。</p>
<h4 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a><strong>HandlerThread</strong></h4><p>在需要对多任务做更精细控制，线程切换更频繁的场景之下，Thread()和AsyncTask都会显得力不从心。HandlerThread却能胜任这些需求甚至更多。</p>
<p>HandlerThread将Handler，Thread，Looper，MessageQueue几个概念相结合。Handler是线程对外的接口，所有新的message或者runnable都通过handler post到工作线程。Looper在MessageQueue取到新的任务就切换到工作线程去执行。不同的post方法可以让我们对任务做精细的控制，什么时候执行，执行的顺序都可以控制。HandlerThread最大的优势在于引入MessageQueue概念，可以进行多任务队列管理。</p>
<p>HandlerThread背后只有一个线程，所以任务是串行执行的。串行相对于并行来说更安全，各任务之间不会存在多线程安全问题。</p>
<p>HandlerThread所产生的线程会一直存活，Looper会在该线程中持续的检查MessageQueue。这一点和Thread()，AsyncTask都不同，thread实例的重用可以避免线程相关的对象的频繁重建和销毁。</p>
<p>HandlerThread较之Thread()，AsyncTask需要写更多的代码，但在实用性，灵活度，安全性上都有更好的表现。</p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a><strong>ThreadPoolExecutor</strong></h4><p>Thread(),AsyncTask适合处理单个任务的场景，HandlerThread适合串行处理多任务的场景。当需要并行的处理多任务之时，ThreadPoolExecutor是更好的选择。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Executor THREAD_POOL_EXECUTOR= <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure></p>
<p>线程池可以避免线程的频繁创建和销毁，显然性能更好，但线程池并发的特性往往也是疑难杂症的源头，是代码降级和失控的开始。多线程并行导致的bug往往是偶现的，不方便调试，一旦出现就会耗掉大量的开发精力。</p>
<p>ThreadPool较之HandlerThread在处理多任务上有更高的灵活性，但也带来了更大的复杂度和不确定性。</p>
<h4 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a><strong>IntentService</strong></h4><p>不得不说Android在API设计上粒度很细，同一样工作可以通过各种不同的类来完成。IntentService又是另一种开工作线程的方式，从名字就可以看出这个工作线程会带有service的属性。和AsyncTask不同，没有和UI线程的交互，也不像HandlerThread的工作线程会一直存活。IntentService背后其实也有一个HandlerThread来串行的处理Message Queue，从IntentService的onCreate方法可以看出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></div><div class="line"><span class="comment">// during processing, and to have a static startService(Context, Intent)</span></div><div class="line"><span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></div><div class="line"> <span class="keyword">super</span>.onCreate();</div><div class="line"> HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line"> thread.start();</div><div class="line"> mServiceLooper = thread.getLooper();</div><div class="line"> mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只不过在所有的Message处理完毕之后，工作线程会自动结束。所以可以把IntentService看做是Service和HandlerThread的结合体，适合需要在工作线程处理UI无关任务的场景。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h2><p>Android开线程的方式虽然五花八门，但归根到底最后还是映射到linux下的pthread，业务的设计还是脱不了和线程相关的基础概念范畴：线程的执行顺序，调度策略，生命周期，串行还是并行，同步还是异步等等。摸清楚各类API下线程的行为特点，在设计具体业务的线程模型的时候自然轻车熟路了，线程模型的设计要有整个app视角的广度，切忌各业务模块各玩各的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;&lt;strong&gt;导语&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文意在练习hexo，并非恶意盗用原作者文章来满足自己的虚荣心，本文出自：&lt;a 
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="关键字" scheme="http://yoursite.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>Hexo</title>
    <link href="http://yoursite.com/2016/08/09/Hexo/"/>
    <id>http://yoursite.com/2016/08/09/Hexo/</id>
    <published>2016-08-09T11:18:46.000Z</published>
    <updated>2016-09-03T15:57:21.974Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、-Hexo简介"><a href="#一、-Hexo简介" class="headerlink" title="一、 Hexo简介"></a><strong>一、 Hexo简介</strong></h4><hr>
<h4 id="二、-博客搭建"><a href="#二、-博客搭建" class="headerlink" title="二、 博客搭建"></a><strong>二、 博客搭建</strong></h4><h5 id="1-创建GitHub仓库"><a href="#1-创建GitHub仓库" class="headerlink" title="1. 创建GitHub仓库"></a>1. 创建GitHub仓库</h5><h5 id="2-Git-安装"><a href="#2-Git-安装" class="headerlink" title="2. Git 安装"></a>2. Git 安装</h5><h6 id="1-Windows-中"><a href="#1-Windows-中" class="headerlink" title="(1). Windows 中"></a>(1). Windows 中</h6><h6 id="2-Mac-OS-中"><a href="#2-Mac-OS-中" class="headerlink" title="(2). Mac OS 中"></a>(2). Mac OS 中</h6><h5 id="3-Node-js-安装"><a href="#3-Node-js-安装" class="headerlink" title="3. Node.js 安装"></a>3. Node.js 安装</h5><h6 id="1-Windows-中-1"><a href="#1-Windows-中-1" class="headerlink" title="(1). Windows 中"></a>(1). Windows 中</h6><h6 id="2-Mac-OS-中-1"><a href="#2-Mac-OS-中-1" class="headerlink" title="(2). Mac OS 中"></a>(2). Mac OS 中</h6><h5 id="4-Hexo-安装"><a href="#4-Hexo-安装" class="headerlink" title="4. Hexo 安装"></a>4. Hexo 安装</h5><h5 id="5-创建本地博客"><a href="#5-创建本地博客" class="headerlink" title="5. 创建本地博客"></a>5. 创建本地博客</h5><h5 id="6-Next-安装"><a href="#6-Next-安装" class="headerlink" title="6. Next 安装"></a>6. Next 安装</h5><h6 id="1-Next-配置"><a href="#1-Next-配置" class="headerlink" title="(1). Next 配置"></a>(1). Next 配置</h6><pre><code>Next 配置详解
</code></pre><p>Next 配置就是上面所说的”主题配置文件“，位于xxx.github.io/   themes/next 目录下，文件名为 _config.yml</p>
<h6 id="2-创建分类页面"><a href="#2-创建分类页面" class="headerlink" title="(2). 创建分类页面"></a>(2). 创建分类页面</h6><h6 id="3-创建标签云页面"><a href="#3-创建标签云页面" class="headerlink" title="(3). 创建标签云页面"></a>(3). 创建标签云页面</h6><hr>
<h4 id="三、-写博客与发布"><a href="#三、-写博客与发布" class="headerlink" title="三、 写博客与发布"></a><strong>三、 写博客与发布</strong></h4><h5 id="1-用Markdown写文章"><a href="#1-用Markdown写文章" class="headerlink" title="1. 用Markdown写文章"></a>1. 用Markdown写文章</h5><blockquote>
<p>说明：Next 主题会自动生成目录</p>
</blockquote>
<h5 id="2-在本地运行测试"><a href="#2-在本地运行测试" class="headerlink" title="2. 在本地运行测试"></a>2. 在本地运行测试</h5><pre><code>打开命令行定位到 xxx.github.io 目录，输入命令：
hexo s # 这是简写 == hexo server # 启动服务预览
或$ hexo s
</code></pre><h5 id="3-在浏览器查看效果"><a href="#3-在浏览器查看效果" class="headerlink" title="3. 在浏览器查看效果"></a>3. 在浏览器查看效果</h5><h5 id="4-安装自动部署发布工具"><a href="#4-安装自动部署发布工具" class="headerlink" title="4. 安装自动部署发布工具"></a>4. 安装自动部署发布工具</h5><h5 id="5-发布到-GitHubPages"><a href="#5-发布到-GitHubPages" class="headerlink" title="5. 发布到 GitHubPages"></a>5. 发布到 GitHubPages</h5>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、-Hexo简介&quot;&gt;&lt;a href=&quot;#一、-Hexo简介&quot; class=&quot;headerlink&quot; title=&quot;一、 Hexo简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、 Hexo简介&lt;/strong&gt;&lt;/h4&gt;&lt;hr&gt;
&lt;h4 id=&quot;二、-博客搭建&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="gihubpages" scheme="http://yoursite.com/tags/gihubpages/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
